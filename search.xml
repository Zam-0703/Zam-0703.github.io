<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AST-Task2]]></title>
    <url>%2F2019%2F10%2F16%2FAST-Task2%2F</url>
    <content type="text"><![CDATA[注意，本文编译环境为Visual Studio 2019 on Windows 10 1903 X64 几个练手题1.编程实现：用户给定一个整数，将该整数逆置之后输出。（如：输入123，输出321）。限制条件a.给定整数，不要用字符串来完成。b.尽可能使时间复杂度小。c.要求能够完成214748364792这个数字的逆置。 程序源码1234567891011121314#include&lt;stdio.h&gt;int main() &#123; long long int input; scanf_s("%lld", &amp;input); long long int output = 0, digit; while (input &gt; 0) &#123; digit = input % 10;//取当前最末位数 output = output * 10 + digit;//将当前的最末位数加到待输出结果的最后一位 input /= 10; &#125; printf("%lld", output); return 0;&#125; ###运行结果 2.编程实现：给定一串任意字符串。要求，将其中的所有整数提取出来并存入整数数组给定样例1023fase415#145# 程序源码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main(void)&#123; char str[1000]; int a[100]; int p, q; int i = 0, r = 0,count = 0;//i用于控制输出，r用于控制字符串内查找,count用于计算字符串内数字个数 gets(str); r = 0; while (1) &#123; while (str[r] &amp;&amp; (str[r]&lt;'0' || str[r]&gt;'9')) r++; //跳过字符串中非数字部分 if (str[r]) &#123; p = r; //p指向数字子串开头 q = r + 1; //q寻找数字串结尾 a[i] = str[r] - '0';//将字符串中的0变为数字0 while (str[q] &gt;= '0' &amp;&amp; str[q] &lt;= '9') &#123; a[i] = 10 * a[i] + (str[q] - '0');//计算数字 q++; &#125; count++; r = q; //设定新起点 i++; &#125; else break; &#125; for (i = 0; i &lt; count; i++) printf("%d ", a[i]); printf("\n"); return 0;&#125; 运行结果 3.编程实现：给定一串任意字符串。要求，将其中的所有数字提取出来并存入double数组。给定样例10.23fase4.15#14.5# 程序源码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; char str[1000], num[1000]; double a[100]; int p, q; int i = 0, r = 0,count = 0;//i用于控制循环，r用于控制字符串内查找,count用于计算字符串内数字个数 gets(str); r = 0; while (1) &#123; while (str[r] &amp;&amp; (str[r]&lt;'0' || str[r]&gt;'9')) &#123;//查找数字字串开头部分 r++; &#125; if (str[r]) &#123; p = r; //p指向数字子串开头 q = r + 1; //q寻找数字串结尾 while ((str[q] &gt;= '0' &amp;&amp; str[q] &lt;= '9')||str[q]=='.')&#123; q++; &#125; for (i = 0; i &lt; q-p; i++) &#123;//将数字字串转存到新字符串中，用于后续转化输出 num[i] = str[p + i]; &#125; num[i] = '\0'; a[count] = atof(num); count++; r = q; //设定新起点 &#125; else break; &#125; for (i = 0; i &lt; count; i++) printf("%lf ", a[i]); printf("\n"); return 0;&#125; 运行结果 几个烧脑题多级指针：观察下列代码，思考并解释程序运行结果1程序代码及解释12345678910111213#include &lt;stdio.h&gt;int main()&#123; char * c[] = &#123; "ENTER", "NEW", "POINT", "FIRST" &#125;;//定义了四个指针c[0]-c[3]分别指向四个字符串 char** cp[] = &#123; c + 3, c + 2, c + 1, c &#125;;//定义了一个二级指针数组，其中的cp[0]-cp[3]分别依次对应c[3]-c[0] char*** cpp = cp;//定义了一个三级指针，指向二级指针数组的第一个元素cp[0]，此时cpp就相当于c[3] printf("%s\n", ** ++cpp);//** cpp经过间接引用运算后相当于是指针cp，指针cp自增后指向的是指针数组cp[]中的第二个元素,也即是c[2] printf("%s\n", * --* ++cpp + 3);//首先对指针cpp作了自增操作，使得cpp指向cp[2],此时cpp中的地址为c+1，再通过自减符使得指针 * cpp即cp[2] (注意不是cpp)的地址变为c，这时候*--* ++cpp相当于指向了一个字符数组&#123;'E','N','T','E','R'&#125;的首地址。+3的操作等价于在这个字符数组的首地址的基础上再右移三个地址，指向了第二个E，然后通过printf将第二个E和之后的所有剩余字符全部打印。 printf("%s\n", * cpp[-2] + 3);//经过了上一条语句后，cpp指向cp[2],那么cpp[-2]指向cp[0]（注意，此时cpp内存储的地址并没有改变）,即c[3]此时的*cpp[-2]就相当于指向了一个字符数组&#123;'F','I','R','S','T'&#125;的首地址。+3的操作等价于在这个字符数组的首地址的基础上再右移三个地址，指向了S，然后通过printf将S和之后的所有剩余字符全部打印。 printf("%s\n", * cpp[-1][-1] + 1);//同上理，此时cpp指向cp[2],cpp[-1]就会指向cp[1]，即c[2],那么cpp[-1][-1]就相当于指向c[1],即一个字符数组&#123;'N','E','W'&#125;的首地址。+1的操作等价于在这个字符数组的首地址的基础上再右移1个地址，指向了E，然后通过printf将E和之后的所有剩余字符全部打印。 system("pause"); return 0;&#125; 上机验证 2程序代码1234567891011121314151617#include &lt;stdio.h&gt;struct Test&#123; int Num; char* pcName; short sDate; char cha[2]; short sBa[4];&#125;*p;int main()&#123; p = 0x100000; printf("%p\n", p + 0x1);//输出00100014 printf("%p\n", (unsigned long)p + 0x1);//输出00100001 printf("%p\n", (unsigned int*)p + 0x1);//输出00100004 return 0;&#125; 解释首先要明确，指针与整数的加减法公式为 p = p +/- sizeof（type * p） 第一行输出00100014的原因是结构体Test的存储空间大小为sizeof(int) + sizeof(char* ) + sizeof(short) + sizeof(char)* 2 + sizeof(short)* 4 = 20,并且指针的地址是以十六进制数存放的，因此p + 0x1就相当于指针p向后移动了sizeof(Test)的内存大小，因此输出的内存地址比1000000大20，为00100014。 第二行输出001000001的原因是(unsigned long)语句将* p转换成了整数类型，因此此时做的只是普通的整数与整数之间的加减法。 第三行输出00100004的原因是 (unsigned int)语句将Test 类型的p指针转换成了int * 类型，根据公式此时sizeof(int*) = 4,因此输出00100004。 上机验证 3程序代码#include &lt;stdio.h&gt; 12345678int main()&#123; int a[4] = &#123; 1, 2, 3, 4 &#125;; int * ptr1 = (int * )(&amp;a + 1); int * ptr2 = (int * )((int)a + 1); printf("%x\n%x\n", ptr1[-1], * ptr2);\\输出4 2000000 return 0;&#125; 解释首先，&amp;a指的是取数组a的地址，而&amp;a + 1指的是加上一个int a[4]的长度，即sizeof(int) * 4=16字节，所以ptr1指向数组a后面的内存单元，如果用下标表示就是a[5] 由指针与整数的加减法公式p = p +/- sizeof（type * p，ptr1[-1]表示ptr1指向的地址再减去sizeof(int * )，即指向a[4]，所以第一个%x输出对应的是0x4. (int)a+1的值就是元素a[0]的第二个字节的地址，然后把这个地址强制转化为（int)类型赋给ptr2，也就是说ptr2的值应该为元素a[0]的第二个字节开始的连续4个Byte的内容。 不过要想理解为什么输出了2000000，就要首先明白数字在数组中是怎么被存储的： 每个元素具体存储方式，取决于CPU。 有两种：1、小端(Little Endian)：将低序字节存储在起始地址（低位编址）, 地址低位存储值的低位，地址高位存储值的高位 。目前大多数CPU是按照这种方式存储的，包括intel和移动端最常见的arm。比如4字节整型值为0x12345678的情况，那么在内存中会存储为：0x78 0x56 0x34 0x122、大端(Big Endian)：与小端相反， 将高序字节存储在起始地址（高位编址），地址低位存储值的高位,地址高位存储值的低位。之前的例子在大端情况下存储为：0x12 0x34 0x56 0x78 因此，a[0]在内存中被存储为0x01 0x00 0x00 0x00,a[1]在内存中被存储为0x02 0x00 0x00 0x00，此时ptr2所指向的内存区域的值就是0x00 0x00 0x00 0x02 但是，在printf进行输出时，内存中的值是自右而左地被读出的，因此输出的值应该是0x02000000 上机验证 其余部分就先咕为敬了，告辞有空再补]]></content>
      <tags>
        <tag>C</tag>
        <tag>Learning</tag>
        <tag>Function&amp;Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST Task1]]></title>
    <url>%2F2019%2F10%2F05%2FAST-Task1%2F</url>
    <content type="text"><![CDATA[学习内容0x01 C语言中的数据类型C语言中的常用数据类型 C语言中整型与字符型数据首先需要注意的是： 无符号(unsigned)整型数据与一般有符号整型数据的区别。 整型有无符号（unsigned）和有符号（signed）两种类型，在默认情况下声明的整型变量都是有符号的类型（char有点特别，需要根据具体编译环境确定），如果需声明无符号类型的话就需要在类型前加上unsigned。 无符号整型和有符号整型的区别就是无符号类型可以存放的正数范围比有符号整型中的范围大一倍，因为有符号类型将最高位储存符号，而无符号类型全都储存数字。 并且： 在C/C++语言中，int和long int的所占的字节数与编译环境有关。 C语言标准是这样规定的：int最少16位（2字节），long不能比int短，short不能比int长，具体位长由编译器开发商根据各种情况自己决定。 在老式的16位编译系统上，short、int、long普遍的长度是2字节、2字节、4字节。在32位编译系统x86处理器上，short、int、long普遍的长度是2字节、4字节、4字节。int占四字节，与long相同。在64位编译系统x64处理器上：short占两字节，int占四字节，long占8字节，long数据范围变为：-2^63~2^63-1 由此可见int类型的数据长度一般是机器位长。在16位编译系统中int为16位，两个字节；32位编译系统中int为32位，4个字节；但是在64位编译系统中为了兼容32位编译系统，64位编译系统的int也是4字节。 现在常用的编译器多认为int和long int相同，均为4字节，short为2字节，char为1字节。如果只输入int，它有可能是以上三种形式中的一种。 那么如何得到某个类型在特定平台上的准确大小？ 为了得到某个类型或某个变量在特定平台上的准确大小，我们可以使用 sizeof 运算符。通过表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小： 123456789#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int main()&#123; printf("int 存储大小 : %lu \n", sizeof(int)); return 0;&#125; C语言中的void类型void 类型指定没有可用的值。它通常用于以下三种情况下： 第一种：函数返回为空C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 第二种：函数参数为空C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数void *malloc( size_t size );返回指向 void 的指针，可以转换为任何数据类型。 C语言中的bool（布尔）类型在此之前的C语言中，使用整型int来表示真假。在输入时：使用非零值表示真；零值表示假。在输出时：真的值是1，假的值是0。 现在，出现了布尔型变量。_Bool类型长度为1，只能取值范围为0或1。将任意非零值赋值给_Bool类型，都会先转换为1，表示真。将零值赋值给_Bool类型，结果为0，表示假。 有如下example program： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; _Bool bool1 = 1; _Bool bool2 = 2; /* 非零值，bool2的值为1 */ _Bool bool3 = 0; _Bool bool4 = -1; /* 非零值，bool4的值为1 */ printf(&quot;bool1==%d, \n&quot;, bool1); printf(&quot;bool2==%d, \n&quot;, bool2); printf(&quot;bool3==%d, \n&quot;, bool3); printf(&quot;bool4==%d, \n&quot;, bool4); printf(&quot;sizeof(_Bool) == %d \n&quot;, sizeof(_Bool)); return 0;&#125; 运行结果如下： 12345bool1==1,bool2==1,bool3==0,bool4==1,sizeof(_Bool) == 1 C语言中的数组类型所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 C语言中的指针类型每个变量都被存放在从某个内存地址（以字节为单位）开始的若干个字节中。“指针”，也称作“指针变量”，大小为4个字节（或8个字节）的变量，其内容代表一个内存地址。通过指针，我们能够对该指针指向的内存区域进行读写。如果把内存的每个字节都想像成宾馆的一个房间，那么内存地址相当于就是房间号，而指针里存放的，就是房间号。 T * p ; // T 可以是任何类型的名字，比如 int, double ,char 等等。p 的类型: T * p 的类型： T通过表达式 * p，可以读写从地址 p 开始的 sizeof(T)个字节 p 等价于存放在地址p处的一个 T 类型的变量 意思为间接引用运算符sizeof(T*) 4字节（64位计算机上可能8字节） 有了指针，就有了自由访问内存空间的手段：不需要通过变量，就能对内存直接进行操作。通过指针，程序能访问的内存区域就不仅限于变量所占据的数据区域。在C中，用指针p指向a的地址,然后对p进行加减操作，p就能指向a后面或前面的内存区域，通过p也就能访问这些内存区域。 C语言中的字符串类型C语言中，字符串有两种形式： 用双引号括起来的字符串常量， 如”CHINA” ， “C program “。 存放于字符数组中，以‘\0’字符（ASCII码为0)结尾 存放于字符数组中的字符串常量占据内存的字节数等于字符串中字符数目加1，多出来的是结尾字符‘\0’。但是字符串的长度不包含’\0’用char数组存放字符串，数组元素个数应该至少为字符串长度+1，以避免数组越界。char数组的内容，可以在初始化时设定，还可以用对数组元素赋值的办法任意改变其中的某个字符。 “” 也是合法的字符串常量，称为“空串”， 空串仍然会占据一个字节的存储空间，存放 ‘\0’。 如果字符串常量中包含双引号，则双引号应写为‘&quot;’。而‘\’字符在 字符串中出现时，须连写两次，变成‘\’，以防止转译。 C语言中的结构类型两个同类型的结构变量，可以互相赋值。但是结构变量之间不能用“==”、“!=”、“&lt;”、“&gt;”、“&lt;=”、“&gt;=”进行比较运算。 一般来说，一个结构变量所占的内存空间的大小，就是结构中所有成员变量大小之和。结构变量中的各个成员变量在内存中一般是连续存放的。 并且，一个结构的成员变量可以是任何类型的，包括可以是另一个结构类型: ASCII码和char类型的关系char表示一个字符型数据，其和int在0-255范围内是等价的。而字符编码采用的是ASCII码，所以看起来和ASCII有关。在用char进行输入、输出时其值可以被当成ASCII码，输入、输出函数根据这个码找到相应的字符输入或输出。 0x02 使用格式化输入输出函数printf()和scanf()在printf和scanf中可以使用以”%”开头的控制符，指明要输入或输出的数据的类型以及格式。常用的格式控制符如下表所示：|常用格式控制符|作 用||—|—||%d|读入或输出int变量||%c|读入或输出char变量||%f|读入或输出float变量，输出时保留小数点后面6位||%lf|读入或输出double变量，输出时保留小数点后面6位||%x|以十六进制读入或输出整型变量||%lld|读入或输出long long 变量(64位整数）||%nd|(如%4d,%12d）以n字符宽度输出整数，宽度不足时用空格填充||%0nd|( 如 %04d,%012d )以n字符宽度输出整数，宽度不足时用0填充||%.nf|(如%.4f,%.3f） 输出double或float值，精确到小数点后n位| scanf的进阶使用1.用scanf可以一次读入多个类型不同的变量，只要输入的各项之间用空格分隔即可。example： 12345678910#include &lt;stdio.h&gt;int main()&#123; int n; char c; float m; scanf("%d%c%f",&amp;n,&amp;c,&amp;m); /*依次输入一个整数，一个字符，再一个整数，则它们会被分别放入n,c,m；&amp;n代表“取n的地址"，%c代表等待输入一个字符*/ printf("%d %c %f",n,c,m); return 0;&#125; 输入：34 k 234.45↙输出：34 k 234.449997 2.若输入的各项之间没有用空格分隔，则等待输入字符时，不会跳过空格(空格也会被当作字符读入)，输入其他类型的数据时，会跳过空格。example： 12345678910#include &lt;stdio.h&gt;int main()&#123; int n; char c; float f; scanf("%d%c%f",&amp;n,&amp;c,&amp;f); printf("%d %c %f",n,c,f); return 0;&#125; 输入：34 k 456↙输出：34 0.000000 原因：c = &apos; &apos;, 读入f 时，对应输入是&apos;k&apos;，导致出错。3.如果在输入中有scanf中出现的非控制字符，则这些字符会被跳过。example： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int n,m; char c; float f; scanf("%d %c,%f:%d",&amp;n,&amp;c,&amp;f,&amp;m); printf("%d,%c,%f,%d",n,c,f,m); return 0;&#125;&#125; 输入：12 k,3.75:290↙输出：12,k,3.750000,290 有关sprintf()和sscanf()函数参考这篇文章:浅析C语言中printf(),sprintf(),scanf(),sscanf()的用法和区别-极客编程-博客园 0x03 分支结构与循环控制结构分支结构if语句常见错误1.错把赋值符当逻辑运算符来使用：example： 1234567int a = 0;if( a = 0 ) //a = 0的值是0printf("hello");if( a = 5 ) // a = 5的值是5printf("Hi");=&gt; Hi 2.互相矛盾的多个条件，如果确实只希望执行其中一个分支，应该用if和多个else if，而不要写多个if wrong example: 123456789int a = 0;if( a &gt;=0 &amp;&amp; a &lt; 5 )a = 8;if( a &gt;= 5 &amp;&amp; a &lt; 10 )printf("hello");if( a &gt; 10 &amp;&amp; a &lt; 20).....if( a &gt;= 20)..... 最终会输出hello right example： 123456789int a = 0;if( a &gt;=0 &amp;&amp; a &lt; 5 )a = 8;else if( a &gt;= 5 &amp;&amp; a &lt; 10 )printf("hello");else if( a &gt; 10 &amp;&amp; a &lt; 20).....else..... 不会输出 hello switch语句常见错误switch语句在进入某个case分支后，会一直执行到第一个碰到的“break;”，即使这个“break;”是在后面的case分支里面。如果没有碰到“break;”，则会向下一直执行到switch语句末尾的“}”，包括“default:”部分的语句组也会被执行。 因此，在运用switch语句时，一定要根据题目加上break关键字。 if-else与switch-case语法的区别if语句，if else if语句和switch case语句都属于流程控制语句。 在只需要判断一个条件的时候，自然是使用if语句方便有效；但是当判断条件很多的时候，我们可以使用多个if语句或者if…else if语句或者switch case语句。 if…else if语句和多个if语句的区别还是很大的，if…else if在任何一个环节满足条件的时候就将会终止判断，只处理一个满足条件的情况；而对于多个if语句，将会对每一个判断条件进行判断，自然而然会导致程序的执行效率降低。在多个判断条件的情况下，使用if…else if语句相对于使用多个if语句而言，可以减少程序的判断次数，提高效率。 在多个判断条件的情况下，不仅可以使用if…else if语句，还可以使用switch case语句。一般情况下，当判断条件较多的情况下，使用switch case语句的效率会高于使用if…else if语句。switch…case与if…else if的根本区别在于，switch…case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch…case不用像if…else if那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。 因此，当只有分支比较少的时候，if效率比switch高（因为switch需要生成跳转表）。若分支比较多，那当然是switch更高效也更清晰。 循环结构for循环语句结构特点for语句结构： 123for( 表达式1 ;表达式2;表达式3) &#123;语句组&#125; for循环结构里的“表达式1”和“表达式3”都可以是用逗号连接的若干个表达式。 for循环括号内三个语句的执行时间执行过程： 1) 计算“表达式1”。2) 计算“表达式2”，若其值为true，则执行“{ }”中的语句组，然后转到3)；若为false,则不再执行“{}”中的语句组，for语句结束，转到5)。3) 计算“表达式3”。4) 转到2)。5) 从for语句后面继续往下执行程序。 for语句的循环控制变量特点循环控制变量定义在”表达式1”中，则其只在for语句内部起作用，可以不用担心循环控制变量重名。example： 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int i = 5; for( int i = 0;i &lt; 26; ++i )&#123; printf("%c\n",char('a'+i )); &#125; for( int i = 0;i &lt; 26; i+=2 )&#123; printf("%c\n",char('a'+i )); &#125; printf("%d\n",i）;//此处的i和for里面的i无关 return 0;&#125;&gt;最后的一个输出：5#### while循环语句结构特点```cwhile(表达式) &#123;语句组&#125; 若情境是并非到达指定次数，而是满足某条件时即停止循环，则适合用while语句来实现循环。 while循环的执行过程1) 判断“表达式”是否为真，如果不为真，则转4)2) 执行“语句组”3) 转1)4) while语句结束，继续执行while语句后面的语句。 do……while循环语句结构特点123do &#123;语句组&#125; while(表达式); 如果希望循环至少要执行一次，就可以使用do…while语句。 do……while循环语句的执行过程每执行一次循环后，都要判断“表达式”的值是否为真，如果真就继续循环，如果为假，就停止循环。 while和do……while语句的区别while先判断后执行，do while先执行后判断当不满足循环条件时，while循环一次都不会执行，do while循环至少执行一次 break与continue语句break语句可以出现在循环体中(for、while、do…while循环均可)，其作用是跳出循环。并且在多重循环的情况下，break语句只能跳出直接包含它的那一重循环。 example:找兄弟数：如果两个不同的正整数，他们的和是他们的积的因子，就称这两个数为兄弟数，小的称为弟数，大的称为兄数。先后输入正整数n和m(n &lt; m) , 请在n至m这m-n+1个数中，找出一对兄弟数。如果找不到，就输出“No Solution.”。如果能找到，就找出和最小的那一对；如果有多对兄弟数和相同且都是最小，就找出弟数最小的那一对。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main() &#123; int n,m; scanf("%d %d",&amp;n,&amp;m ); int a = m + 1,b = m + 1; //a,b记录已经找到的最佳兄弟数，a是弟数，b是兄数 for( int i = n; i &lt; m ; ++i ) &#123; //取弟数，共m-n种取法 if( i &gt; (a + b)/2 + 1) break; // 跳出外重循环 for( int j = i + 1; j &lt;= m; ++j ) &#123; //取兄数 if( i + j &gt; a + b ) break; // 跳出内重循环 if( i * j % (i + j) == 0 ) &#123; //发现兄弟数 if( i + j &lt; a + b) &#123; //发现和更小的兄弟数 a = i; b = j ; //更新已找到的最佳兄弟数 &#125; else if( i + j == a + b &amp;&amp; i &lt; a) //发现和相同但弟数更小的兄弟数 a = i; b = j; //更新已找到的最佳兄弟数 &#125; &#125; &#125; if( a == m + 1 ) //没找到兄弟数 printf("No solution."); else printf("%d,%d\n",a,b); return 0;&#125; continue语句可以出现在循环体中(for、while、do…while循环均可)，其作用是立即结束本次循环，并回到循环开头判断是否要进行下一次循环。在多重循环的情况下，continue只对直接包含它的那重循环起作用。 example：找10以内的偶数 1234567891011#include&lt;stdio.h&gt;int main()&#123; for( int i = 1;i &lt;= 10 ;++i ) &#123; if( i % 2 ) continue; //导致不执行后面的语句，回到循环开头 printf("%d,",i); &#125; return 0;&#125; 输出：2,4,6,8,10, 0x04 初始化数组一维数字数组的初始化在通过type arrayName [ arraySize ];语句声明数组之后，需要对数组进行初始化。 在 C 中，我们可以逐个初始化数组，也可以使用一个初始化语句，如下所示： int test[5] = {1, 2, 3, 4, 5}; 需要注意的是，声明数组时方括号内的数字代表的是数组长度。数组的元素都是从0开始标号的，因此数组的第一个元素是arrayName[0],最后一个元素是arrayName[数组的总大小减去 1]。需要牢记这一点以免发生数组越界情况。 例如，有以下程序： 1234567891011121314 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define Lenth 5 int main() &#123; int test[Lenth] = &#123; 1, 2, 3, 4, 5 &#125;; int i = 0; for (i = 0; i &lt; Lenth; i++) &#123; printf("test数组的第%d个元素为%d,\n", i+1, test[i]); &#125; return 0;&#125; 运行结果为： &gt;test数组的第1个元素为1, test数组的第2个元素为2, test数组的第3个元素为3, test数组的第4个元素为4, test数组的第5个元素为5, 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 若是大括号{ }之间的值小于我们在数组声明时在方括号中指定的元素数目，则没有值与之对应的数组元素自动赋0 只能给元素逐个赋值，不能给数组整体赋值。例如给十个元素全部赋1值，只能写为：int a[10]={1,1,1,1,1,1,1,1,1,1};而不能写为：int a[10]=1. 如不给可初始化的数组赋初值，则全部元素均为0值。 以上规则也适用于 其他类型的数组例如，有以下程序： 1234567891011121314 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define Lenth 6 int main() &#123; int test[Lenth] = &#123; 1, 2, 3, 4, 5 &#125;; int i = 0; for (i = 0; i &lt; Lenth; i++) &#123; printf("test数组的第%d个元素为%d,\n", i+1, test[i]); &#125; return 0;&#125; 运行结果为： &gt;test数组的第1个元素为1, test数组的第2个元素为2, test数组的第3个元素为3, test数组的第4个元素为4, test数组的第5个元素为5, test数组的第6个元素为0, 如果在初始化时省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果我们初始化：int test[] = {1, 2, 3, 4, 5};那么创建的这个数组，它与前一个例子中所创建的数组是完全相同的。 一维字符数组的初始化C语言允许用字符串的方式对数组作初始化赋值。例如： 1char c[9]=&#123;'c',' ','p','r','o','g','r','a','m'&#125;; 可写为： 1char c[10]=&#123;"C program"&#125;; 或去掉&#123;&#125;写为： 1char c[10]="C program"; 需要注意的是，用字符串给字符数组赋值时由于要添加结束符 ‘\0‘，数组的长度要比字符串的长度（字符串长度不包括 ‘\0&#39;）大1。例如：char str[] = “C program”;该数组在内存中的实际存放情况为：字符串长度为 9，数组长度为 10。因此我们需要增加一个字符数组长度用来存放\0。 并且，上述这种字符数组的整体赋值只能在字符数组初始化时使用，不能用于字符数组的赋值，字符数组的赋值只能对其元素一一赋值，下面的赋值方法是错误的。 12char str[];str="I am happy";//错误，字符数组的赋值只能按元素一一赋值 当对全体元素赋初值时也可以省去长度说明。例如： 1char c[]=&#123;'c',' ','p','r','o','g','r','a','m'&#125;; 这时C数组的长度自动定为9。 二维数字数组的初始化example： 1int a[5][3]=&#123;&#123;80,75,92&#125;,&#123;61,65&#125;,&#123;59,63,70&#125;,&#123;85,90&#125;,&#123;76,77,85&#125;&#125;; 每个内层的{}，初始化数组中的一行。同样地，二维数组初始化时，如果对每行都进行了初始化，则也可以不给出行数:example： 1int a[][3]=&#123; &#123;80,75,92&#125;,&#123;61,65&#125; &#125;; a 是一个2行3列的数组，a[1][2]被初始化成0。 二维字符数组的初始化通常情况下，二维数组的每一行分别使用一个字符串进行初始化。 例如： 1char c[3][8]=&#123;&#123;"apple"&#125;,&#123;"orange"&#125;,&#123;"banana"&#125;&#125;; 等价于： 1char c[3][8]=&#123;"apple","orange","banana"&#125;; 以上两条初始化语句中，二维数组的第一维大小均可省略。数组 c 的逻辑结构如下所示：| |0|1|2|3|4|5|6|7||–|–|–|–|–|–|–|–|–||c[0]|a|p|p|l|e|\0|\0|\0||c[1]|o|r|a|n|g|e|\0|\0||c[2]|b|a|n|a|n|a|\0|\0| 二维数字数组的存放方式数组T a[N][M] 每一行都有M个元素第i行的元素就是a[i][0]、a[i][1]……a[i][M-1]。同一行的元素，在内存中是连续存放的。第j列的元素的元素，就是a[0][j]、a[1][j]……a[N-1][j]。a[0][0]是数组中地址最小的元素。如果a[0][0]存放在地址n，则a[i][j]存放的地址就是：n + i × M× sizeof(T) + j × sizeof(T) 数组越界数组元素的下标，可以是任何整数，可以是负数，也可以大于数组的元素个数。不会导致编译错误：example： 12345int a[10];a[-2] = 5;a[200] = 10;a[10] = 20;int m = a[30]; 但运行时很可能会出错!a[-2] = 5; a[200] = 10; a[10] = 20;int m = a[30];均可能导致程序运行出错！！！因为可能引起意外修改其他变量的值，导致程序运行结果不正确可能试图访问不该访问的内存区域，导致程序崩溃数组越界的程序，用某些编译器编译后可能可以正确运行，换一个编译器编译后就运行错误最可怕的是，编译器不会报错。 因此，我们在使用数组时，最好能初始化/声明地大一些 0x05 标识符的作用域，结构体标识符的作用域C语言中的全局变量、局部变量、静态变量要想学习变量的作用域，首先要搞懂C中的全局变量、局部变量、静态变量 局部变量：定义在函数内部的变量叫局部变量（函数的形参也是局部变量） 全局变量：定义在所有函数的外面的变量叫全局变量全局变量在所有函数中均可以使用，局部变量只能在定义它的函数内部使用 静态变量：全局变量都是静态变量。局部变量定义时如果前面加了“static”关键字，则该变量也成为静态变量静态变量的存放地址，在整个程序运行期间，都是固定不变的非静态变量(一定是局部变量)地址每次函数调用时都可能不同,在函数的一次执行期间不变如果未明确初始化，则静态变量会被自动初始化成全0(每个bit都是0），局部非静态变量的值则随机 作用域变量名、函数名、类型名统称为“标识符”。一个标识符能够起作用的范围，叫做该标识符的作用域 在一个标识符的作用域之外使用该标识符，会导致“标识符没有定义”的编译错误。使用标识符的语句，必须出现在它们的声明或定义之后在单文件的程序中，结构、函数和全局变量的作用域是其定义所在的整个文件 函数形参的作用域是整个函数局部变量的作用域，是从定义它的语句开始，到包含它的最内层的那一对大括号“{}”的右大括号 “}”为止。for循环里定义的循环控制变量，其作用域就是整个for循环同名标示符的作用域，可能一个被另一个包含。则在小的作用域里，作用域大的那个标识符被屏蔽，不起作用。 生存期所谓变量的“生存期”，指的是在此期间，变量占有内存空间，其占有的内存空间只能归它使用，不会被用来存放别的东西。而变量的生存期终止，就意味着该变量不再占有内存空间，它原来占有的内存空间，随时可能被派做他用。 全局变量的生存期，从程序被装入内存开始，到整个程序结束。静态局部变量的生存期，从定义它语句第一次被执行开始，到整个程序结束为止。函数形参的生存期从函数执行开始，到函数返回时结束。非静态局部变量的生存期，从执行到定义它的语句开始，一旦程序执行到了它的作用域之外，其生存期就终止。 使用struct定义结构体我们可以使用“struct”关键字来定义一个“结构”，也就是说定义了一个新的结构数据类型：定义方式: 1234567struct 结构名&#123;类型名 成员变量名；类型名 成员变量名；类型名 成员变量名；……&#125;; example: 12345struct Student &#123;unsigned int ID;char Name[20];float GPA;&#125;; 在经过这条语句之后Student 即成为自定义类型的名字，可以用来定义变量Stuent s1,s2; 使用结构体获得、写入结构体内部的成员变量一个结构变量的成员变量，可以完全和一个普通变量一样来使用，也可以取得其地址。使用形式： 结构变量名.成员变量名example：对于以下定义的StudentEx与Date结构体数据类型 1234567891011struct Date &#123;int year;int month;int day;&#125;;struct StudentEx &#123;unsigned int ID;char Name[20];float GPA;Date birthday;&#125;; 我们可以运行以下的main()代码段： 1234567StudentEx stu;scanf("%f", &amp;stu.GPA);stu.ID = 12345;stu.Name[]=&#123;'Z','a','m'&#125;;printf("%f",stu.GPA);stu.birthday.year = 1984;unsigned int * p = &amp; stu.ID; //p指向stu中的ID成员变量 结构变量的初始化结构变量可以在定义时进行初始化:例如对上面的例子，我们可以通过以下语句对结构变量进行初始化 1StudentEx stu = &#123; 1234,"Tom",3.78,&#123; 1984,12,28 &#125;&#125;; 指向结构变量的指针定义指向结构变量的指针方式：结构名 * 指针变量名;example: 1234StudentEx * pStudent;//定义了* pStudent为StudentEx类型的指针StudentEx Stu1;pStudent = &amp; Stu1;//使得pStudent指针指向stu1变量的起始位置StudentEx Stu2 = * pStudent; //将pStudent指针指向的stu1变量赋值给stu2变量 通过指针，访问其指向的结构变量的成员变量方式： 123指针-&gt;成员变量名or(* 指针).成员变量名 example:对于‘使用结构体获得、写入结构体内部的成员变量’中定义的结构体可以使用以下语句： 1234567StudentEx Stu;StudentEx * pStu;pStu = &amp; Stu;pStu-&gt;ID = 12345;( * pStu).GPA = 3.48;printf("%d\n",Stu.ID) //输出 12345printf("%f\n",Stu.GPA); //输出 3.48 0x06 C语言函数函数的定义一般来说函数的定义必须出现在函数调用语句之前，否则调用语句编译出错函数的定义方式： 12345返回值类型 函数名(参数1类型 参数1名称, 参数2类型 参数2名称……)&#123;语句组(即“函数体”）return 返回值；&#125; 如果函数不需要返回值，则“返回值类型”可以写“void” 函数的调用调用函数语句：函数名（参数1,参数2，……） return语句对函数的调用，也是一个表达式。函数调用表达式的值，由函数内部的return语句决定。return语句语法如下：return 返回值；return语句的功能是结束函数的执行，并将“返回值”作为结果返回。“返回值”是常量、变量或复杂的表达式均可。如果函数返回值类型为“void”，return语句就直接写：return ;需要注意的是，return 语句作为函数的出口，可以在函数中多次出现。多个return语句的“返回值”可以不同。在哪个return语句结束函数，函数的返回值就和哪个return语句里面的“返回值”相等。 0x07 C语言的指针C语言指针的定义T * p ; // T 可以是任何类型的名字，比如 int, double ,char 等等。p 的类型: T * *p 的类型： T通过表达式 * p，可以读写从地址p开始的 sizeof(T)个字节*p 等价于存放在地址p处的一个 T 类型的变量 间接引用运算符 sizeof(T*) 4字节（64位计算机上可能8字节）指针的用法&amp; : 取地址运算符&amp;x : 变量x的地址（即指向x的指针)对于类型为 T 的变量 x，&amp;x 表示变量 x 的地址(即指向x的指针) &amp;x 的类型是 T * 。example：123456char ch1 = 'A';char * pc = &amp;ch1; // 使得pc 指向变量ch1 * pc = 'B'; // 使得ch1 = 'B' char ch2 = * pc; // 使得ch2 = ch1 pc = &amp; ch2; // 使得pc 指向变量ch2 * pc = 'D'; // 使得ch2 = 'D' 指针的赋值 不同类型的指针，如果不经过强制类型转换，不能直接互相赋值example： 123456int * pn, char * pc, char c = 0x65;pn = pc; //类型不匹配，编译出错pn = &amp; c; //类型不匹配，编译出错pn = (int * ) &amp; c;int n = * pn; //n值不确定* pn = 0x12345678; //编译能过但运行可能出错 指针的运算1） 两个 同类型 的指针变量，可以比较大小 若地址p1&lt;地址p2，则 p1&lt; p2 值为真。若地址p1=地址p2，则 p1== p2 值为真。若地址p1&gt;地址p2，则 p1 &gt; p2 值为真。 2) 两个 同类型 的指针变量，可以相减 运算规则：两个T * 类型的指针 p1和p2p1 – p2 = ( 地址p1 – 地址 p2 ) / sizeof(T) 例：int * p1, * p2;若 p1 指向地址 2000,p2 指向地址 600, 则p1 – p2 = (1000 – 600)/sizeof(int) = (2000 – 600)/4 = 350 3)指针变量加减一个整数的结果是指针 例如：p : T * 类型的指针n : 整数类型的变量或常量 则p+n : T * 类型的指针，指向地址： 地址p + n × sizeof(T)n+p, p-n , * (p+n), * (p-n)等同理 4) 指针变量可以自增、自减 若T* 类型的指针p指向地址n则p++, ++p : p指向 n + sizeof(T) p–, –p : p指向 n - sizeof(T) 5）指针可以用下标运算符“[ ]”进行运算若p 是一个 T * 类型的指针， n 是整数类型的变量或常量则p[n] 等价于 * (p+n) Task End]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>AST of EIC,HUST</tag>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
