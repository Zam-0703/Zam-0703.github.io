<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jupyter的安装与使用]]></title>
    <url>%2F2020%2F01%2F19%2FJupyter%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近开始学习Python，但是臃肿的Visual Studio启动和编译速度极慢，直接使用命令行又没法保存我敲的代码。于是乎，我就想整一个又能即时保存我敲的代码，又能快速地运行Python程序，最好还能支持Markdown，让我能够边学习边做笔记。在经过了一番寻找过后，我找到了这款神器：Jupyter Jupyter简介12Jupyter Notebook是一个Web应用程序，允许您创建和共享包含实时代码，方程，可视化和说明文本的文档。用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。 在Notebooks中不仅可以运行Python语言，它还支持R、Julia和Javascript等等语言。 安装Jupyter Notebooks通过pip安装既然你都已经想要安装Jupyter了，那么我想Python总已经安装并配置好了吧。 123注意：Python中默认安装的版本：Python 2.7.9及后续版本：默认安装，命令为pipPython 3.4及后续版本：默认安装，命令为pip3 升级pip到最新版本打开cmd，并切换到Python的安装目录下的Scripts文件夹，然后执行以下命令： 1pip3 install --upgrade pip3 安装Jupyter Noteboooks接下来执行以下命令： 1pip3 install jupyter 等待进度条跑完即可（u1s1，pip是真的方便 运行Jupyter Notebooks切换到Python的安装目录下的Scripts文件夹。执行如下命令 1jupyter notebook 然后浏览器就会自动打开Notebook窗口。但是此时你所创建的notebook文件都是放置在你的Python安装目录\Script下。之后会提到如何修改Jupyter Notebook的工作空间。 通过Anaconda安装在安装Anaconda的同时会安装Python 和 Jupyter Notebooks这两个工具，并且还包含相当多数据科学和机器学习社区常用的软件包。关于Anaconda的安装与使用，可以参考这个链接：Anaconda介绍、安装及使用教程安装好了Anaconda后，可以直接在Anaconda的命令提示符界面输入以下命令： 1jupyter notebook 然后就可以食用Jupyter了 修改Jupyter Notebook工作空间在我们第一次启动Notebooks时，默认显示的是Script文件夹下的文件目录。因为此时notebooks默认的工作空间是安装目录。但是这样的话找起文件来比较麻烦。我们可以自己定义一个专属的工作空间 获取Jupyter Notebook的配置文件打开命令提示窗口，执行如下命令： 1jupyter notebook --generate-config 此处需要注意的是，如果你已经配置过notebooks的相关信息，执行此命令会提示你是否覆盖原有配置。输入y直接覆盖。如果是首次执行此命令，则生成配置到相应目录。 修改配置文件打开生成的配置文件，修改#c.NotebookApp.notebook_dir = &#39;&#39;此条配置，在单引号中填入我们刚才创建的专属工作空间，此处我这里是E:\MyTools\Python\jupyter-notebook。要注意的是，由于转义字符这种神奇的存在。所以你需要在字符串的单引号前加r，或者将单斜杠变为双斜杠，如下图所示。此条配置默认是注释掉的，所以我们需要删除第一个#。ok,保存配置文件。好了，现在打开命令提示窗口，执行jupyter notebook命令重新启动Notebook，浏览器相应会打开Notebook主页，主页中相应会显示工作空间中的文件目录。注意：启动notebook之后，不要关闭该命令提示窗口。一旦关闭该窗口Jupyter的本地服务器就会被关闭。 Jupyter Notebook 基本使用Jupyter界面起订Notebook后，界面应该是这样的： 第一部分 Files：列出所有文件 Running：展示你当前打开的终端和笔记本 Clusters：由 IPython 并行提供的第二部分点击右侧的New按钮可展开如图的下拉列表按钮，其内包括了可创建的四种工作环境： Python3：创建一个可以执行Python代码的ipynb文件 Text File：创建文本类型的txt文件 Folder：创建一个文件夹 Teminal：在浏览器中打开一个命令窗口第三部分这里的按钮其实就是对当前工作空间内的文件进行一系列操作： Duplicate：复制文件 Rename：重命名 Move：移动文件 Download：下载文件 View：在浏览器中预览文件内容 Edit：编辑文件 Delete(小图标)：删除选中的文件Jupyter Notebook 中编写并执行Python代码在首页右侧点击New，选择点击Python3,页面即跳转到一个新的窗口，此时已经创建了一个新的文件，红色区域为该文件的名称(默认为Untitled)，点击即可修改文件名，此处我们命名为Hello_World，如下图所示。在In [ ] :后面的输入框中我们可以输入一段python代码进行测试，点击Run按钮执行,也可以快捷键Ctrl+Enter执行代码，结果如下:Jupyter Notebooks 的强大之处在于除了能够输入代码之外，你还可以用 Markdown 添加叙述性和解释性文本。比如我想添加一个文字说明，在代码上面添加了一个单元格，并以 Markdown 输入了一个文本。按下Ctrl+Enter，效果如下:Jupyter Notebook 中的快捷键介绍当你熟练使用notebooks的基本功能后，掌握他的快捷键是十分必要的，这样可以大大提高你的工作效率。下面是一些比较常用的快捷键： 编辑模式：点击单元格按下Enter命令模式（退出编辑模式)：按下Esc 进入命令模式之后（此时你没有活跃单元），有以下快捷键： A：在所选单元之上插入一个新的单元 B：在所选单元之下插入一个新的单元 D：连续按两次删除所选的单元 Z：撤销被删除的单元 Y：将当前选中的单元变成一个代码单元 F：查找和替换 Shift +上或下箭头：可选择多个单元。 Shift + M：在多选模式时，可合并你的选择。 处于编辑模式时（在命令模式时按 Enter 会进入编辑模式），下列快捷键很有用： Ctrl + Home：到达单元起始位置 Ctrl + S：保存进度 Ctrl + Enter：会运行你的整个单元块 Alt + Enter：不止会运行你的单元块，还会在下面添加一个新单元 Ctrl + Shift + F：打开命令面板可在命令模式按 H 或进入Help &gt; Keyboard Shortcuts。可以查看键盘快捷键完整列表。总结关于Jupyter Notebooks的安装和基本用法就先介绍到这里就差不多了。]]></content>
      <tags>
        <tag>Jupyter</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST-Task4]]></title>
    <url>%2F2019%2F11%2F26%2FAST-Task4%2F</url>
    <content type="text"><![CDATA[咕咕咕了这么久，终于有空好好学学树与二叉树的数据结构了。 树的基本概念下面是一些关于树的基本术语：|术语|中文|描述||—-|—-|—-||Root|根节点|The top node in a tree.||Child|子节点|A node directly connected to another node when moving away from the Root.||Leaf|叶子节点|A node with no children||Edge|边|The connection between one node and another.||Path|路径|A sequence of nodes and edges connecting a node with a descendant.||Height|节点高度|The height of a node is the number of edges on the longest path between that node and a leaf.||Level|层级|The level of a node is defined by 1 + (the number of connections between the node and the root).||Depth|深度|The depth of a node is the number of edges from the tree’s root node to the node.||Degree|度|The number of subtrees of a node.|下面通过几个图解释树的术语 需要注意的是叶子节点的高度为0，如果树只有一个节点，那么这个节点的高也是0需要注意的是根节点的深度（Depth）是0. 从Height和Depth的对比，它们的方向刚好是相反的。对于Height和Depth不用死记，我们可以把树倒过来看，也就是我们现实生活当中的树，求某个节点的Height那肯定是从根部往上的方向；如果是求某个节点的深度，方向肯定是向下的。节点的Level是从1开始的，Level = Depth+1，根节点的Level=1也有很多书籍上Level是从0开始的，这样的话Level就等于Depth，根节点的Level=0reference:数据结构与算法（七）树和二叉树 二叉树的基本概念二叉树是一个每个最结最多只能有两个分支的树，左边的分支称之为左子树，右边的分支称之为右子树。 也就是说二叉树节点的度最大也就是2，而普通的树，节点的度是没有限制的。 二叉树的分类完美/满二叉树完美二叉树也有地方称之为满二叉树。完美二叉树满足两个特性： 所有的几点都包含两个子节点 所有的叶子节点的Height或者Level都相等 例如下面就是一个完美二叉树： 完全二叉树完全二叉树是 除了最后一层都是满的（都有两个子节点），并且最后一层的节点是从左往右排列的。 完全二叉树，通俗点说就是节点按层从左往右排列。如果最后一层排满了就是完美二叉树，没有满则是完全二叉树。所以完美二叉树一定是完全二叉树，完全二叉树不一定是完美二叉树。 一个完全二叉树可以高效的使用数组来表示。 例如下面就是一个完全二叉树： 完满二叉树完满二叉树就简单了，就是每个节点都有两个子节点。也就是说它比完美二叉树少了一个条件。 例如下面就是一个完满二叉树： 学习并实现树的相关操作在这里，我们定义一个如下的二叉树数据结构： 1234567typedef char BTDataType;typedef struct BTNode&#123; struct BTNode * _pLeft; struct BTNode * _pRight; BTDataType _data;&#125;BTNode; 遍历二叉树从二叉树的递归定义可知，一棵非空的二叉树由根结点及左、右子树这三个基本部分组成。因此，在任一给定结点上，可以按某种次序执行三个操作： ⑴访问结点本身（N） ⑵遍历该结点的左子树（L） ⑶遍历该结点的右子树（R） 以上三种操作有六种执行次序： NLR、LNR、LRN、NRL、RNL、RLN。 注意： 前三种次序与后三种次序对称，故只讨论先左后右的前三种次序。 因此，我们就可以根据访问结点操作发生位置命名： NLR：前序遍历(Preorder Traversal 亦称（先序遍历）） ——访问根结点的操作发生在遍历其左右子树之前。 LNR：中序遍历(Inorder Traversal) ——访问根结点的操作发生在遍历其左右子树之中（间）。 LRN：后序遍历(Postorder Traversal) ——访问根结点的操作发生在遍历其左右子树之后。注意： 由于被访问的结点必是某子树的根，所以N(Node）、L(Left subtree）和R(Right subtree）又可解释为根、根的左子树和根的右子树。NLR、LNR和LRN分别又称为先根遍历、中根遍历和后根遍历。 先序遍历若二叉树非空，则依次执行如下操作：⑴ 访问根结点；⑵ 遍历左子树；⑶ 遍历右子树。递归算法实现： 123456789void PreOrder(BTNode* pRoot)&#123; if (pRoot) &#123; printf("%c ", pRoot-&gt;_data); PreOrder(pRoot-&gt;_pLeft); PreOrder(pRoot-&gt;_pRight); &#125;&#125; 中序遍历若二叉树非空，则依次执行如下操作：⑴遍历左子树；⑵访问根结点；⑶遍历右子树。递归算法实现： 123456789void InOrder(BTNode* pRoot)&#123; if (pRoot) &#123; InOrder(pRoot-&gt;_pLeft); printf("%c ", pRoot-&gt;_data); InOrder(pRoot-&gt;_pRight); &#125;&#125; 后序遍历若二叉树非空，则依次执行如下操作：⑴遍历左子树；⑵遍历右子树；⑶访问根结点。递归算法实现： 123456789void PostOrder(BTNode* pRoot)&#123; if (pRoot) &#123; PostOrder(pRoot-&gt;_pLeft); PostOrder(pRoot-&gt;_pRight); printf("%c ", pRoot-&gt;_data); &#125;&#125; 层序遍历除了以上三种以根节点相对于它的左右孩子的访问顺序定义的遍历算法之外，二叉树还有一种遍历方式，就是层序遍历。递归算法实现 123456789101112131415161718192021void LevelOrder(BTNode* pRoot)&#123; if(pRoot == NULL) &#123; return NULL; &#125; Queue q; QueueInit(&amp;q); QueuePush(&amp;q, pRoot); while(!QueueEmpty(&amp;q)) &#123; pRoot = QueueFront(&amp;q); QueuePop(&amp;q); printf("%c ", pRoot-&gt;_data); if(pRoot-&gt;_pLeft!=NULL) QueuePush(&amp;q, pRoot-&gt;_pLeft); if(pRoot-&gt;_pRight!=NULL) QueuePush(&amp;q, pRoot-&gt;_pRight); &#125; QueueDestroy(&amp;q);&#125; reference:二叉树的前中后和层序遍历详细图解(递归和非递归写法) 新建一个树节点C语言实现 12345678910111213BTNode* BuyNewNode1(BTDataType data)&#123; BTNode* root = (BTNode*)malloc(sizeof(BTNode)); if (root == NULL) &#123; assert(0); return NULL; &#125; root-&gt;_data = data; root-&gt;_pLeft = NULL; root-&gt;_pRight = NULL; return root;&#125; 创建二叉树C语言实现 12345678910111213141516171819202122BTNode * _CreateBinTree(BTDataType * array, int size, int* index,BTDataType invalid)&#123; BTNode* pRoot = NULL; if ((*index) &lt; size &amp;&amp; invalid != array[*index] ) &#123; pRoot = BuyNewNode1(array[*index]); //创建左子树； ++(*index); pRoot-&gt;_pLeft = _CreateBinTree(array, size, index,invalid); //创建右子树 ++(*index); pRoot-&gt;_pRight = _CreateBinTree(array, size, index,invalid); &#125; return pRoot;&#125;BTNode* CreateBinTree(BTDataType* array, int size, BTDataType invalid) &#123; int index = 0; return _CreateBinTree(array, size, &amp;index, invalid);&#125; 拷贝二叉树C语言实现 12345678910BTNode* CopyBinTree(BTNode* pRoot)&#123; BTNode* newpRoot = NULL; if (pRoot == NULL) return NULL; newpRoot = BuyBinTreeNode(pRoot-&gt;_data); newpRoot-&gt;_pLeft = CopyBinTree(pRoot-&gt;_pLeft); newpRoot-&gt;_pRight = CopyBinTree(pRoot-&gt;_pRight); return newpRoot;&#125; 删除二叉树C语言递归实现 123456789101112void DestroyBinTree(BTNode** pRoot)&#123; if (*pRoot) &#123; //递归删除左子树 DestroyBinTree(&amp;((*pRoot)-&gt;_pLeft)); //递归删除右子树 DestroyBinTree(&amp;((*pRoot)-&gt;_pRight)); free(*pRoot); *pRoot = NULL; &#125;&#125; 获取二叉树全部的节点个数C语言递归实现 1234567int GetBinTreeSize(BTNode* pRoot)&#123; if (pRoot) return GetBinTreeSize(pRoot-&gt;_pLeft) + GetBinTreeSize(pRoot-&gt;_pRight) + 1; else return 0;&#125; 获取二叉树中叶子节点个数C语言递归实现 123456789101112int GetLeafCount(BTNode* pRoot)&#123; if (pRoot == NULL) &#123; return 0; &#125; if (pRoot-&gt;_pLeft == NULL &amp;&amp; pRoot-&gt;_pRight == NULL) &#123; return 1; &#125; return GetLeafCount(pRoot-&gt;_pLeft) + GetLeafCount(pRoot-&gt;_pRight);&#125; 获取二叉树深度(高度)C语言递归实现 123456789101112131415161718int GetBinTreeHeight(BTNode* pRoot)&#123; if (pRoot == NULL) &#123; return 0; &#125; int height = 1; while (pRoot-&gt;_pLeft || pRoot-&gt;_pRight) &#123; height++; if (pRoot-&gt;_pLeft) pRoot = pRoot-&gt;_pLeft; if(pRoot-&gt;_pRight) pRoot = pRoot-&gt;_pRight; &#125; return height;&#125; 在二叉树中搜索值为X的节点C语言递归实现 1234567891011121314151617181920BTNode* BinaryTreeFind(BTNode* root, BTDataType x)&#123; if (root == NULL) &#123; return NULL; &#125; if(root-&gt;_data == x) &#123; return root; &#125; BTNode* tmp = NULL; //递归从左子树往下找 if (tmp = BinaryTreeFind(root-&gt;_pLeft, x)) &#123; return tmp; &#125; //左子树从右子树找，右子树找到直接返回 return BinaryTreeFind(root-&gt;_pRight, x);&#125; 镜像翻转二叉树C语言递归实现 1234567891011121314151617void BinaryTreeSwap(BTNode** pleft, BTNode ** pright)&#123; BTNode * tmpNode = *pleft; *pleft = *pright; *pright = tmpNode;&#125;void Mirror(BTNode* pRoot)&#123; if (pRoot == NULL) &#123; return NULL; &#125; BinaryTreeSwap(pRoot-&gt;_pLeft, pRoot-&gt;_pRight); Mirror(pRoot-&gt;_pLeft); Mirror(pRoot-&gt;_pRight);&#125; 学习并实现树的相关结构线索二叉树Reference:线索二叉树的创建及遍历(C语言实现)在使用二叉链表的普通二叉树中，对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域。这些空链域放着不用，是对空间的浪费。如果算法中多次涉及到对二叉树的遍历，普通的二叉树就需要使用栈结构做重复性的操作。因此，如果使用二叉树中空闲的内存空间记录某些结点的前趋和后继元素的位置（不是全部）。这样在算法后期需要遍历二叉树时，就可以利用保存的结点信息，提高了遍历的效率。使用这种方法构建的二叉树，即为“线索二叉树”。 线索二叉树中，如果结点有左子树，则 lchild 指针域指向左孩子，否则 lchild 指针域指向该结点的直接前趋；同样，如果结点有右子树，则 rchild 指针域指向右孩子，否则 rchild 指针域指向该结点的直接后继。为了避免指针域指向的结点的意义混淆，需要改变结点本身的结构，增加两个标志域，如下图所示 其中，LTag 和 RTag 为标志域。实际上就是两个布尔类型的变量： LTag 值为 0 时，表示 lchild 指针域指向的是该结点的左孩子；为 1 时，表示指向的是该结点的直接前趋结点； RTag 值为 0 时，表示 rchild 指针域指向的是该结点的右孩子；为 1 时，表示指向的是该结点的直接后继结点。结点结构代码实现(C):12345678910111213#define TElemType int//宏定义，结点中数据域的类型//枚举，Link为0，Thread为1typedef enum PointerTag&#123; Link, Thread&#125;PointerTag;//结点结构构造typedef struct BiThrNode&#123; TElemType data;//数据域 struct BiThrNode* lchild,*rchild;//左孩子，右孩子指针域 PointerTag Ltag,Rtag;//标志域，枚举类型&#125;BiThrNode,*BiThrTree; 表示二叉树时，像以上结点结构构成的二叉链表，被称为线索链表；构建的二叉树称为线索二叉树。 将普通二叉树转化为线索二叉树大致思路：在遍历过程中，如果当前结点没有左孩子，需要将该结点的 lchild 指针指向遍历过程中的前一个结点，所以在遍历过程中，设置一个指针（名为 pre ），时刻指向当前访问结点的前一个结点。rchlid也同样处理C语言实现： 12345678910111213141516171819//中序对二叉树进行线索化void InThreading(BiThrTree p)&#123; //如果当前结点存在 if (p) &#123; InThreading(p-&gt;lchild);//递归当前结点的左子树，进行线索化 //如果当前结点没有左孩子，左标志位设为1，左指针域指向上一结点 pre if (!p-&gt;lchild) &#123; p-&gt;Ltag=Thread; p-&gt;lchild=pre; &#125; //如果 pre 没有右孩子，右标志位设为 1，右指针域指向当前结点。 if (!pre-&gt;rchild) &#123; pre-&gt;Rtag=Thread; pre-&gt;rchild=p; &#125; pre=p;//线索化完左子树后，让pre指针指向当前结点 InThreading(p-&gt;rchild);//递归右子树进行线索化 &#125;&#125; 线索二叉树的遍历下图是一个按照中序遍历建立的线索二叉树。其中，实线表示指针，指向的是左孩子或者右孩子。虚线表示线索，指向的是该结点的直接前趋或者直接后继。 使用线索二叉树时，会经常遇到一个问题，如图 3 中，结点 b 的直接后继直接通过指针域获得，为结点 * ；而由于结点 * 的度为 2 ，无法利用指针域指向后继结点，整个链表断掉了。当在遍历过程，遇到这种问题是解决的办法就是：寻找先序、中序、后序遍历的规律，找到下一个结点。 在先序遍历过程中，如果结点因为有右孩子导致无法找到其后继结点，如果结点有左孩子，则后继结点是其左孩子；否则，就一定是右孩子。拿图 3 举例，结点 + 的后继结点是其左孩子结点 a ，如果结点 a 不存在的话，就是结点 * 。 在中序遍历过程中，结点的后继是遍历其右子树时访问的第一个结点，也就是右子树中位于最左下的结点。例如图 3 中结点 * ，后继结点为结点 c ，是其右子树中位于最左边的结点。反之，结点的前趋是左子树最后访问的那个结点。 后序遍历中找后继结点需要分为 3 种情况：如果该结点是二叉树的根，后继结点为空；如果该结点是父结点的右孩子（或者是左孩子，但是父结点没有右孩子），后继结点是父结点；如果该结点是父结点的左孩子，且父结点有右子树，后继结点为父结点的右子树在后序遍历列出的第一个结点。使用后序遍历建立的线索二叉树，在真正使用过程中遇到链表的断点时，需要访问父结点，所以在初步建立二叉树时，宜采用三叉链表做存储结构。 12345678910111213141516171819//中序遍历线索二叉树void InOrderThraverse_Thr(BiThrTree p)&#123; while(p) &#123; //一直找左孩子，最后一个为中序序列中排第一的 while(p-&gt;Ltag == Link)&#123; p = p-&gt;lchild; &#125; printf("%c ", p-&gt;data); //操作结点数据 //当结点右标志位为1时，直接找到其后继结点 while(p-&gt;Rtag == Thread &amp;&amp; p-&gt;rchild !=NULL)&#123; p = p-&gt;rchild; printf("%c ", p-&gt;data); &#125; //否则，按照中序遍历的规律，找其右子树中最左下的结点，也就是继续循环遍历 p = p-&gt;rchild; &#125;&#125; 平衡二叉树（AVL Tree）平衡二叉树的定义平衡二叉树指的是要么它本身是一个空树，要么它是一个左子树和右子树的深度之差的绝对值不大于1，并且保证左右子树都是平衡树，下图就是一个平衡二叉树。从图中我们可以看出，一个结点的高度位1则表明为其叶子结点到父结点的高度，整颗树的高度取决于最深叶子结点到根结点的距离。由于AVL树操作中有许多的操作需要向上进行，所以数据结构应这样设计： 12345678910typedef struct treeNode&#123; char key; int val; //平衡因子，-1，0，1为合理值 int balanceFactor; struct treeNode *left; struct treeNode *right; //父节点，方便向上的操作进行 struct treeNode *Parent;&#125;AVLTree,*PAVLTree; 平衡二叉树的操作AVL树的查找操作和普通的二叉树的查找基本一致，但是插入和删除操作有所不同，因为插入和删除会减少树的结点并且改变树的结构，这个时候为了使树始终保持平衡状态我们需要对树进行重构使其始终保持平衡状态，一般这个操作叫做旋转操作（rotation），旋转分为左旋转和右旋转等。我们需要使用旋转操作使得在插入和删除操作之后使二叉平衡树在插入和删除某结点之后依然保持平衡。 旋转操作旋转的操作主要有左旋转和右旋转。旋转操作的基本原理都一样，最终目的就是为了让二叉平衡树在被操作之后再次达到平衡。 左旋转在上图所表示的左旋转操作中，我们假设的是x &lt; y &lt; z，因为树不平衡了，我们执行左旋转，将x及其左子树进行左旋转，并且将原本y的左子树变为x的右子树，这里需要注意的两点， ①就是我们需要寻找到三个点，这三个点的大小是有排序的，如这此段开头所说道的xyz的关系，将中间那个值作为新的中心结点，然后再进行旋转操作。 ②就是一定要确保所有的左右子树遵循二叉树的定义要求，既左子树一定要永远都是小于其父结点的，而右子树始终大于父结点的。C语言实现：12345678910111213141516PAVLTree leftRotate(PAVLTree Node)&#123; PAVLTree Temp = Node-&gt;right; Node-&gt;right = Temp-&gt;left; Temp-&gt;left = Node; Temp-&gt;Parent = Node-&gt;Parent; if(Temp-&gt;left) Temp-&gt;left-&gt;Parent = Temp; if(Temp-&gt;right) Temp-&gt;right-&gt;Parent = Temp; if(Node-&gt;left) Node-&gt;left-&gt;Parent = Node; if(Node-&gt;right) Node-&gt;right-&gt;Parent = Node; return Temp;&#125; 右旋转上图所述的三个节点的关系为z &lt; x &lt; y，因此根据左旋转所描述的我们可以知道x应该作为中心结点也就是父结点，然后这里需要进行两次旋转才能使二叉树最终处于平衡，首先是先对z进行左旋转，将z变为x的左子树，然后再对y进行右旋转，在这个过程中，x的左子树变为z的右子树，而右子树则成为了y的左子树。C语言实现： 12345678910111213141516PAVLTree rightRotate(PAVLTree Node)&#123; PAVLTree Temp = Node-&gt;left; Node-&gt;left = Temp-&gt;right; Temp-&gt;right = Node; Temp-&gt;Parent = Node-&gt;Parent; if(Temp-&gt;left) Temp-&gt;left-&gt;Parent = Temp; if(Temp-&gt;right) Temp-&gt;right-&gt;Parent = Temp; if(Node-&gt;left) Node-&gt;left-&gt;Parent = Node; if(Node-&gt;right) Node-&gt;right-&gt;Parent = Node; return Temp;&#125; 自旋转在实现了左旋和右旋操作之后，我们就可以编写一个自平衡函数，来在进行插入和删除操作后自动使二叉树重新达到平衡。在编写自旋转函数之前，我们需要明白我们在插入或者删除的时候可能导致的树的不平衡的所有情况。情况1和4是最简单的，我们只需要对结点Z进行一个左右的旋转即可，旋转和红黑树的旋转一样。目的是降低子树的高度差。情况2和情况3需要先对y进行左或者右旋转，变成情况1和4，然后再照着情况1，和4处理。其实每次插入删除的时候引起的不平衡的结点都是插入、删除的结点的父节点，不肯是其父节点的兄弟结点之类，而且我们总是通过不平衡结点加上往下的两个结点，来判断出事情况几。往下的结点怎么选取呢？选取的规定就是，看刚插入或者删除的结点是在不平衡结点的左子树还是右子树，加入在左子树，那么继续判断刚插入或者删除的结点在该左子树的左子树还是右子树，只需要这么两步就可以判断出情况。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//树的权值搜索函数PAVLTree searchKey(PAVLTree t,ElemType key)&#123; PAVLTree p=t; while(p) &#123; if(p-&gt;key==key) return p; else if(p-&gt;key&lt;key) p=p-&gt;rchild; else p=p-&gt;lchild; &#125; return p;&#125;//树的自平衡函数,传入的参数是新插入的节点PAVLTree AVLTreeBalance(PAVLTree *Node)&#123; if(!(*Node)) return NULL; PAVLTree *BFNode; PAVLTree Temp = *Node; PAVLTree Parent; //0--left,1--right int LeftOrRight = -1; PAVLTree find = (*Node); BFNode = Node; //查找到不平衡的结点 while(find) &#123; if(find-&gt;balanceFactor == -2 || find-&gt;balanceFactor == 2) break; find = find-&gt;Parent; &#125; //当前树平衡 if(!find) &#123; while(Temp-&gt;Parent) Temp = Temp-&gt;Parent; return Temp; &#125; (*BFNode) = find; //如果存在父节点 if((*BFNode)-&gt;Parent) &#123; Parent = (*BFNode)-&gt;Parent; if(Parent-&gt;left == (*BFNode)) LeftOrRight = 0; else LeftOrRight = 1; &#125; else Parent = NULL; //辅助判断是哪种情况的变量 int Second,Third; Second = searchKey((*BFNode),Temp-&gt;key,&amp;find); if(Second == 0) Third = searchKey((*BFNode)-&gt;left,Temp-&gt;key,&amp;find); else Third = searchKey((*BFNode)-&gt;right,Temp-&gt;key,&amp;find); //情况一，左左左 if(Second == 0 &amp;&amp; Third == 0) (*BFNode) = rightRotate((*BFNode)); //情况二，右右右 else if(Second == 1 &amp;&amp; Third == 1) (*BFNode) = leftRotate((*BFNode)); //情况三，左左右 else if(Second == 0 &amp;&amp; Third == 1) &#123; (*BFNode)-&gt;left = leftRotate((*BFNode)-&gt;left); (*BFNode) = rightRotate((*BFNode)); &#125; //情况四，右右左 else &#123; (*BFNode)-&gt;right = rightRotate((*BFNode)-&gt;right); (*BFNode) = leftRotate((*BFNode)); &#125; if(LeftOrRight != -1) &#123; if(LeftOrRight == 0) Parent-&gt;left = (*BFNode); else Parent-&gt;right = (*BFNode); &#125; //返回根节点 while(Temp-&gt;Parent) Temp = Temp-&gt;Parent; return Temp;&#125; 一些辅助函数其它的一些辅助函数与普通的二叉树没什么不同。 获得AVL树的深度C语言实现： 123456789//获得树的深度int GetDeepth(PAVLTree Node)&#123; if(!Node) return 0; int left = GetDeepth(Node-&gt;left); int right = GetDeepth(Node-&gt;right); return (left &gt; right ? (left+1) : (right+1));&#125; 重新计算树的平衡因子//重新计算树的平衡因子，但是只会回溯插入节点的沿途父节点,始终以左节点层数减去右节点层数C语言实现： 12345678void CalculateBF(PAVLTree Node)&#123; //根节点的父节点就终止 if(!Node) return; Node-&gt;balanceFactor = GetDeepth(Node-&gt;left)-GetDeepth(Node-&gt;right); CalculateBF(Node-&gt;Parent);&#125; 插入操作平衡二叉树的插入操作与普通二叉查找树的操作一样，新插入的节点都发生在叶子结点，唯一不同的就如上述所说，新插入的结点致使树的结构发生改变而导致不平衡，此时需要进行旋转以达到平衡。这时我们会发现此时的二叉树已经不平衡，这时我们需要寻找到树里面导致树不平衡的三个点，进行相应的操作，具体有以下两步： ① 先对结点39以结点42为父结点进行左旋转，此时节点40变成了39的右结点，而33，39，40一起成为了结点42的左子树。 ② 对结点53进行右旋转，将其变成节点42的右子树，结点55依然为结点53的右子树。由此便完成了整棵树的重构并让新的树保持平衡。重构之后的树如下图所示：有了上边的自平衡函数，那么AVL树的插入和删除操作就会变得非常简单。C语言实现:123456789101112131415161718192021222324252627282930//插入操作PAVLTree insertKey(PAVLTree *root,char key,int val)&#123; //为空，表示应该插入的位置 if(!(*root)) &#123; (*root) = (PAVLTree)malloc(sizeof(AVLTree)); (*root)-&gt;key = key; //(*root)-&gt;Parent = (*root); (*root)-&gt;val = val; (*root)-&gt;left = (*root)-&gt;right = NULL; //Balance factor and primary value is 0 (*root)-&gt;balanceFactor = 0; return (*root); &#125; //如果已经存在那么修正值就行: else if((*root)-&gt;key == key) &#123; (*root)-&gt;key = key; return (*root); &#125; //在左子树 else if((*root)-&gt;key &gt; key) insertKey(&amp;(*root)-&gt;left,key,val)-&gt;Parent = (*root); //在右子树 else if((*root)-&gt;key &lt; key) insertKey(&amp;(*root)-&gt;right,key,val)-&gt;Parent = (*root); CalculateBF(*root); return (*root);&#125; 删除操作假设在插入的基础上删除结点22，那么此时我们从节点19开始遍历找到第一个导致不平衡的结点为25并且具有最大高度值的结点，之后往右子树进行便利寻找到第二个具有最大高度值的结点，此结点为42（下图标注了红色边框的结点）。过程如下图所示：那么删除的策略就是： 1.叶子结点那么直接删除。 2.不是叶子结点，但是只有一个儿子结点，那么删除该节点，用其儿子结点顶替 3.不是叶子结点，但是有两个儿子结点，那么查找该树的中序遍历情况下，要删除节点的下一个结点来顶替，（其实就是右子树的最小值结点）C语言实现：123456789101112131415161718192021222324252627282930313233//删除函数PAVLTree deleteKey(PAVLTree *root,char key)&#123; PAVLTree DeleteNode = (PAVLTree)malloc(sizeof(AVLTree)); //查找到，那么删除 if((*root)-&gt;key == key) &#123; //为了调试少写一点 DeleteNode-&gt;key = (*root)-&gt;key; DeleteNode-&gt;val = (*root)-&gt;val; //叶子节点，直接删除 if(!(*root)-&gt;left &amp;&amp; !(*root)-&gt;right) (*root) = NULL; else if(!(*root)-&gt;left) (*root) = (*root)-&gt;right; else if(!(*root)-&gt;right) (*root) = (*root)-&gt;left; //最复杂的情况需要寻找中序遍历的下一个点来顶替（右子树的最小结点） else &#123; PAVLTree Temp = deleteMin(&amp;(*root)-&gt;right); (*root)-&gt;key = Temp-&gt;key; (*root)-&gt;val = Temp-&gt;val; &#125; &#125; else if((*root)-&gt;key &gt; key) DeleteNode = deleteKey(&amp;(*root)-&gt;left,key); else DeleteNode = deleteKey(&amp;(*root)-&gt;right,key); CalculateBF(*root); AVLTreeBalance(root); return DeleteNode;&#125; Reference：AVL（自平衡二叉树）树的实现（C语言） 哈夫曼树赫夫曼树，别名“哈夫曼树”、“最优树”以及“最优二叉树”。学习哈夫曼树之前，首先要了解几个名词。 哈夫曼树相关的几个名词 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。上图中，从根结点到结点 a 之间的通路就是一条路径。 路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。上图中从根结点到结点 c 的路径长度为 3。 节点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，上图中结点 a 的权为 7，结点 b 的权为 5。 结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，上图中结点 b 的带权路径长度为 2 * 5 = 10 。树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如上图中所示的这颗树的带权路径长度为：WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3哈夫曼树的定义 当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。 在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在上图中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。 构建哈夫曼树的过程对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。上图中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。 哈夫曼树中的节点结构构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。 12345//哈夫曼树结点结构typedef struct &#123; int weight;//结点权重 int parent, left, right;//父结点、左孩子、右孩子在数组中的位置下标&#125;HTNode, *HuffmanTree; 构建哈夫曼树的算法实现构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。 查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑： 如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点； 如果介于两个结点权重值之间，替换原来较大的结点；C语言的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//HT数组中存放的哈夫曼树，end表示HT数组中存放结点的最终位置，s1和s2传递的是HT数组中权重值最小的两个结点在数组中的位置void Select(HuffmanTree HT, int end, int *s1, int *s2)&#123; int min1, min2; //遍历数组初始下标为 1 int i = 1; //找到还没构建树的结点 while(HT[i].parent != 0 &amp;&amp; i &lt;= end)&#123; i++; &#125; min1 = HT[i].weight; *s1 = i; i++; while(HT[i].parent != 0 &amp;&amp; i &lt;= end)&#123; i++; &#125; //对找到的两个结点比较大小，min2为大的，min1为小的 if(HT[i].weight &lt; min1)&#123; min2 = min1; *s2 = *s1; min1 = HT[i].weight; *s1 = i; &#125;else&#123; min2 = HT[i].weight; *s2 = i; &#125; //两个结点和后续的所有未构建成树的结点做比较 for(int j=i+1; j &lt;= end; j++) &#123; //如果有父结点，直接跳过，进行下一个 if(HT[j].parent != 0)&#123; continue; &#125; //如果比最小的还小，将min2=min1，min1赋值新的结点的下标 if(HT[j].weight &lt; min1)&#123; min2 = min1; min1 = HT[j].weight; *s2 = *s1; *s1 = j; &#125; //如果介于两者之间，min2赋值为新的结点的位置下标 else if(HT[j].weight &gt;= min1 &amp;&amp; HT[j].weight &lt; min2)&#123; min2 = HT[j].weight; *s2 = j; &#125; &#125;&#125; s1和s2传入的是实参的地址，所以函数运行完成后，实参中存放的自然就是哈夫曼树中权重值最小的两个结点在数组中的位置。构建哈弗曼树的代码实现如下： 12345678910111213141516171819202122232425262728293031323334//HT为地址传递的存储哈夫曼树的数组，w为存储结点权重值的数组，n为结点个数void CreateHuffmanTree(HuffmanTree *HT, int *w, int n)&#123; if(n&lt;=1) return; // 如果只有一个编码就相当于0 int m = 2*n-1; // 哈夫曼树总节点数，n就是叶子结点 *HT = (HuffmanTree) malloc((m+1) * sizeof(HTNode)); // 0号位置不用 HuffmanTree p = *HT; // 初始化哈夫曼树中的所有结点 for(int i = 1; i &lt;= n; i++) &#123; (p+i)-&gt;weight = *(w+i-1); (p+i)-&gt;parent = 0; (p+i)-&gt;left = 0; (p+i)-&gt;right = 0; &#125; //从树组的下标 n+1 开始初始化哈夫曼树中除叶子结点外的结点 for(int i = n+1; i &lt;= m; i++) &#123; (p+i)-&gt;weight = 0; (p+i)-&gt;parent = 0; (p+i)-&gt;left = 0; (p+i)-&gt;right = 0; &#125; //构建哈夫曼树 for(int i = n+1; i &lt;= m; i++) &#123; int s1, s2; Select(*HT, i-1, &amp;s1, &amp;s2); (*HT)[s1].parent = (*HT)[s2].parent = i; (*HT)[i].left = s1; (*HT)[i].right = s2; (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight; &#125;&#125; 注意，如果使用此程序，对权重值分别为 2、8、7、6、5 的节点构建哈夫曼树，最终效果如图 4(A) 所示。但其实，图 4(B) 中显示的哈夫曼树也满足条件，这两棵树的带权路径长度相同。之所以使用此程序构建的哈夫曼树，是图 4(A) 而不是 4(B)，是因为在构建哈夫曼树时，结点 2 和结点 5 构建的新的结点 7 存储在动态树组中位置，比权重值为 7 节点的存储位置还靠后，所以，在程序继续选择两个权值最小的结点时，直接选择了的叶子结点 6 和 7 。Reference:哈夫曼树（赫夫曼树、最优树）详解 字典树字典树的定义字典树，顾名思义，就是用树的结构去存储单词。比如，我要存储单词ant和apple，就可以采取下图的多叉树结构去实现，其中可以看到，他们公用A节点，看是上去似乎节省了空间（实际上并没有，下面会解释），和形成了有序的分组。假设我们采用的是传统的方法，也就是用一个数组，把单词存进去。那么我们可以比较以下这两个方法的时间复杂度假设每个单词平均有M个字母，一共有N个单词。|操作|传统算法|字典树||—|—|—||插入|O(N)|O(M)||查找|O(N)|O(M)||删除|O(N)|O(M)|显然，当需要存储的数据量越庞大或者数据的操作越频繁，字典树的优势越明显，它的时间复杂度只与单词的长度有关。这个算法可以应用在词频分析，信息检索，字符串匹配等方面。 字典树的实现C语言实现 定义结构体12345typedef struct node &#123; struct node* children[SUB_NODE_COUNT]; int flag; char character;&#125; Node; 树节点的数据包含三个部分 所含的字母 指向下一节点的指针 是否能终结的标志位，也就是说是否能与它的祖先节点组成一个单词。字典树的插入函数C语言实现123456789101112131415161718192021222324252627282930313233343536373839Node* create_node(char c, int flag) &#123; Node* n = malloc(sizeof(Node)); n-&gt;character = c; n-&gt;flag = flag; for (int i = 0; i &lt; SUB_NODE_COUNT; i++) &#123; n-&gt;children[i] = NULL; &#125; return n;&#125;int append_node(Node* n, char c) &#123; Node* child_ptr = n-&gt;children[c-'a']; if (child_ptr) &#123; return FALSE; &#125; else &#123; n-&gt;children[c-'a'] = create_node(c, FALSE); return TRUE; &#125;&#125;int add_word(Node* root, char* str) &#123; char c = *str; Node* ptr = root; int flag = TRUE; while(c != '\0') &#123; if (!append_node(ptr, c)) &#123; flag = FALSE; &#125; ptr = ptr-&gt;children[c-'a']; c = *(++str); &#125; if (!ptr-&gt;flag) &#123; flag = FALSE; ptr-&gt;flag = TRUE; &#125; return !flag;&#125; 这个函数的功能，将单词插入树中，假如目标单词已经存在于树中，则返回FALSE , 否则就能成功插入，返回TRUE。插入的过程比较简单，只要单词字母对应的节点存在，则继续往下查询，否则就创建新节点，然后在最后的一个字母的节点把flag改为FALSE; 字典树的查找函数C语言实现 12345678910111213141516171819int check(Node* root, char* word) &#123; Node* ptr = root; int len = strlen(word); for (int i = 0; i &lt; len; i++) &#123; if (!ptr) &#123; printf("\"%s\" isn't in the Dictionary!\n", word); return FALSE; &#125; ptr = ptr-&gt;children[word[i]-'a']; &#125; if (ptr &amp;&amp; ptr-&gt;flag) &#123; printf("\"%s\" is in the Dictionary!\n", word); return TRUE; &#125; else &#123; printf("\"%s\" isn't in the Dictionary!\n", word); return FALSE; &#125;&#125; 字典树的遍历函数C语言实现： 12345678910111213141516171819202122232425void traversal(Node* root, char* str) &#123; if (!root) &#123; return; &#125; int len_of_str = strlen(str); char* new_str = malloc(len_of_str+1); strcpy(new_str, str); new_str[len_of_str] = root-&gt;character; if (root-&gt;flag) &#123; //输出 char* str_for_print = malloc(len_of_str+2); strcpy(str_for_print, new_str); str_for_print[len_of_str+1] = '\0'; printf("%s\n", str_for_print); free(str_for_print); &#125; for (int i = 0; i &lt; SUB_NODE_COUNT; i++) &#123; traversal(root-&gt;children[i], new_str); &#125; free(new_str);&#125; 很显然，这里用深度优先遍历比较合适，因为这是根据单词字母的组成来垂直扩展多叉树的。对于深度优先算法，递归是最能偷懒的方法啦！深度遍历的过程中，只要遇到flag等于TRUE，跟祖先节点构成单词输出，那就OK啦。 字典树的删除函数C语言实现： 1234567891011121314151617181920212223242526272829303132333435int isLeave(Node* root) &#123; for (int i = 0; i &lt; SUB_NODE_COUNT; i++) &#123; if (root-&gt;children[i]) &#123; return FALSE; &#125; &#125; return TRUE;&#125;int delete_word(Node* root, char* word) &#123; int len = strlen(word); int first_index = word[0] - 'a'; if (!root-&gt;children[first_index]) &#123; return FALSE; &#125; if (len == 1) &#123; if (root-&gt;children[first_index]-&gt;flag) &#123; if (isLeave(root-&gt;children[first_index])) &#123; free(root-&gt;children[first_index]); root-&gt;children[first_index] = NULL; &#125; else &#123; root-&gt;children[first_index]-&gt;flag = FALSE; &#125; return TRUE; &#125; else &#123; return FALSE; &#125; &#125; int flag = delete_word(root-&gt;children[first_index], word+1); if (isLeave(root-&gt;children[first_index]) &amp;&amp; !root-&gt;children[first_index]-&gt;flag) &#123; free(root-&gt;children[first_index]); root-&gt;children[first_index] = NULL; &#125; return flag;&#125; 其实删除一个单词最直接的方法就是把最后一个字母的flag改为FALSE就可以了。但是如果只是这么做的话，随着操作的次数增加，会产生许多多余的没必要的节点，浪费很多的空间。因此这个函数需要完成两件事 判断删除的单词是否存在，假如不存在则返回FALSE. 删除多余的节点。节点必须同时满足以下两点才能定义为多余的节点。 没有子节点（叶子节点） flag的值为FALSE完整实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TRUE 1#define FALSE 0#define SUB_NODE_COUNT 26typedef struct node &#123; struct node* children[SUB_NODE_COUNT]; int flag; char character;&#125; Node;Node* create_node(char c, int flag) &#123; Node* n = malloc(sizeof(Node)); n-&gt;character = c; n-&gt;flag = flag; for (int i = 0; i &lt; SUB_NODE_COUNT; i++) &#123; n-&gt;children[i] = NULL; &#125; return n;&#125;int append_node(Node* n, char c) &#123; Node* child_ptr = n-&gt;children[c-'a']; if (child_ptr) &#123; return FALSE; &#125; else &#123; n-&gt;children[c-'a'] = create_node(c, FALSE); return TRUE; &#125;&#125;int add_word(Node* root, char* str) &#123; char c = *str; Node* ptr = root; int flag = TRUE; while(c != '\0') &#123; if (!append_node(ptr, c)) &#123; flag = FALSE; &#125; ptr = ptr-&gt;children[c-'a']; c = *(++str); &#125; if (!ptr-&gt;flag) &#123; flag = FALSE; ptr-&gt;flag = TRUE; &#125; return !flag;&#125;void traversal(Node* root, char* str) &#123; if (!root) &#123; return; &#125; int len_of_str = strlen(str); char* new_str = malloc(len_of_str+1); strcpy(new_str, str); new_str[len_of_str] = root-&gt;character; if (root-&gt;flag) &#123; //输出 char* str_for_print = malloc(len_of_str+2); strcpy(str_for_print, new_str); str_for_print[len_of_str+1] = '\0'; printf("%s\n", str_for_print); free(str_for_print); &#125; for (int i = 0; i &lt; SUB_NODE_COUNT; i++) &#123; traversal(root-&gt;children[i], new_str); &#125; free(new_str);&#125;int check(Node* root, char* word) &#123; Node* ptr = root; int len = strlen(word); for (int i = 0; i &lt; len; i++) &#123; if (!ptr) &#123; printf("\"%s\" isn't in the Dictionary!\n", word); return FALSE; &#125; ptr = ptr-&gt;children[word[i]-'a']; &#125; if (ptr &amp;&amp; ptr-&gt;flag) &#123; printf("\"%s\" is in the Dictionary!\n", word); return TRUE; &#125; else &#123; printf("\"%s\" isn't in the Dictionary!\n", word); return FALSE; &#125;&#125;int isLeave(Node* root) &#123; for (int i = 0; i &lt; SUB_NODE_COUNT; i++) &#123; if (root-&gt;children[i]) &#123; return FALSE; &#125; &#125; return TRUE;&#125;int delete_word(Node* root, char* word) &#123; int len = strlen(word); int first_index = word[0] - 'a'; if (!root-&gt;children[first_index]) &#123; return FALSE; &#125; if (len == 1) &#123; if (root-&gt;children[first_index]-&gt;flag) &#123; if (isLeave(root-&gt;children[first_index])) &#123; free(root-&gt;children[first_index]); root-&gt;children[first_index] = NULL; &#125; else &#123; root-&gt;children[first_index]-&gt;flag = FALSE; &#125; return TRUE; &#125; else &#123; return FALSE; &#125; &#125; int flag = delete_word(root-&gt;children[first_index], word+1); if (isLeave(root-&gt;children[first_index]) &amp;&amp; !root-&gt;children[first_index]-&gt;flag) &#123; free(root-&gt;children[first_index]); root-&gt;children[first_index] = NULL; &#125; return flag;&#125;int main(void) &#123; Node *root = create_node('$', FALSE); //测试add_ word函数 add_word(root, "abc"); add_word(root, "abcd"); add_word(root, "world"); add_word(root, "nnaiodnf"); traversal(root, ""); //测试check函数 check(root, "abc"); check(root, "abcd"); //测试delete_word函数 delete_word(root, "abe"); check(root, "abe"); return EXIT_SUCCESS;&#125; Reference:用C语言实现字典树 线段树直接上链接，说的贼详细线段树详解 树状数组直接上链接，说的贼详细树状数组详解 最小生成树这个不是树，是图，就直接放链接吧最小生成树构造算法其实是我学不动了 LeetCode题解LeetCode题号: 101. 对称二叉树话不多说，直接上代码 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */bool isSymmetric(struct TreeNode* root)&#123; if (root == NULL) return true; return fun(root-&gt;left, root-&gt;right);&#125;int fun(struct TreeNode* left,struct TreeNode* right)&#123; if(left == NULL&amp;&amp;right == NULL)&#123; return true; &#125; if(left == NULL || right == NULL)&#123; return false; &#125; if(left-&gt;val!=right-&gt;val)&#123; return false; &#125; return fun(left-&gt;left,right-&gt;right)&amp;&amp;fun(left-&gt;right,right-&gt;left);&#125; 思路:如果同时满足下面的条件，两个树互为镜像： 它们的两个根结点具有相同的值。 每个树的右子树都与另一个树的左子树镜像对称。因此，我们就可以很自然地把上边的想法写成一个递归函数。LeetCode题号：96. 不同的二叉搜索树可以使用动态规划法求解给定一个有序序列 1 … n，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 i，将该数字作为树根，1 … (i-1) 序列将成为左子树，(i+1) … n 序列将成为右子树。于是，我们可以递归地从子序列构建子树。在上述方法中，由于根各自不同，每棵二叉树都肯定能保证是独特的。C语言实现：123456789101112int numTrees(int n)&#123; int * dp = (int*)malloc(sizeof(int)*(n+2)); bzero(dp,sizeof(int)*(n+2)); dp[0] = 1; dp[1] = 1; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++)&#123; dp[i] += dp[j - 1] * dp[i - j]; &#125; return dp[n];&#125; LeetCode题号: 99. 恢复二叉搜索树因为题目中说了，二叉搜索树中只有两个节点被错误地交换。并且，正常的二叉搜索树中序遍历输出应该是递增的。所以，在遍历二叉树的过程中找到不满足递增的点（即错误交换的点），交换两者的值即可。错误交换的点在中序遍历结果中可能是相邻的，也可能是不相邻的。例如，若一棵树中序遍历结果1324，错误交换的点2和3就是相邻的；使用first和second表示错误交换的两个点，在第一次遇到不递增的情况时，将first置为3，second置为2，遍历结束后交换first与second。 再如，若一棵树中序中序遍历结果321，错误交换的点就是不相邻的。在第一次遇到不递增的情况时，将first设置为3，second设置为2，在第二次遇到不递增的情况时，只改变second，将second置为1.遍历结束后交换first与second。将这个想法写成代码，就成了下面这个样子。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; */struct TreeNode* first = NULL;struct TreeNode* second = NULL;struct TreeNode* pre = NULL;void inorder(struct TreeNode* root)&#123; if(root == NULL) return; inorder(root-&gt;left); if(pre != NULL &amp;&amp; pre-&gt;val &gt; root-&gt;val)&#123; if(first == NULL)&#123;//first为空,首次找到前后大小不对的点 first = pre; second = root; &#125; else&#123;//first不为空,第二次找到前后大小不对的点,只更新second second = root; &#125; &#125; pre = root; inorder(root-&gt;right);&#125;void recoverTree(struct TreeNode* root)&#123; inorder(root); int tmp = first-&gt;val; first-&gt;val = second-&gt;val; second-&gt;val = tmp;&#125; 然而并没有AC，就先洗洗睡了 我保证会把线段树、树状数组、最小生成树认真学了就这样，先咕为敬！有空再补！]]></content>
      <tags>
        <tag>C</tag>
        <tag>Learning</tag>
        <tag>Data Structure</tag>
        <tag>Tree</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network-Task2]]></title>
    <url>%2F2019%2F11%2F10%2FNetwork-Task2%2F</url>
    <content type="text"><![CDATA[吹着前奏望着天空，我想起Task试着完成，为它爆肝的那一天，断电的那一天，709的那一间，我怎么做不完，消失的DDL，我好像再来一年~ 安装准备Problem1.apt源配置问题在开始之前，我才发现自己的apt源配错了。我使用的是Ubuntu19.10（eoan），但是apt源里居然全写的是Ubuntu 18.04 LTS（Bionic）的源……因此出现了花式安装报错的问题。Solution:自己手动把所有的Bionic都换成eoan…… Problem2.没有合适的IDE由于这次任务需要在Linux上完成，自己的能力又没有强到能够用眼调试的水平。因此需要安装一个IDE。（能用GCC调试我也服气）Solution：用HUST邮箱整一个CLion。网址：CLion白嫖就完事了~ Echo Server代码话不多说，直接上代码： Linux Server端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;netdb.h&gt;#include &lt;sys/socket.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#define EHCO_PORT 28345//监听端口#define MAX_CLIENT_NUM 10//最大客户端连接数量#define MAX_BUFF 101//最大缓冲区长度void charConversion(char array[]);//大小写转换int isLowerCase(char ch);//判断小写int main()&#123; int socketfd; socketfd = socket(AF_INET, SOCK_STREAM, 0);//创建套接字 if(socketfd == -1)&#123; printf("errno=%d \n", errno); exit(1); &#125; else&#123; printf("socket create successfully \n"); &#125; struct sockaddr_in sa; bzero(&amp;sa,sizeof(sa));//重置结构体 sa.sin_family = AF_INET; sa.sin_port = htons(EHCO_PORT);//设定监听端口 sa.sin_addr.s_addr = htons(INADDR_ANY);//设定本地IP bzero(&amp;(sa.sin_zero), 8); if(bind(socketfd, (struct sockaddr *)&amp;sa, sizeof(sa))!= 0)&#123; printf("bind failed \n"); printf("errno=%d \n", errno); exit(1); &#125; else&#123; printf("bind successfully \n"); &#125; if(listen(socketfd ,MAX_CLIENT_NUM) != 0)&#123; printf("listen error "); exit(1); &#125; else&#123; printf("listen successfully \n"); &#125; int clientfd; struct sockaddr_in clientAdd; char buff[MAX_BUFF]; socklen_t len = sizeof(clientAdd); int closing =0; clientfd = accept(socketfd, (struct sockaddr *)&amp;clientAdd, &amp;len); printf("Client ip is %s,port is %d\n",inet_ntoa(clientAdd.sin_addr),ntohs(clientAdd.sin_port)); while(closing == 0) &#123; int n; while ((n = recv(clientfd, buff, 100, 0)) &gt; 0) &#123;//循环接收数据 buff[n]='\0'; write(STDOUT_FILENO, buff, n); printf("successfully recv %d bytes\n", n); printf("client says :%s\n", buff); if (strcmp(buff, "quit") == 0) &#123;//根据不同情形判断操作 send(clientfd, "See you~", strlen("See you~"), 0); printf("server says: See you~\n"); closing = 1; break; &#125; charConversion(buff);//将小写全部变为大写 send(clientfd, buff, n, 0); printf("server replys:%s\n", buff); &#125; &#125; close(clientfd); close(socketfd); printf("socket close successfully!\n"); return 0;&#125;void charConversion(char array[])&#123; int i=0; // 定义数组循环下标 while(array[i])&#123;// 数组访问循环控制 //判断是否遇到了字符串的结束标志 if( isLowerCase(array[i]) )&#123; array[i] = array[i] - ('a'-'A'); // 小写转大写 &#125; i++; &#125;&#125;// 检测字符是否为小写字母， [a, z]int isLowerCase(char ch)&#123; return (ch&gt;='a'&amp;&amp;ch&lt;='z');&#125; Windows client端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#include &lt;winsock.h&gt;#include &lt;string.h&gt;#pragma comment( lib, "ws2_32.lib" )#define PORT 28345#define MAXDATASIZE 100#define Address 192.168.188.128void main(void)&#123; int iClientSock; int addr_len; struct sockaddr_in ServerAddr; int numbytes; char buf[MAXDATASIZE+1] = "hello world!"; WSADATA WSAData; //连接准备部分以及初始化 if (WSAStartup(0x0202, &amp;WSAData))&#123; printf("initializationing error!\n"); WSACleanup(); exit(0); &#125; if ((iClientSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)&#123; printf("创建套接字失败!\n"); WSACleanup(); exit(0); &#125; ServerAddr.sin_family = PF_INET; ServerAddr.sin_port = htons(PORT); ServerAddr.sin_addr.s_addr = inet_addr("192.168.188.128");//换localhost if (connect(iClientSock, (struct sockaddr*) &amp; ServerAddr, sizeof(SOCKADDR_IN)) != -1) &#123; printf("Connection success!\n"); &#125; else &#123; printf("Connection failed!\n"); exit(0); &#125; memset(&amp;(ServerAddr.sin_zero), 0, sizeof(ServerAddr.sin_zero)); addr_len = sizeof(struct sockaddr); printf("Server ip is %s,port is %d\n", inet_ntoa(ServerAddr.sin_addr), PORT); //发送数据部分 while (1) &#123; printf("client says:"); gets(buf); numbytes = send(iClientSock, buf, strlen(buf), 0); if (numbytes == -1)&#123; printf("send调用失败!\n"); WSACleanup(); exit(0); &#125; printf("successfully send %d bytes\n", numbytes); numbytes = -1; numbytes = recv(iClientSock, buf, MAXDATASIZE, 0); if (numbytes == -1)&#123; printf("recv调用失败!\n"); WSACleanup(); exit(0); &#125; buf[numbytes] = '\0'; printf("recv %d bytes\n", numbytes); printf("server replys:%s\n", buf); if (strcmp(buf, "See you~") == 0) &#123; return; &#125; &#125; closesocket(iClientSock); WSACleanup();&#125; 效果 ProblemSocket一直不能建立连接这是由于Linux和Windows的防火墙策略设置Solution：在Linux中安装白名单IP地址： 1sudo iptables -N whitelist-A whitelist -s 10.10.68.58 -j ACCEPT #将10.10.68.58换成你的主机真实网卡的IP地址 网卡设置有误在Task1中，我错误地将主机中VMnet8的IP地址设置成了VM1的IP地址192.168.188.128，导致出现了我一直都不能用ssh连接上我的虚拟机，但是ping又能ping通的诡异现象。Solution：在Windows系统中，更改VMnet8这张网卡的IP地址在虚拟机的相同网段下的其它IP，例如说192.168.188.1。 客户端协议设置出错由于之前在熬测的时候写过了类似的程序，于是乎我想都没想就在Windows系统上的client用了之前的的源码，然而这份源码是UDP协议的，但是在Linux上跑的是TCP协议的Server，导致Server一直不能发包到Client。Solution：重写Windows系统下的源码，改用TCP协议。虽然这次错误实在是有点蠢，但是我因此更加明确了我这次Task使用的一些socket函数在UDP协议与TCP协议的不同情况下使用的一些区别，也算是因祸得福（确信。 拓展client 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#define Windows#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#ifdef Windows#include &lt;windows.h&gt;#include &lt;winsock.h&gt;#pragma comment( lib, "ws2_32.lib" )#define Address "192.168.188.128"#endif#ifdef Linux#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define Address "192.168.188.1"#endif#define PORT 28345#define MAXDATASIZE 100void main(void)&#123; int iClientSock; struct sockaddr_in ServerAddr; int numbytes; char buf[MAXDATASIZE+1] = "hello world!";#ifdef Windows WSADATA WSAData; if (WSAStartup(0x0202, &amp;WSAData)) &#123; printf("initializationing error!\n"); WSACleanup(); exit(0); &#125;#endif if ((iClientSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) &#123; printf("创建套接字失败!\n");#ifdef Windows WSACleanup();#endif exit(0); &#125; ServerAddr.sin_family = PF_INET; ServerAddr.sin_port = htons(PORT); ServerAddr.sin_addr.s_addr = inet_addr(Address);//换localhost if (connect(iClientSock, (struct sockaddr*) &amp; ServerAddr, sizeof(ServerAddr)) != -1) &#123; printf("Connection success!\n"); &#125; else &#123; printf("Connection failed!\n"); exit(0); &#125; memset(&amp;(ServerAddr.sin_zero), 0, sizeof(ServerAddr.sin_zero)); printf("Server ip is %s,port is %d\n", inet_ntoa(ServerAddr.sin_addr), PORT); while (1) &#123; printf("client says:"); gets(buf); numbytes = send(iClientSock, buf, strlen(buf), 0); if (numbytes == -1) &#123; printf("send调用失败!\n");#ifdef Windows WSACleanup();#endif exit(0); &#125; printf("successfully send %d bytes\n", numbytes); numbytes = -1; numbytes = recv(iClientSock, buf, MAXDATASIZE, 0); if (numbytes == -1) &#123; printf("recv调用失败!\n");#ifdef Windows WSACleanup();#endif exit(0); &#125; buf[numbytes] = '\0'; printf("recv %d bytes\n", numbytes); printf("server replys:%s\n", buf); if (strcmp(buf, "See you~") == 0) &#123; return; &#125; &#125;#ifdef Windows closesocket(iClientSock); WSACleanup();#endif#ifdef Linux close(iClientSock);#endif&#125; Server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#define Windows#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#ifdef Linux#include &lt;netdb.h&gt;#include &lt;sys/socket.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#endif#ifdef Windows#include&lt;winsock2.h&gt;#include&lt;windows.h&gt;#include&lt;ws2tcpip.h&gt;#pragma comment( lib, "ws2_32.lib" )#endif#define EHCO_PORT 28345//监听端口#define MAX_CLIENT_NUM 10//最大客户端连接数量#define MAX_BUFF 101//最大缓冲区长度void charConversion(char array[]);//大小写转换int isLowerCase(char ch);//判断小写int main() &#123;#ifdef Windows WSADATA WSAData; if (WSAStartup(0x0202, &amp;WSAData)) &#123; printf("initializationing error!\n"); WSACleanup(); exit(0); &#125;#endif int socketfd; socketfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);//创建套接字 if (socketfd == -1) &#123;#ifdef Linux printf("errno=%d \n", errno);#endif printf("socket create failed \n");#ifdef Windows WSACleanup();#endif exit(1); &#125; else &#123; printf("socket create successfully \n"); &#125; struct sockaddr_in sa; memset(&amp;sa,0,sizeof(sa));//重置结构体 sa.sin_family = AF_INET; sa.sin_port = htons(EHCO_PORT);//设定监听端口 sa.sin_addr.s_addr = htons(INADDR_ANY);//设定本地IP memset(&amp;(sa.sin_zero),0, 8); if (bind(socketfd, (struct sockaddr*) &amp; sa, sizeof(sa)) != 0) &#123; printf("bind failed \n");#ifdef Linux printf("errno=%d \n", errno);#endif#ifdef Windows WSACleanup();#endif exit(1); &#125; else &#123; printf("bind successfully \n"); &#125; if (listen(socketfd, MAX_CLIENT_NUM) != 0) &#123; printf("listen error ");#ifdef Windows WSACleanup();#endif exit(1); &#125; else &#123; printf("listen successfully \n"); &#125; int clientfd; struct sockaddr_in clientAdd; char buff[MAX_BUFF]; socklen_t len = sizeof(clientAdd); int closing = 0; clientfd = accept(socketfd, (struct sockaddr*) &amp; clientAdd, &amp;len); printf("Client ip is %s,port is %d\n", inet_ntoa(clientAdd.sin_addr), ntohs(clientAdd.sin_port)); while (closing == 0) &#123; int n; while ((n = recv(clientfd, buff, 100, 0)) &gt; 0) &#123;//循环接收数据 buff[n] = '\0';#ifdef Linux write(STDOUT_FILENO, buff, n);#endif printf("successfully recv %d bytes\n", n); printf("client says :%s\n", buff); if (strcmp(buff, "quit") == 0) &#123;//根据不同情形判断操作 send(clientfd, "See you~", strlen("See you~"), 0); printf("server says: See you~\n"); closing = 1; break; &#125; charConversion(buff);//将小写全部变为大写 send(clientfd, buff, n, 0); printf("server replys:%s\n", buff); &#125; &#125;#ifdef Windows closesocket(clientfd); closesocket(socketfd); WSACleanup();#endif#ifdef Linux close(clientfd); close(socketfd);#endif printf("socket close successfully!\n"); return 0;&#125;void charConversion(char array[]) &#123; int i = 0; // 定义数组循环下标 while (array[i]) &#123;// 数组访问循环控制 //判断是否遇到了字符串的结束标志 if (isLowerCase(array[i])) &#123; array[i] = array[i] - ('a' - 'A'); // 小写转大写 &#125; i++; &#125;&#125;// 检测字符是否为小写字母， [a, z]int isLowerCase(char ch) &#123; return (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z');&#125; File Server话不多说，直接上代码 代码Linux receiver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include "head.h"#define BUFF_SIZE 1024#define PORT 28345#define FILE_NAME_SIZE 512int main(int argc,char *argv[])&#123; struct sockaddr_in s_addr,c_addr; int s_sockfd,c_sockfd; char buf[BUFF_SIZE]; int c_addr_len=sizeof(struct sockaddr_in); int s_addr_len=sizeof(struct sockaddr_in); s_sockfd=socket(AF_INET,SOCK_STREAM,0); if(s_sockfd==-1) strerr("socket error"); memset(&amp;s_addr,0,s_addr_len); s_addr.sin_family=AF_INET; s_addr.sin_port=htons(PORT); s_addr.sin_addr.s_addr=htonl(INADDR_ANY); int opt=1; setsockopt(s_sockfd,SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); if(bind(s_sockfd,(struct sockaddr*)&amp;s_addr,s_addr_len)==-1) strerr("bind error"); if(listen(s_sockfd,5)==-1) strerr("listen error"); while(1)&#123; printf("listening to connect........\n"); c_sockfd=accept(s_sockfd,(struct sockaddr*)&amp;c_addr,&amp;c_addr_len); if(c_sockfd==-1) strerr("accept error"); memset(buf,0,BUFF_SIZE); if(recv(c_sockfd,buf,BUFF_SIZE,0)==-1) strerr("recv error"); char filename[FILE_NAME_SIZE+1]; memset(filename,0,FILE_NAME_SIZE+1); strncpy(filename,buf,strlen(buf)&gt;FILE_NAME_SIZE? FILE_NAME_SIZE:strlen(buf)); filename[strlen(buf)]='\0'; if(strcmp(filename,"quit")==0)&#123; printf("Exit.\n"); break; &#125; printf("file name is %s\n",filename); FILE * fp=fopen(filename,"wb+"); if(NULL==fp) strerr("fopen error"); else&#123; int length=0; memset(buf,0,BUFF_SIZE); while((length=recv(c_sockfd,buf,BUFF_SIZE,0))&gt;0)&#123; if(fwrite(buf,sizeof(char),length,fp)&lt;length) strerr("fwrite error"); memset(buf,0,BUFF_SIZE); &#125; printf("receive file : %s from server successful\n",filename); fclose(fp); &#125; close(c_sockfd); &#125;//end while(1) close(s_sockfd); return 0;&#125; Windows Sender1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;WinSock2.h&gt; #define PORT 28345 #define SERVER_IP "192.168.188.128"#define BUFFER_SIZE 1024 #define FILE_NAME_MAX_SIZE 512 #pragma comment(lib, "WS2_32") int main(int argc, char* argv[])&#123; if (argc != 2)&#123; printf("usage : %s filename and format\n", argv[0]); exit(1); &#125; // 初始化socket dll WSADATA wsaData; WORD socketVersion = MAKEWORD(2, 0); if (WSAStartup(socketVersion, &amp;wsaData) != 0)&#123; printf("Init socket dll error!"); exit(1); &#125; //创建socket SOCKET c_Socket = socket(AF_INET, SOCK_STREAM, 0); if (SOCKET_ERROR == c_Socket)&#123; printf("Create Socket Error!"); system("pause"); exit(1); &#125;//指定服务端的地址 struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_addr.S_un.S_addr = inet_addr(SERVER_IP); server_addr.sin_port = htons(PORT); int opt = 1; setsockopt(c_Socket, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); if (SOCKET_ERROR == connect(c_Socket, (LPSOCKADDR)&amp;server_addr, sizeof(server_addr)))&#123; printf("Can Not Connect To Server IP!\n"); system("pause"); exit(1); &#125; char buffer[BUFFER_SIZE];//初始化缓冲区 memset(buffer, 0, BUFFER_SIZE); strncpy(buffer, argv[1], strlen(argv[1]) &gt; BUFFER_SIZE ? BUFFER_SIZE : strlen(argv[1]));//将文件名传入缓冲区 //向服务器发送文件名 if (send(c_Socket, buffer, BUFFER_SIZE, 0) &lt; 0)&#123; printf("Send File Name Failed\n"); system("pause"); exit(1); &#125; //打开文件，准备发送 FILE* fp = fopen(argv[1], "rb");//windows下是"rb",表示打开一个只读的二进制文件 if (NULL == fp)&#123; printf("File: %s Not Found\n", argv[1]); &#125; else&#123; memset(buffer, 0, BUFFER_SIZE); int length = 0; //获取文件长度 fseek(fp, 0, SEEK_END); //定位到文件末 long long nFileLen = ftell(fp); //文件总长度 fseek(fp, 0, SEEK_SET); //恢复到文件头 long long sendLength = 0; while ((length = fread(buffer, sizeof(char), BUFFER_SIZE, fp)) &gt; 0) &#123; if (send(c_Socket, buffer, length, 0) &lt; 0) &#123; printf("Send File: %s Failed\n", argv[1]); break; &#125; sendLength += length; printf("The File have sended %lld percent\n", sendLength * 100 / nFileLen); memset(buffer, 0, BUFFER_SIZE); &#125; fclose(fp); printf("File: %s Transfer Successful!\n", argv[1]); &#125; closesocket(c_Socket); //释放winsock库 WSACleanup(); system("pause"); return 0;&#125; 效果 ProblemProblem1：遇到了服务端创建文件成功，但是写入文件失败的情况Solution：经过检查发现，是Linux接收端的代码出现了问题。我写了一个死循环来实现持续接收文件。但是忘记了在每次接收完文件后使用fclose()语句来释放文件指针，导致文件写入失败。 iptables过滤报文通过使用iptables丰富的拓展模块，我们可以实现以下Task所要求的内容： 根据字符串过滤这个实现简单快捷，只需要一条shell语句： 1sudo iptables -t filter -I INPUT -m string --algo bm --string "CyberSecurity" -j REJECT ‘-I INPUT’表示对INPUT链进行操作‘-m string’ 表示使用string模块。‘–algo bm’表示使用bm算法去匹配指定的字符串。‘–string “CyberSecurity”‘则表示我们想要匹配的字符串。实现效果： 根据时间过滤这个实现也只需要一条shell语句： 1sudo iptables -t filter -I INPUT -p tcp --dport 28345 -m time --timestart 13:00:00 --timestop 16:00:00 -j REJECT 注意，这里的时间默认使用的是UTC标准时间，我们需要将我们想要设定的时间-8（因为我们在东八区）才可以使设置正常生效。‘-I INPUT’表示对INPUT链进行操作‘-m time’表示使用time模块。‘–timestart’选项用于指定起始时间‘–timestop’选项用于指定结束时间实现效果： 其余部分能力有限时间不足告辞，有空会回来补的]]></content>
      <tags>
        <tag>Dian CyberSecurity Team</tag>
        <tag>Network</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST-Task3]]></title>
    <url>%2F2019%2F11%2F02%2FAST-Task3%2F</url>
    <content type="text"><![CDATA[栈栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。栈可以根据是否可以动态增加存储空间，分为动态栈和静态栈两种。 动态栈动态栈是建立在malloc函数的基础之上的一种栈结构 动态栈的数据结构定义1234567891011typedef struct Node //定义一个链表式结点结构体&#123; int data; struct Node * last; &#125;*node; typedef struct Stack //定义链式栈结构体&#123; node top; //栈顶指针 int count; //记录栈结点数量&#125;stack; 由于动态栈的数据是可以变化的。因此在动态栈中是没有init()操作的，每一次push操作都会使得动态栈的大小动态扩大。 动态栈的入栈操作函数12345678void push(stack *S,int n)&#123; node curs = (node)malloc(sizeof(struct Node));//开辟新的存储空间用来存放链式表节点 curs -&gt; data = n;//存入节点 curs -&gt; last = S-&gt;top; S -&gt; top = curs;//更新top指针 S -&gt; count ++;&#125; 动态栈的出栈操作函数1234567891011121314int pop(stack *S)&#123; int output; node curs; //定义一个结点指针变量 if(S-&gt;count == 0)&#123; //判断栈是否为空 printf("Error,Stack is empty!\n"); exit(1); &#125; curs = S-&gt;top; //让新定义的结点指针指向当前栈顶 output = curs-&gt;data; //保存当前节点的数据 S-&gt;top = curs-&gt;last; //让栈顶指针指向栈顶结点的上一个结点 free(curs); //释放结点s的存储空间 S-&gt;count--; //结点个数减一 return output; //返回栈顶元素&#125; 动态栈的取栈顶元素函数123456789int Gettop(stack *S)&#123; if(S-&gt;count == 0) //判断栈是否为空 &#123; printf("Error,Stack is empty!\n"); exit(1); &#125; return S-&gt;top-&gt;data;&#125; 静态栈静态栈是建立在静态数组的基础之上的一种栈结构。 静态栈的数据结构定义123456#define MAXSIZE 1000typedef struct Stack //定义栈&#123; int data[MAXSIZE]; //栈中的数据 int top; //栈顶&#125;stack; 静态栈的初始化函数12345stack Init()&#123; //初始化栈 stack s; s-&gt;top = -1; return s;&#125; 静态栈的进栈操作函数123456789101112int Push(stack &amp;s,int n)&#123; //进栈操作，我们是对指针进行操作，因此需要添加取地址符 if(s-&gt;top == P-1)&#123; //进栈的时候必须判断是否栈满 printf("stack full\n"); exit(1); &#125; s-&gt;top++; s-&gt;data[s-&gt;top] = n; //将数据放入数组中 if(s-&gt;top == P-1)&#123; //进栈结束的时候判断是否栈满 return 0; &#125; return 1;&#125; 注意 由于静态表并不会自动增加存储空间，因此我们需要在进栈结束后判断栈是否已满，避免发生溢出情况。 静态栈的出栈操作函数12345678910int Pop(stack &amp;s)&#123; //出栈操作 int n; //出栈元素 if(s-&gt;top == -1)&#123; //出栈的时候必须判断是否栈空,避免数组越界 printf("stack empty\n"); exit(1); &#125; n = s-&gt;data[s-&gt;top]; s-&gt;top--; return n;&#125; 静态栈的取栈顶元素函数1234567int Gettop(stack *s)&#123; if(s-&gt;top == -1)&#123; //判断栈是否为空 printf("Error,Stack is empty!\n"); exit(1); &#125; return s-&gt;data[s-&gt;top];&#125; 栈的应用LeetCode 20 有效的括号思路遇左括号就入栈，遇右括号就把栈顶元素拿出来比对。如果栈空（用top指针判断）,则为True。 代码123456789101112131415161718192021222324bool isValid(char * s)&#123; if( s == NULL ) return false; char * stack = (char * ) malloc( sizeof(char) * ( strlen(s)+1 ) ); int top = 0; for( int i=0; s[i]!='\0'; i++) &#123; if(s[i]=='(' || s[i]=='[' || s[i]=='&#123;') //左括号入栈 stack[++top] = s[i]; else if( (s[i]==')'&amp;&amp;stack[top]=='(') || (s[i]==']'&amp;&amp;stack[top]=='[') || (s[i]=='&#125;'&amp;&amp;stack[top]=='&#123;') ) //右括号比对 top--; else //比对失败 return false; &#125; if( stack!= NULL) &#123; free(stack); stack = NULL; &#125; if( top == 0 ) //字符串结束且栈空 return true; else return false;&#125; LeetCode 150 逆波兰表达式求值思路写个循环遍历字符串碰到数字就压进栈遇到运算符就把栈顶的两个元素弹出来然后算了之后的结果再压进去直到最后把栈里的最后一个元素输出即可 代码这题真的很迷，每次运行都报数组越界，无奈只好放弃，就把有bug的源代码贴上来好了 1234567891011121314151617181920212223242526272829int evalRPN(char ** tokens, int tokensSize)&#123; int stack[10000], top = 0;//使用数组实现栈 int num1, num2; int i; for(i = 0; i &lt; tokensSize; i++)&#123; if(tokens[i] == '+' || tokens[i] == '-' || tokens[i] == '*' || tokens[i] == '/')&#123;//如果碰到运算符 num2 = stack[--top]; //将栈中的顶部两元素pop num1 = stack[--top];//先出栈的是除数/减数，后出栈的是被除数/除数 switch(tokens[i][0])&#123;//用switch_case语句确定不同运算情况 case '-' : stack[top++] = num1 - num2; break; case '+' : stack[top++] = num1 + num2; break; case '* ' : stack[top++] = num1 * num2; break; case '/' : stack[top++] = num1 / num2; break; &#125; &#125; else&#123; stack[top++] = atoi(tokens[i]);//将字符串中的字符转化为数字push进栈 &#125; &#125; return stack[--top];//将最终结果返回&#125; 队列队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列的实现队列的数据结构定义12345678910typedef struct Node//数据域&#123; int data; struct Node * next;&#125;Node,*DNode;typedef struct Queue//指针域&#123; DNode front; DNode rear;&#125;Queue,*DQueue; 队列的初始化函数1234void initQueue(DQueue Q)&#123; Q=(DQueue)malloc(sizeof(Queue));//申请队节点的内存空间 Q-&gt;front=Q-&gt;rear=NULL;&#125; 队列的入队操作函数123456789101112void inQueue(DQueue Q,int n)&#123; DNode q; q=(DNode)malloc(sizeof(Node)); //申请队节点的内存空间 q-&gt;next=NULL; q-&gt;data=n;将值放入节点中 if(Q-&gt;rear==NULL) //判断如果队空，则插入结点为队首结点 Q-&gt;front=Q-&gt;rear=q; else&#123; //若队不为空，尾指针所指的结点的next连接上q，同时后移尾指针 Q-&gt;rear-&gt;next=q; Q-&gt;rear=q; &#125;&#125; 由于队的存储空间大小是动态变化的，因此我们不需要判断队列是否已满。 队列的出队操作函数123456789101112131415int outQueue(DQueue Q,int x)&#123; if(Q-&gt;front==NULL || Q-&gt;rear==NULL) //判断队列是否为空 return -1; DNode q; //出队结点是front指向的结点,用一个结点q存储和释放出队结点 q=Q-&gt;front; //判断是否仅有一个结点 if(Q-&gt;front==Q-&gt;rear) Q-&gt;front=Q-&gt;rear=NULL;//仅有一节点则该元素出队后队列即空 else Q-&gt;front=Q-&gt;front-&gt;next;//将front指针指向下一个节点 x=q-&gt;data; free(q); //释放节点内存空间 return x;&#125; 队列的取队尾元素函数12345int getFront(DQueue Q)&#123; if(Q-&gt;front==NULL || Q-&gt;rear==NULL) //判断队列是否为空 return -1; return Q-&gt;front-&gt;data;&#125; 队列的应用LeetCode 21 合并两个有序链表思路定义一个新链表。比较两个原链表中元素的大小，并把它放到新链表中。然后再把放入了新元素的链表的指针向后移一个节点，没有放入新元素的链表的指针不动。如果一个链表指针已经指向队尾，那么就把另外一个链表之后的所有节点原封不动全部放入新链表中。 代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123; struct ListNode output; output.next = NULL; struct ListNode * ear = &amp;output; struct ListNode * node = NULL; while(l1 &amp;&amp; l2)&#123; rear-&gt;next = l1-&gt;val &lt; l2-&gt;val ? l1 : l2; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1 = l1-&gt;next; &#125; else&#123; l2 = l2-&gt;next; &#125; rear = rear-&gt;next; &#125; if(l1)&#123; rear-&gt;next = l1; &#125; if(l2)&#123; rear-&gt;next = l2; &#125; return output.next;&#125; LeetCode 2 两数相加思路懒得写了全部写在代码的注释当中…… 代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */int value = 0;//使用全局变量，来实现进位struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2)&#123;//使用递归将链表各个对应的元素相加 if(l1==NULL&amp;&amp;l2==NULL&amp;&amp;value==0)&#123;//判断输入的链表节点是否已经超过的链表的末尾，是否还有没存入最终输出链表的元素 return NULL; &#125; if(l1!=NULL)&#123; value+=l1-&gt;val;//如果当前链表节点存在，则把它的值取出来加到value上 l1=l1-&gt;next;//使得指针指向下一个节点 &#125; else&#123; value+=0; &#125;; if(l2!=NULL)&#123; value+=l2-&gt;val; l2=l2-&gt;next; &#125; else&#123; value+=0; &#125; struct ListNode *outList=(struct ListNode *)malloc(sizeof(struct ListNode));//开辟数组空间储存当前的链表节点 outList-&gt;val=value%10;//使用取模计算符保证val的值是value的个位数部分 value=value/10;//使用整除来保存value中需要进位的十位数的值 outList-&gt;next=addTwoNumbers(l1,l2); return outList;&#125; 还有两道困难题……就先咕为敬了，告辞有空再补]]></content>
      <tags>
        <tag>C</tag>
        <tag>Learning</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux初体验]]></title>
    <url>%2F2019%2F11%2F02%2FLinux%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[写在前面本来想装物理机Linux，做个双系统，但是奈何本机硬件不算主流（Ryzen 7 3700u with Radeon Vega Mobile Gfx）,担心在物理机上安Arch会出现驱动兼容性问题，遂作罢，改用VMware安装虚拟机，还可以顺带做网安组的Task，美滋滋。 安装准备VMware的安装下载地址：https://www.nocmd.com/740.html安装无脑下一步即可 Arch Linux镜像下载地址：http://mirrors.zju.edu.cn/archlinux/iso/2019.10.01/ （浙大源）下载链接地址中的archlinux-2019.10.01-x86_64.iso若此地址下载缓慢，也可以进入官方的下载源集合：https://www.archlinux.org/download/ 开始安装VMware配置打开VMware，首先点击文件选项 -&gt; 新建虚拟机 -&gt; 典型 -&gt; 稍后安装操作系统 -&gt; 选择Linux选项 -&gt; 版本选择‘Linux4.x’，内存按需分配就可以，硬盘分配40G左右，根据自己需求来定，毕竟Arch一开始还算一个比较干净简洁轻量的Linux release。网络类型选择NAT，其他默认即可。CD/DVD选项记得选择ArchLinux镜像。 Arch Linux安装准备启动安装archlinux不论你使用的是EFI或BIOS引导，均选择Boot Arch Linux(x86_64)这一选项启动成功后就会进入命令行模式，此时如果你不清楚你用的是EFI引导还是BIOS引导，可以在此处列出efivars目录以验证启动模式来判断主板是以何种方式引导系统的（这对之后对硬盘的分区 十分有用）： 1ls /sys/firmware/efi/efivars 若该目录不存在，系统就可能以BIOS模式启动。 确认网络连接情况如果你使用的是有线网络连接方式，那么Arch Linux在启动后，守护进程dhcpcd已被默认启用以探测有线设备，因此你只需验证网络是否正常即可如果你使用的是无线网络连接方式，Arch Linux的安装必须使用网络才能完成，使用下面命令以验证网络是否正常： 1ping -c 4 www.baidu.com 如果网络不正常，可能是由于dhcp服务没有开启，可以使用以下命令来开启此服务： 1systemctl enable dhcpcd.service 更新系统时间首先还是验证一下系统的时间是否正常： 1timedatectl status 如果时间和当前时间对不上的话，使用下面命令来更新系统时间： 1timedatectl set-ntp true 建立硬盘分区硬盘如果被系统识别到，就会被分配为一个块设备，如/dev/sda；因此先查看一下硬盘的状态，以便于后续分区操作： 1lsblk 屏幕显示如下：这里sda即是我分配给虚拟机的8GB硬盘，因为此硬盘下还没有分区，所以sda节点下无任何显示；loop0和sr0可以忽略。如果硬盘已经有分区，sda节点下应当会显示如下图：接下来我们要对这8GB的硬盘进行分区，能够创建分区的命令很多，如fdisk，parted，cfdisk等，这里使用GUI的cfdisk命令（在真机上分区时，请认真检查你的硬盘是否选择正确，如果你有多个硬盘，可能你要用来安装Linux的硬盘并不是如下所写的/dev/sda，而是/dev/sdb也说不定。 1cfdisk /dev/sda 对于一个硬盘，以下三个分区是必须要有的：··· 一个根分区（挂载在根目录） /··· 如果 UEFI 模式被启用，你还需要一个 EFI 系统分区，或者是通过BIOS启动，那么你需要建立的是BIOS boot分区··· Swap 可以在一个独立的分区上设置，也可以直接建立交换文件其中，Swap分区的大小应与你物理机/虚拟机的内存大小相同，EFI分区通常为300M，BIOS boot分区通常为1G 具体cfdisk的使用命令，可以参考这篇文章：https://jingyan.baidu.com/article/ce09321bb922da2bff858fdd.html 分好区后确认写入分区到硬盘，然后退出分区工具，再次使用lsblk查看一下，显示如下图：那么你就成功分好区了 格式化分区分区完成后，需要对分区做格式化处理，如果你使用了EFI分区，因为EFI分区需要FAT32文件格式，所以需要将其格式化为FAT32格式；EFI引导分区推荐大小为512M。在这里我使用的是BIOS引导，但为了方便起见，我也将它格式化成FAT32文件格式。根分区格式化为ext4格式；设置并开启Swap分区： 12345mkfs.fat -F32 /dev/sda2mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4mkswap /dev/sda1 -L Swapswapon /dev/sda1 挂载分区EFI模式引导格式化完成后，需要将分区挂载到 /mnt ，先挂载根分区（这里是/dev/sda2）；再挂载EFI分区（这里是/dev/sda1），挂载EFI分区时，需要在/mnt上先创建 boot/EFI 目录，然后将EFI分区挂载到/mnt/boot/EFI上；Sawp分区不需要挂载： 123mount /dev/sda3 /mntmkdir -p /mnt/boot/EFImount /dev/sda2 /mnt/boot/EFI BIOS模式引导12345mount /dev/sda4 /mnt 注：sda4挂载为根mkdir /mnt/boot 注：在 / 分区中创建/boot文件夹mkdir /mnt/home 注：在 / 分区中创建home文件夹mount /dev/sda2 /mnt/boot 注：将sda2分区挂载到/mnt/boot文件夹内mount /dev/sda3 /mnt/home 注：将sda3分区挂载到/mnt/home文件夹内 安装基本系统选择软件镜像源在安装基本系统之前，需要修改一下软件镜像源，不然安装基本系统时会安装不上。镜像源列表在 /etc/pacman.d/mirrorlist 文件中。 我们选择软件镜像源时，最好选择国内的镜像源，因为国内网络环境的关系，选择其他国家或地区的镜像源，安装时可能很慢或失败也不一定。 下面这段代码首先添加了阿里巴巴镜像源到一个新文件（此处为mrlist），然后从mirrolist文件中选出所有国内镜像源追加到mrlist中，然后将mirrorlist文件的内容追加在mrlist的最后面，最后将mrlist重命名为mirrorlsit： 1234echo &apos;## China\nServer = http://mirrors.aliyun.com/archlinux/$repo/os/$arch&apos; &gt; mrlistgrep -A 1 &apos;China&apos; /etc/pacman.d/mirrorlist|grep -v &apos;\-\-&apos; &gt;&gt; mrlistcat /etc/pacman.d/mirrorlist &gt;&gt; mrlistmv mrlist /etc/pacman.d/mirrorlist 执行完以上命令后，可以使用以下命令来查看mirrorlist文件是否修改成功： 1nano /etc/pacman.d/mirrorlist 按下Ctrl+X退出查看若修改成功，会看到mirrorlist文件中的开头的内容全是国内的镜像源 开始安装系统修改完软件镜像源后，然后就可以开始安装系统了： 1pacstrap -i /mnt base base-devel vim linux linux-firmware 注意，在安装环节就需要安装linux 和 linux-firmware两个包，不然会导致内核没有安装导致grub引导失败进不去系统使用-i选项会在实际安装前进行确认；安装 base-devel组，可以让我们通过 AUR (简体中文) 或者 ABS (简体中文) 编译安装软件包，如果不需要通过AUR或ABS安装软件包，则只需要安装base组就可以了 。 配置系统FstabLinux的文件结构是单个的树状结构。最顶部的为根目录，即/。在根目录下，分为多个子目录，包括/bin、/boot、/dev、/etc、/home、/lib、/media、/mnt、/opt、/proc、/root、/sbin、/tmp、/usr和/var等。磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作，而fstab正是负责这一配置。 因此，在基本系统安装完成后，用以下命令生成 fstab 文件 (用 -U 或 -L 选项设置UUID 或卷标)： 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 然后使用以下命令检查一下生成的fstab文件是否正确： 1nano /mnt/etc/fstab 如果生成的fstab文件正确，会看到之前分的4个分区的信息。 Chrootchroot命令用来在指定的根目录下运行指令切换到新安装的系统： 1arch-chroot /mnt chroot之后，当前目录就变成为 / 。此步会自动进行创建初始的ramdisk环境，但是如果以后更改了内核配置了的话，最好使用一下命令再重新生成ramdisk环境： 1mkinitcpio -p linux 配置时区将系统时区设为东八区： 1ln -sf /usr/share/zoneinfo/Asia/Chongqing /etc/localtime 设置时间标准为UTC，并调整时间漂移： 1hwclock --systohc --utc 配置Localelocale文件对系统的使用地区和语言等进行配置。在/etc/locale.gen文件中进行配置。locale.gen是一个仅包含注释文档的文本文件。指定需要的本地化类型，只需移除对应行前面的注释符号（＃）即可，使用下面命令打开locale.gen文件： 1nano /etc/locale.gen 然后找到下面2项，去掉每项前面的#即可： 12en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8 使用locale-gen命令生成Locale信息，并列出所有启用的Locale： 12locale-genlocale -a 最后创建locale.conf文件，并提交所要使用的本地化选项，然后使用locale命令显示当前正在使用的Locale和相关的环境变量： 12echo LANG=en_US.UTF-8 &gt; /etc/locale.conflocale /etc/locale.conf用来配置整个系统所使用的Loacle，而这也可以由用户通过用户自己的 /.config/locale.conf （表示当前用户的Home目录）来覆盖整个系统的Locale配置。建立 /etc/skel/.config/locale.conf 文件，可以在新用户的建立（新用户的建立见下文）且同时创建用户主目录（useradd -m）时，自动应用其中的Locale（会将此文件复制到新建用户的 ~/.config/locale.conf 中）。不推荐此时设置任何中文locale，因为这样做可能会导致tty显示乱码。 设置主机名要设置主机名，创建 /etc/hostname 文件并将主机名写入该文件即可。我的主机名为Zam-laptop： 1echo Zam-laptop &gt; /etc/hostname 然后配置主机名对应的IP到 /etc/hosts 中： 1nano /etc/hosts 将其中的主机名改为你自己的主机名（我这里是Zam-laptop）： 123127.0.0.1 localhost.localdomain localhost::1 localhost.localdomain localhost127.0.1.1 Zam-laptop.localdomain Zam-laptop 网络配置若使用有线网络的话，由于在Base包里已经不包括联网所需的程序，所以需要下载dhcp客户端: 1pacman -S dhcpcd 若使用无线网络的话，则安装以下几个软件包（因为我使用的是虚拟机，并未验证过）： 1pacman -S iw wpa_supplicant dialog 设置Root用户密码设置root密码： 1passwd 然后输入两次密码即可。 创建新用户因为使用root用户登陆后，root用户拥有系统的所有操作权限，这样对系统的操作非常不安全（如一不小心删库，你就要开始跑路），所以需要新建一个普通用户，让其对系统的操作受到一定限制，使用下面命令新建用户zam： 1useradd -m -G wheel -s /bin/bash zam 命令解释：-m：创建用户主目录（/home/[用户名]）-G：用户要加入的附加组列表；此处将用户加到wheel组中，之后可以给这个组执行sudo命令的权限-s：指定了用户默认登录shell的路径，此处设置为bash的路径更多创建新用户的使用请查看官方Arch Linux Wiki：https://wiki.archlinux.org/index.php/Users_and_groups_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 然后修改新创建用户的用户密码，和修改Root用户密码所使用的命令一样（只是需要指定要修改密码的用户名）： 1passwd zam 然后输入两次密码即可。 以后大部分时间我们都将使用此普通用户来工作，但由于此用户的操作权限有限，有时会对很多操作带来不便，因此需要给该用户在某些情况下提权，这就需要允许该用户所在的wheel组有执行sudo命令的权限，此时需要修改 /etc/sudoers文件 ，但请不要直接修改此文件，而是用下面的命令修改： 1visudo 使用上面命令打开sudoers文件后，删除wheel组前面的注释（#）即可： 12## Uncomment to allow members of group wheel to execute any command%wheel ALL=(ALL) ALL 若执行visudo时，提示找不到vim，则请先安装vim后在执行上面的操作，执行下面指令安装vim： 1pacman -S vim 安装grubgrub是一个启动引导器，同时支持EFI和BIOS方式的启动。若使用的UEFI方式引导系统，则还需要安装efibootmgr，如果是双系统的话，还需要安装os-prober，且如果使用Intel CPU的话，则需要安装 intel-ucode 并启用 因特尔微码更新 嘤特尔微码更新并不是一定需要开启 微码 微码（microcode）就是由 Intel/AMD 提供的 CPU 固件。Linux 的内核可以在引导时更新 CPU 固件，而无需 BIOS 更新。处理器的微码保存在内存中，在每次启动系统时，内核可以更新这个微码。 这些来自 Intel/AMD 的微码的更新可以去修复 bug 或者使用补丁来防范 bug。例如前段时间爆出的幽灵(Spectre)与熔断(Meltdown)漏洞，就可以通过更新微码来解决 因此，最好还是启用因特尔微码更新，以保证自己的数据安全 因为我使用的是虚拟机和BIOS引导方式，因此只需要安装grub： 1pacman -S grub 然后，还需要将其安装到BIOS boot分区当中： 1grub-install --recheck /dev/sda 注意：此处的 /dev/sda 后没有数字。最后还需要生成一个grub的配置文件： 1grub-mkconfig -o /boot/grub/grub.cfg 重启执行以下命令： 12exit #退出chroot环境，切换到光盘系统reboot #重启系统 然后你就可以进入到grub的引导界面，选择Arch Linux，enjoy it！ 进阶安装在重启之后，我们就已经成功地安装了ArchLinux,但是这时系统处于一个非常精简的状态,为了日常使用,我们必须安装一些需要的组件,来完善我们的系统功能。 预先准备：启动DHCP服务启动dhcp服务： 1systemctl enable dhcpcd.service 以确保后续的下载软件包操作能够正常进行 安装图形界面安装XorgXorg是Linux下的一个著名的开源图形服务，我们的桌面环境需要Xorg的支持。执行以下命令安装Xorg及相关组件： 1sudo pacman -S xorg 安装Deepin Desktop Environment（DDE）作为国产的桌面操作环境，当然要滋磁一波执行以下命令： 1sudo pacman -S deepin deepin-extra lightdm lightdm-deepin-greeter 安装其余实用软件deepin还提供了解压、下载工具等实用工具的下载执行以下命令： 12sudo pacman -S file-roller evince gedit thunderbird gpicviewsudo pacman -S unrar unzip p7zip 安装桌面管理器sddm经过某李姓学长提醒，了解了sddm和lightdm都是图形化的桌面管理器，因此若上面安装deepin时已经安装了lightdm，接下来就不需要安装桌面管理器sddm了 安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，sddm就是这样的一款管理器。执行以下命令来安装sddm： 1sudo pacman -S sddm 设置开机启动sddm服务使用systemctl命令：sudo systemctl enable sddm来启用sddm开机自启设置lightdm开机自启同理 配置网络到现在我们已经安装好了桌面环境，但是还有一件事情需要我们提前设置一下。由于我们之前使用的一直都是netctl这个自带的网络服务，而桌面环境使用的是NetworkManager这个网络服务，所以我们需要禁用netctl并启用NetworkManager： 12sudo systemctl disable netctlsudo systemctl enable NetworkManager 同时你需要安装工具栏工具来显示网络设置图标： 1sudo pacman -S network-manager-applet 安装完成重启之后就可以尽情地enjoy了 下载编译安装最新最鬼酷的Linux内核注：为了完成之后的Patch任务，我这里就下载5.3版本的内核。下载最新版的内核同理。 下载内核首先，我们当然要先去把内核下载到虚拟机中 由于某些特殊原因，国内访问国外的Kernel.org速度偏慢那么就需要从国内的开源镜像站去下载内核地址：https://mirrors.tuna.tsinghua.edu.cn/kernel/ 然后根据自己的喜好找到自己需要的内核，使用wget命令下载，并将其解压 123wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.3.tar.xzxz -d linux-5.3.tar.xztar -xvf linux-5.3.tar 编译内核进入解压好的源码的根目录下，如果需要自定义选项，就执行以下命令： 1make menuconfig 会进入一个菜单，让你定制你自己的内核。当然，你也可以使用缺省配置，执行以下命令: 1zcat /proc/config.gz &gt; .config #将当前内核的配置文件复制到此处 并且不要忘记在 General Setup —&gt; 选项中或者复制来的config文件的”CONFIG_LOCALVERSION”一行的值来修改内核版本，这样可以避免编译的内核覆盖当前内核文件。这样内核已经配置好了，下面就可以开始编译了编译命令： 1make -j 线程数 安装内核模块1sudo make modules_install ##把所有编译好的模块安装到正确的主目录/lib/modules下 该命令将编译好的模块拷贝至 /lib/modules/-，例如 /lib/modules/3.18.28-ARCH。这样，这些模块和那些被你电脑上其他内核使用的模块就独立开来。 拷贝内核到 /boot 目录内核编译完成后会生成内核的 bzImage (big zImage) 文件，根据系统架构，将此文件复制到 /boot 目录，以 5.3 内核为例： 32-bit (i686) kernel: 1sudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-linux53 64-bit (x86_64) kernel: 1sudo cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-linux53 制作初始化内存盘自动生成复制和修改 mkinitcpio preset，就能用官方内核一样的方式生成自定义内核的 initramfs 镜像。下面例子中将已有的 preset 复制到 linux53 要使用的文件: 1sudo cp /etc/mkinitcpio.d/linux.preset /etc/mkinitcpio.d/linux53.preset 针对定制内核编辑和修改此文件， 1sudo vim /etc/mkinitcpio.d/linux53.preset ALL_kver= 应该和定制内核匹配： 1234567/etc/mkinitcpio.d/linux53.preset...ALL_kver=&quot;/boot/vmlinuz-linux53&quot;...default_image=&quot;/boot/initramfs-linux53.img&quot;...fallback_image=&quot;/boot/initramfs-linux53-fallback.img&quot; 用官方内核一样的方式生成 initramfs 镜像： 1sudo mkinitcpio -p linux53 拷贝System.map将 System.map 复制到 /boot, 然后创建 /boot/System.map 软链接到 /boot/System.map-YourKernelName: 12sudo cp System.map /boot/System.map-YourKernelNamesudo ln -sf /boot/System.map-YourKernelName /boot/System.map 更新grub配置信息使用命令 1grub-mkconfig -o /boot/grub/grub.cfg 来把我们刚刚配置好的内核添加到grub的启动配置中 然后reboot就可以享受最新（更老）的kernel了！ Patch自己的内核说实话，一开始看到要patch自己的内核，能够给出现象证明你的patch有效，我的心就拔凉拔凉的Kernel里那么多东西，我咋看的过来哪些能改哪些不能改，改了会有什么效果啊我透……后来转念一想，Patch最显著的现象不就是版本号升级了吗？！于是就有了之前反向升级最新内核的操作 下载Patch地址：https://mirrors.tuna.tsinghua.edu.cn/kernel/依旧是打开那个熟悉的地址，然后找到自己对应的patch包，用wget命令下载即可。注意：如果你想跨版本升级，例如说现在是5.3，想要升级到5.3.8的内核，可以一步到位从5.3这个大版本用patch-5.3.8升级至5.3.8 解压Patch使用命令： 1xz -d patch-5.3.1.xz 即可 安装Patch将解压出的Patch文件放在你想要打Patch的源代码文件夹的Kernel目录下 重要 为确保内核树绝对干净，执行以下命令 1make clean &amp;&amp; make mrproper 注意：由于patch文件中的文件路径包含了它所基于的内核源文件目录的名字(或者像是”a/“和”b/“之类的其它名字)。这很可能和你本地机器上的内核源代码目录的名字不匹配。你应该切换到你的内核源代码目录，并且在打补丁的时候去掉patch中文件名字路径的第一个分量(patch命令的-p1参数可以完成这个任务)。因此我们在Kernel目录下直接执行以下命令： 1patch -p1 &lt; ./patch-5.3.8.patch 其余的patch文件依样画瓢即可 编译Patch后的内核以及之后的步骤这个就和之前的差不多，就不再叙说了~ 制作自己的Patch文件并打Patch。经过某李姓学长的提醒，我明白了这个任务其实是要我们自己动手修改kernel内核。那么最简单的修改方法就是添加一个系统调用。 修改源程序，增加系统调用实现假设你现在已经下好了kernel源文件并解压。在解压出的源代码文件夹内执行以下命令： 1vim ./kernel/sys.c 在sys.c的末尾加入以下函数 123asmlinkage void sys_helloworld(void)&#123; printk(“hello world”);&#125; 修改头文件，增加系统调用声明注意：我在修改之后的系统调用后才发现520已经被占，因此之后图里所有的520都被改成了436，也推荐大家以后新增调用时先去看看syscall_64.tbl文件的内容。使用命令 1vim ./include/uapi/asm-generic/unistd.h 来添加系统调用的声明在文件的最末尾处添加如下代码：再使用命令 1vim ./include/linux/syscalls.h 在文件的最末尾处添加如下代码： 注册系统调用进入/arch/x86/entry/syscalls目录可以看到以下内容：32位系统就添加到syscall_32.tbl，64位就修改syscall_64.tbl我这里是64位，因此我应该修改syscall_64.tbl。按着顺序往下添加即可，中间使用Tab键分隔。如图所示： 生成Patch文件在这里，我就假设你已经修改好了文件。比如基于kernel内核 做了修改，修改前的内容放在文件夹kernel下，修改后的内容放在文件夹kernel_new下，并且两个目录在同级的文件夹里，那么制作patch文件的命令为 1diff -Naur kernel/ kernel_new/ &gt; new.patch 然后接下来的步骤和上面的 安装Patch 部分相同，不再赘述。 最终结果 几个踩坑的点一开始只安装了Base包网上的远古教程指导我说安装了Base包就行了，然而Arch Linux似乎把Linux内核从Base包当中分离了出来，所以一开始只安装Base包导致grub找不到内核一直引导失败。这个惨痛的经历告诉我们，以后不管装什么，都要看官方wiki，避免踩坑。 在编译内核时config文件没有配置好一开始直接用make defconfig命令，编译了一个几乎啥都不带的内核。之后才明白如果想沿用当前系统设置应该用zcat /proc/config.gz &gt; .config命令。还好有 善意的提醒 不然又得从头再来。 在Patch时报错，提示patch rejected这是因为我用了tuna的patch包，这个包是用来一步到位从5.3升级到5.3.8的，而要想从5.3.7升级到5.3.8，则需要从 https://www.kernel.org 上下载Inc.patch包。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>syscall</tag>
        <tag>Patch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VMware搭建小型局域网]]></title>
    <url>%2F2019%2F10%2F26%2F%E4%BD%BF%E7%94%A8VMware%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%9E%8B%E5%B1%80%E5%9F%9F%E7%BD%91%2F</url>
    <content type="text"><![CDATA[前期准备安装VMware下载地址：https://www.nocmd.com/740.html安装无脑下一步即可 安装Ubuntu镜像下载地址：https://cn.ubuntu.com/download最新版的VMware支持Ubuntu的简易安装，所以在配置时直接填好主机名用户名密码就可以愉快的食用Ubuntu了 配置局域网在虚拟网络编辑器中配置网关以及网段在VMware主页面 编辑–》虚拟网络编辑器单击箭头所指按钮，给编辑器提升权限以更改设置 我们使用NAT模式，所以选择VMnet8。（记住这个名称，稍后还会用到）不勾选【使用本地DHCP】服务这个复选框，因为我们要求固定IP，DHCP是动态分配IP的。首先，我们将子网IP设置成我们需要的IP地址所在的网段，即192.168.188.0，如图所示： 点击NAT设置。我们将网关IP设置成我们需要的IP地址192.168.188.2，如图所示： 然后再选择Host-only模式的网卡VMnet1同理，不勾选【使用本地DHCP】服务这个复选框。首先，我们将子网IP设置成我们需要的IP地址所在的网段，即192.168.188.0，如图所示： 在控制面板中配置虚拟网卡IP在VMware中更改了虚拟网络之后，我们还需要去宿主机的网络控制面板中更改网络适配器，才能让我们的虚拟主机能够正常的上网在控制面版中找到VMware Network Adapter VMnet8，也就是我们之前记住的使用NAT模式的那张网卡双击图标后，在弹出的窗口中单击属性–&gt;双击Internet协议版本4将弹出的窗口设置成如图所示的亚子： 到此，配置局域网的工作暂告一段落打开三台虚拟机，进行最后的指向操作对于充当路由器和DNS服务器的虚拟机VM1首先打开VM1的IP转发功能： 1nano /etc/sysctl.conf 把net.ipv4.ip_forward = 0改成1，或者是将注释符删去，如图所示： ![更改VM1 IP转发.png](https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/更改VM1 IP转发.png) 使用sysctl -p命令使改动生效。 然后再将用于与VM2和VM3通信的网卡手动分配下IP注意，此时一定要分清哪张网卡是工作在NAT模式下，用于与宿主机通信的；哪张是工作在Host-Only模式下，用于与两个虚拟机通信的。所以在开始更改网卡配置之前，需要先执行ifconfig确定网卡的具体信息 从ubuntu从17.10开始，已经不再在/etc/network/interfaces里配置IP，即使配置了也不会生效，而是改成netplan方式 ，配置写在/etc/netplan/文件夹里或者类似名称的yaml文件里。因此，我们应先查看/etc/netplan文件夹下的文件，来判断我们需要修改的是什么文件 12cd /etc/netplanls 从而确定下一步的命令为：sudo nano 01-network-manager-all.yaml 经过我的甄别，确定网卡ens38是那张工作在Host-Only模式下的网卡、ens33是那张工作在NAT模式下的网卡，于是乎按照任务要求，如图所示编辑两张网卡的配置： 之后运行命令netplan apply来应用这一设置 到这里，对VM1的操作就告一段落 对于VM2和VM3照葫芦画瓢，首先执行ifconfig确定网卡的具体信息，再更改netplan的配置信息。具体操作过程与VM1大差不差，就直接放按着任务要求配置好的netplan了。 然后就可以实现VM1,VM2,VM3三台机器的互ping 对VM2与VM3进行NAT转换但是，经过上述的操作，VM2与VM3却不能ping通VM1的网关和公网。有句话说得好，不能连公网的主机和咸鱼没啥区别。因此，我们需要用iptables实现NAT转换，使得B和C能够访问(ping)A的网关和公网。 具体的NAT操作过程示例，可以参照这篇blog中SNAT部分，再根据具体的环境配置iptables的参数：https://www.zsythink.net/archives/1764 在此次任务中，命令为： 1sudo iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -j SNAT --to-source 192.168.188.128 执行之后就可以在VM2与VM3两台“内网”机器中愉快的连上公网了~ 遇到的问题 1.netplan apply时遇到格式错误 错误原因：YAML文件对格式的要求非常严格。在冒号后少打一个空格都会导致文件读取错误。 解决方法：重新检查一遍YAML文件格式是否正确，有没有少打空格。并在之后多多注意格式问题 2.在执行命令中多次出现Permission Denied 错误原因：因为这次任务中涉及到对网络配置等系统关键文件进行修改的操作，所以需要su权限才能进行命令的执行。 解决方法：在之后的命令行输入时，涉及到对系统文件、系统环境的修改时要记得加上sudo。 不能因为sudo麻烦而直接使用root用户登录。不然没准哪天你就会不小心删库跑路 Task Over然而还差12h工时……绝了]]></content>
      <tags>
        <tag>Dian CyberSecurity Team</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST-Task2]]></title>
    <url>%2F2019%2F10%2F16%2FAST-Task2%2F</url>
    <content type="text"><![CDATA[注意，本文编译环境为Visual Studio 2019 on Windows 10 1903 X64 几个练手题1.编程实现：用户给定一个整数，将该整数逆置之后输出。（如：输入123，输出321）。限制条件a.给定整数，不要用字符串来完成。b.尽可能使时间复杂度小。c.要求能够完成214748364792这个数字的逆置。 程序源码1234567891011121314#include&lt;stdio.h&gt;int main() &#123; long long int input; scanf_s("%lld", &amp;input); long long int output = 0, digit; while (input &gt; 0) &#123; digit = input % 10;//取当前最末位数 output = output * 10 + digit;//将当前的最末位数加到待输出结果的最后一位 input /= 10; &#125; printf("%lld", output); return 0;&#125; ###运行结果 2.编程实现：给定一串任意字符串。要求，将其中的所有整数提取出来并存入整数数组给定样例1023fase415#145# 程序源码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main(void)&#123; char str[1000]; int a[100]; int p, q; int i = 0, r = 0,count = 0;//i用于控制输出，r用于控制字符串内查找,count用于计算字符串内数字个数 gets(str); r = 0; while (1) &#123; while (str[r] &amp;&amp; (str[r]&lt;'0' || str[r]&gt;'9')) r++; //跳过字符串中非数字部分 if (str[r]) &#123; p = r; //p指向数字子串开头 q = r + 1; //q寻找数字串结尾 a[i] = str[r] - '0';//将字符串中的0变为数字0 while (str[q] &gt;= '0' &amp;&amp; str[q] &lt;= '9') &#123; a[i] = 10 * a[i] + (str[q] - '0');//计算数字 q++; &#125; count++; r = q; //设定新起点 i++; &#125; else break; &#125; for (i = 0; i &lt; count; i++) printf("%d ", a[i]); printf("\n"); return 0;&#125; 运行结果 3.编程实现：给定一串任意字符串。要求，将其中的所有数字提取出来并存入double数组。给定样例10.23fase4.15#14.5# 程序源码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; char str[1000], num[1000]; double a[100]; int p, q; int i = 0, r = 0,count = 0;//i用于控制循环，r用于控制字符串内查找,count用于计算字符串内数字个数 gets(str); r = 0; while (1) &#123; while (str[r] &amp;&amp; (str[r]&lt;'0' || str[r]&gt;'9')) &#123;//查找数字字串开头部分 r++; &#125; if (str[r]) &#123; p = r; //p指向数字子串开头 q = r + 1; //q寻找数字串结尾 while ((str[q] &gt;= '0' &amp;&amp; str[q] &lt;= '9')||str[q]=='.')&#123; q++; &#125; for (i = 0; i &lt; q-p; i++) &#123;//将数字字串转存到新字符串中，用于后续转化输出 num[i] = str[p + i]; &#125; num[i] = '\0'; a[count] = atof(num); count++; r = q; //设定新起点 &#125; else break; &#125; for (i = 0; i &lt; count; i++) printf("%lf ", a[i]); printf("\n"); return 0;&#125; 运行结果 几个烧脑题多级指针：观察下列代码，思考并解释程序运行结果1程序代码及解释12345678910111213#include &lt;stdio.h&gt;int main()&#123; char * c[] = &#123; "ENTER", "NEW", "POINT", "FIRST" &#125;;//定义了四个指针c[0]-c[3]分别指向四个字符串 char** cp[] = &#123; c + 3, c + 2, c + 1, c &#125;;//定义了一个二级指针数组，其中的cp[0]-cp[3]分别依次对应c[3]-c[0] char*** cpp = cp;//定义了一个三级指针，指向二级指针数组的第一个元素cp[0]，此时cpp就相当于c[3] printf("%s\n", ** ++cpp);//** cpp经过间接引用运算后相当于是指针cp，指针cp自增后指向的是指针数组cp[]中的第二个元素,也即是c[2] printf("%s\n", * --* ++cpp + 3);//首先对指针cpp作了自增操作，使得cpp指向cp[2],此时cpp中的地址为c+1，再通过自减符使得指针 * cpp即cp[2] (注意不是cpp)的地址变为c，这时候*--* ++cpp相当于指向了一个字符数组&#123;'E','N','T','E','R'&#125;的首地址。+3的操作等价于在这个字符数组的首地址的基础上再右移三个地址，指向了第二个E，然后通过printf将第二个E和之后的所有剩余字符全部打印。 printf("%s\n", * cpp[-2] + 3);//经过了上一条语句后，cpp指向cp[2],那么cpp[-2]指向cp[0]（注意，此时cpp内存储的地址并没有改变）,即c[3]此时的*cpp[-2]就相当于指向了一个字符数组&#123;'F','I','R','S','T'&#125;的首地址。+3的操作等价于在这个字符数组的首地址的基础上再右移三个地址，指向了S，然后通过printf将S和之后的所有剩余字符全部打印。 printf("%s\n", * cpp[-1][-1] + 1);//同上理，此时cpp指向cp[2],cpp[-1]就会指向cp[1]，即c[2],那么cpp[-1][-1]就相当于指向c[1],即一个字符数组&#123;'N','E','W'&#125;的首地址。+1的操作等价于在这个字符数组的首地址的基础上再右移1个地址，指向了E，然后通过printf将E和之后的所有剩余字符全部打印。 system("pause"); return 0;&#125; 上机验证 2程序代码1234567891011121314151617#include &lt;stdio.h&gt;struct Test&#123; int Num; char* pcName; short sDate; char cha[2]; short sBa[4];&#125;*p;int main()&#123; p = 0x100000; printf("%p\n", p + 0x1);//输出00100014 printf("%p\n", (unsigned long)p + 0x1);//输出00100001 printf("%p\n", (unsigned int*)p + 0x1);//输出00100004 return 0;&#125; 解释首先要明确，指针与整数的加减法公式为 p = p +/- sizeof（type * p） 第一行输出00100014的原因是结构体Test的存储空间大小为sizeof(int) + sizeof(char* ) + sizeof(short) + sizeof(char)* 2 + sizeof(short)* 4 = 20,并且指针的地址是以十六进制数存放的，因此p + 0x1就相当于指针p向后移动了sizeof(Test)的内存大小，因此输出的内存地址比1000000大20，为00100014。 第二行输出001000001的原因是(unsigned long)语句将* p转换成了整数类型，因此此时做的只是普通的整数与整数之间的加减法。 第三行输出00100004的原因是 (unsigned int)语句将Test 类型的p指针转换成了int * 类型，根据公式此时sizeof(int*) = 4,因此输出00100004。 上机验证 3程序代码#include &lt;stdio.h&gt; 12345678int main()&#123; int a[4] = &#123; 1, 2, 3, 4 &#125;; int * ptr1 = (int * )(&amp;a + 1); int * ptr2 = (int * )((int)a + 1); printf("%x\n%x\n", ptr1[-1], * ptr2);\\输出4 2000000 return 0;&#125; 解释首先，&amp;a指的是取数组a的地址，而&amp;a + 1指的是加上一个int a[4]的长度，即sizeof(int) * 4=16字节，所以ptr1指向数组a后面的内存单元，如果用下标表示就是a[5] 由指针与整数的加减法公式p = p +/- sizeof（type * p，ptr1[-1]表示ptr1指向的地址再减去sizeof(int * )，即指向a[4]，所以第一个%x输出对应的是0x4. (int)a+1的值就是元素a[0]的第二个字节的地址，然后把这个地址强制转化为（int)类型赋给ptr2，也就是说ptr2的值应该为元素a[0]的第二个字节开始的连续4个Byte的内容。 不过要想理解为什么输出了2000000，就要首先明白数字在数组中是怎么被存储的： 每个元素具体存储方式，取决于CPU。 有两种：1、小端(Little Endian)：将低序字节存储在起始地址（低位编址）, 地址低位存储值的低位，地址高位存储值的高位 。目前大多数CPU是按照这种方式存储的，包括intel和移动端最常见的arm。比如4字节整型值为0x12345678的情况，那么在内存中会存储为：0x78 0x56 0x34 0x122、大端(Big Endian)：与小端相反， 将高序字节存储在起始地址（高位编址），地址低位存储值的高位,地址高位存储值的低位。之前的例子在大端情况下存储为：0x12 0x34 0x56 0x78 因此，a[0]在内存中被存储为0x01 0x00 0x00 0x00,a[1]在内存中被存储为0x02 0x00 0x00 0x00，此时ptr2所指向的内存区域的值就是0x00 0x00 0x00 0x02 但是，在printf进行输出时，内存中的值是自右而左地被读出的，因此输出的值应该是0x02000000 上机验证 其余部分就先咕为敬了，告辞有空再补好了我胡汉三又回来了 malloc函数的使用在C语言中，malloc是动态内存分配函数。 它的原型声明在stdlib.h头文件中： 1void *malloc(unsigned int num_bytes); num_bytes 是无符号整型，用于表示分配的字节数。这个函数的返回值：如果分配成功则返回指向被分配内存的指针void* (此存储区中的初始值不确定)，否则返回空指针NULL。void* 表示未确定类型的指针，void * 可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者…）这个函数的功能很简单：就是分配长度为num_bytes字节的内存块。注意：由于C语言中缺少内存回收机制，所以当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，例如说统一为4的倍数，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此在使用是我们应要进行类型转换。example: 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//malloc()函数被包含在stdlib.h里面int main(void)&#123;char*a=NULL; //声明一个指向a的char*类型的指针a=(char*)malloc(100*sizeof(char));//使用malloc分配内存的首地址，然后赋值给aif(!a)//如果malloc失败，可以得到一些log&#123;perror("malloc");return-1;&#125;sprintf(a,"%s","HelloWorld\n");//"HelloWorld\n"写入a指向的地址printf("%s\n",a);//输出上边写入a的字符串free(a);//释放掉使用的内存地址return 0;//例2有无内存泄露？&#125; 而且，作为一名合格的码农，我们应当对一些特殊情况进行特殊处理，如这里的malloc函数若调用失败，则直接让程序退出，而不是让其运行下去，否则可能会造成更大的bug，而且也不利于我们根据返回值进行debug。 结构体指针-&gt;的使用除了我们通过结构体变量名.成员名的方式引用结构体变量中的成员，我们还可以使用指针。要想学会-&gt;这种指针的使用，首先我们就要学会一般的结构体指针使用方式：(* 指针变量名).成员名这个指针变量定义成什么类型呢？只能定义成结构体类型，且指向什么结构体类型的结构体变量，就要定义成什么样的结构体类型。比如指向 struct STUDENT 类型的结构体变量，那么指针变量就一定要定义成 struct STUDENT* 类型。example: 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;# include &lt;string.h&gt;struct AGE&#123; int year; int month; int day;&#125;;struct STUDENT&#123; char name[20]; //姓名 int num; //学号 struct AGE birthday; //生日 float score; //分数&#125;;int main(void)&#123; struct STUDENT student1; /* 用struct STUDENT结构体类型定义结构体变量student1*/ struct STUDENT * p = NULL; /* 定义一个struct STUDENT结构体类型的指针变量p*/ p = &amp;student1; /* p指向结构体变量student1的首地址, 即第一个成员的地址*/ strcpy((* p).name, "小明"); //(* p).name等价于student1.name (* p).birthday.year = 1989; (* p).birthday.month = 3; (* p).birthday.day = 29; (* p).num = 1207041; (* p).score = 100; printf("name : %s\n", (* p).name); //(* p).name不能写成p,即使p指向的是student1.name的地址。 printf("birthday : %d-%d-%d\n", (* p).birthday.year, (* p).birthday.month, (* p).birthday.day); printf("num : %d\n", (* p).num); printf("score : %.1f\n", (* p).score); return 0;&#125; 输出结果： 1234name : 小明birthday : 1989-3-29num : 1207041score : 100.0 注意，* p 两边的括号不可省略，因为成员运算符“.”的优先级高于指针运算符“ * ”，所以如果 * p 两边的括号省略的话，那么 * p.num 就等价于 * (p.num) 了。从该程序也可以看出：因为指针变量 p 指向的是结构体变量 student1 第一个成员的地址，即字符数组 name 的首地址，所以 p 和 (* p).name 是等价的。但是，“等价”仅仅是说它们表示的是同一个内存单元的地址，但它们的类型是不同的。指针变量 p 是 struct STUDENT* 型的，而 (* p).name 是 char* 型的。所以在 strcpy 中不能将 (* p).name 改成 p。用 %s 进行输入或输出时，输入参数或输出参数也只能写成 (* p).name 而不能写成 p。同样，虽然 &amp;student1 和 student1.name 表示的是同一个内存单元的地址，但它们的类型是不同的。&amp;student1 是 struct STUDENT* 型的，而 student1.name 是 char* 型的，所以在对 p 进行初始化时，“p=&amp;student1；”不能写成“p=student1.name”。因为 p 是 struct STUDENT* 型的，所以不能将 char* 型的 student1.name 赋给 p。C语言是一门强数据类型的语言，就在这里体现的淋漓尽致。此外,为了使用的方便和直观，我们可以直接用指针变量名-&gt;成员名来代替。p-&gt;num 的含义是：指针变量 p 所指向的结构体变量中的 num 成员。p-&gt;num 最终代表的就是 num 这个成员中的内容。下面，我们可以用指针变量名-&gt;成员名的形式对我们刚刚的代码进行修改： 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;# include &lt;string.h&gt;struct AGE&#123; int year; int month; int day;&#125;;struct STUDENT&#123; char name[20]; //姓名 int num; //学号 struct AGE birthday; /* 用struct AGE结构体类型定义结构体变量birthday, 生日*/ float score; //分数&#125;;int main(void)&#123; struct STUDENT student1; /* 用struct STUDENT结构体类型定义结构体变量student1*/ struct STUDENT * p = NULL; /* 定义struct STUDENT结构体类型的指针变量p*/ p = &amp;student1; /* p指向结构体变量student1的首地址, 即第一项的地址*/ strcpy(p-&gt;name, "小明"); p-&gt;birthday.year = 1989; p-&gt;birthday.month = 3; p-&gt;birthday.day = 29; p-&gt;num = 1207041; p-&gt;score = 100; printf("name : %s\n", p-&gt;name); //p-&gt;name不能写成p printf("birthday : %d-%d-%d\n", p-&gt;birthday.year, p-&gt;birthday.month, p-&gt;birthday.day); printf("num : %d\n", p-&gt;num); printf("score : %.1f\n", p-&gt;score); return 0;&#125; 输出同上。 链表的基本概念及简单使用学了三个月，终于学到了第一种数据结构类型：链表。那么，链表它到底是个啥？链表，链表，首先它得是个线性表。根据《数据结构》书中介绍，一个线性表是n个数据元素的有限序列，它的长度可根据需要增长或缩短，还有一系列对线性表的操作。线性表可分为顺序存储结构和链式存储结构两种。那么今天所学习的链表，全称就叫链式存储结构线性表。线性链表可分为单链表，循环链表，双链表。 线性表特点是用一组任意的存储单元存储线性表的数据元素，同时还存储一个指向后继信息的信息，这两部分信息组成为结点。结点包含两部分数据域和指针域。指针域存储信息成为指针或链。链表中只包含一个指针域，故称为单链表。 下面通过c语言实现单链表的基本操作： 1234567891011#define MAXSIZE 20#define OK 1#define ERROR 0typedef int ElemType;typedef int Status;//上述是一些重命名和宏定义//单链表的存储结构typedef struct LNode&#123; ElemType data; //数据域 struct Node * next; //指针域&#125;LNode，*LinkList; 读取链表第i个元素的数据： 123456789101112131415Status GetElem(LinkList L, int i, ElemType *e)&#123; LinkList p; int j; p = L-&gt;next; j=1; while(p &amp;&amp; j&lt;i)&#123; p = p-&gt;next; ++j; &#125; if(!p || j&gt;i)&#123; return ERROR; &#125; * e = p-&gt;data; return OK;&#125; 在带头结点的链表L的第i个位置之前插入元素e: 12345678910111213141516171819Status ListInsert(LinkList &amp;L, int i, ElemType e)&#123; LNode p; int j; p = L; j=0; while(p &amp;&amp; j&lt;i-1)&#123; p = p-&gt;next; ++j; &#125; if(!p || j&gt;i-1)&#123; return ERROR; &#125; LinkList s; s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next =s; return OK;&#125; 在带头结点的链表L，删除第i个位置的元素，并由e返回其值: 12345678910111213141516171819Status ListDelete(LinkList &amp;L, int i, ElemType &amp;e)&#123; LNode p; int j; p = L; j=0; while(p &amp;&amp; j&lt;i-1)&#123; p = p-&gt;next; ++j; &#125; if(!(p-&gt;next) || j&gt;i-1)&#123; return ERROR; &#125; LinkList q; q = p-&gt;next; p = q-&gt;next; e = q-&gt;data; free(q); return OK;&#125; 循环链表是另外一种存储形式的链式存储结构，特点是表中最后一个结点的指针域指向头结点，与单链表比较相像，故不再赘述。双向链表：是指针域指向前驱结点和后继结点。存储结构为： 12345typedef struct DuLNode&#123; ElemType data; struct DuLNode * prior; struct DuLNode * next;&#125;DuLNode, * DuLinkList; 链表延伸1.编程创建一个单链表。可不断读取用户输入的整数并存储进链表里。并在最后将链表里面的数据打印出来。2.编程实现：将上述任务中已经创建完毕的单链表逆置（如将1-&gt;2-&gt;3-&gt;4-&gt;null逆置为4-&gt;3-&gt;2-&gt;1-&gt;） 程序代码简明起见，我将两个任务写在一个程序里了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SUCCESS 10000#define FAILURE 10001typedef int ElemType;typedef struct Node&#123; ElemType data; struct Node* next;&#125;Link;int InitLink(Link** l)//初始化链表&#123; if (NULL == l) &#123; return FAILURE; &#125; * l = (Link*)malloc(sizeof(Link)); if (NULL == * l) &#123; return FAILURE; &#125; (* l)-&gt;next = NULL; (* l)-&gt;data = 0; return SUCCESS;&#125;int InsertLink(Link* l, int place, ElemType e)//插入链表&#123; int k = 1; if (NULL == l) &#123; return FAILURE; &#125; if (place &gt; l-&gt;data + 1 || place &lt;= 0) &#123; return FAILURE; &#125; Link* head = l; while (k &lt; place) &#123; k++; l = l-&gt;next; &#125; Link* tmp = (Link*)malloc(sizeof(Link)); if (NULL == tmp) &#123; return FAILURE; &#125; tmp-&gt;next = l-&gt;next; l-&gt;next = tmp; tmp-&gt;data = e; head-&gt;data++; return SUCCESS;&#125;int TraverseLink(Link* l)//遍历链表&#123; int length; if (NULL == l) &#123; return FAILURE; &#125; length = l-&gt;data; while (length &gt; 0) &#123; length--; l = l-&gt;next; printf("%d ", l-&gt;data); &#125; return SUCCESS;&#125;void ReverseList(Link* L)//逆置链表&#123; Link* curnode = L-&gt;next; //当前节点，指向表头 Link* temp = curnode-&gt;next; //临时节点 curnode-&gt;next = NULL; L-&gt;next = curnode; while (temp != NULL) &#123; curnode = temp; temp = curnode-&gt;next; curnode-&gt;next = L-&gt;next; L-&gt;next = curnode; &#125;&#125;int SortInsert(Link* l, ElemType e)&#123; int flag = 1; int length, place; if (NULL == l) &#123; return FAILURE; &#125; Link* head = l; length = l-&gt;data; l = l-&gt;next; place = 0; if (0 == length)&#123; InsertLink(head, place + 1, e); &#125; else&#123; while (place &lt; length) &#123; if (e &lt; l-&gt;data) &#123; InsertLink(head, place + 1, e); flag = 0; break; &#125; else &#123; l = l-&gt;next; place++; &#125; &#125; if (1 == flag) &#123; InsertLink(head, length + 1, e); &#125; &#125; return SUCCESS;&#125;int main()&#123; Link* list; ElemType e; InitLink(&amp;list); printf("Please input numbers,input other character to end!\n"); while(scanf_s("%d",&amp;e) == 1) &#123; printf("Please input numbers,input other character to end!\n"); SortInsert(list, e); // printf("Length = %d\n", list-&gt;data); &#125; printf("The output is :"); TraverseLink(list); ReverseList(list); printf("\nThe reverse List output is: "); TraverseLink(list); return 0;&#125; 程序运行结果 Leetcode都不会做好难啊我太菜了]]></content>
      <tags>
        <tag>C</tag>
        <tag>Learning</tag>
        <tag>Function&amp;Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST Task1]]></title>
    <url>%2F2019%2F10%2F05%2FAST-Task1%2F</url>
    <content type="text"><![CDATA[学习内容0x01 C语言中的数据类型C语言中的常用数据类型 C语言中整型与字符型数据首先需要注意的是： 无符号(unsigned)整型数据与一般有符号整型数据的区别。 整型有无符号（unsigned）和有符号（signed）两种类型，在默认情况下声明的整型变量都是有符号的类型（char有点特别，需要根据具体编译环境确定），如果需声明无符号类型的话就需要在类型前加上unsigned。 无符号整型和有符号整型的区别就是无符号类型可以存放的正数范围比有符号整型中的范围大一倍，因为有符号类型将最高位储存符号，而无符号类型全都储存数字。 并且： 在C/C++语言中，int和long int的所占的字节数与编译环境有关。 C语言标准是这样规定的：int最少16位（2字节），long不能比int短，short不能比int长，具体位长由编译器开发商根据各种情况自己决定。 在老式的16位编译系统上，short、int、long普遍的长度是2字节、2字节、4字节。在32位编译系统x86处理器上，short、int、long普遍的长度是2字节、4字节、4字节。int占四字节，与long相同。在64位编译系统x64处理器上：short占两字节，int占四字节，long占8字节，long数据范围变为：-2^63~2^63-1 由此可见int类型的数据长度一般是机器位长。在16位编译系统中int为16位，两个字节；32位编译系统中int为32位，4个字节；但是在64位编译系统中为了兼容32位编译系统，64位编译系统的int也是4字节。 现在常用的编译器多认为int和long int相同，均为4字节，short为2字节，char为1字节。如果只输入int，它有可能是以上三种形式中的一种。 那么如何得到某个类型在特定平台上的准确大小？ 为了得到某个类型或某个变量在特定平台上的准确大小，我们可以使用 sizeof 运算符。通过表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小： 123456789#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int main()&#123; printf("int 存储大小 : %lu \n", sizeof(int)); return 0;&#125; C语言中的void类型void 类型指定没有可用的值。它通常用于以下三种情况下： 第一种：函数返回为空C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 第二种：函数参数为空C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数void *malloc( size_t size );返回指向 void 的指针，可以转换为任何数据类型。 C语言中的bool（布尔）类型在此之前的C语言中，使用整型int来表示真假。在输入时：使用非零值表示真；零值表示假。在输出时：真的值是1，假的值是0。 现在，出现了布尔型变量。_Bool类型长度为1，只能取值范围为0或1。将任意非零值赋值给_Bool类型，都会先转换为1，表示真。将零值赋值给_Bool类型，结果为0，表示假。 有如下example program： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; _Bool bool1 = 1; _Bool bool2 = 2; /* 非零值，bool2的值为1 */ _Bool bool3 = 0; _Bool bool4 = -1; /* 非零值，bool4的值为1 */ printf(&quot;bool1==%d, \n&quot;, bool1); printf(&quot;bool2==%d, \n&quot;, bool2); printf(&quot;bool3==%d, \n&quot;, bool3); printf(&quot;bool4==%d, \n&quot;, bool4); printf(&quot;sizeof(_Bool) == %d \n&quot;, sizeof(_Bool)); return 0;&#125; 运行结果如下： 12345bool1==1,bool2==1,bool3==0,bool4==1,sizeof(_Bool) == 1 C语言中的数组类型所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 C语言中的指针类型每个变量都被存放在从某个内存地址（以字节为单位）开始的若干个字节中。“指针”，也称作“指针变量”，大小为4个字节（或8个字节）的变量，其内容代表一个内存地址。通过指针，我们能够对该指针指向的内存区域进行读写。如果把内存的每个字节都想像成宾馆的一个房间，那么内存地址相当于就是房间号，而指针里存放的，就是房间号。 T * p ; // T 可以是任何类型的名字，比如 int, double ,char 等等。p 的类型: T * p 的类型： T通过表达式 * p，可以读写从地址 p 开始的 sizeof(T)个字节 p 等价于存放在地址p处的一个 T 类型的变量 意思为间接引用运算符sizeof(T*) 4字节（64位计算机上可能8字节） 有了指针，就有了自由访问内存空间的手段：不需要通过变量，就能对内存直接进行操作。通过指针，程序能访问的内存区域就不仅限于变量所占据的数据区域。在C中，用指针p指向a的地址,然后对p进行加减操作，p就能指向a后面或前面的内存区域，通过p也就能访问这些内存区域。 C语言中的字符串类型C语言中，字符串有两种形式： 用双引号括起来的字符串常量， 如”CHINA” ， “C program “。 存放于字符数组中，以‘\0’字符（ASCII码为0)结尾 存放于字符数组中的字符串常量占据内存的字节数等于字符串中字符数目加1，多出来的是结尾字符‘\0’。但是字符串的长度不包含’\0’用char数组存放字符串，数组元素个数应该至少为字符串长度+1，以避免数组越界。char数组的内容，可以在初始化时设定，还可以用对数组元素赋值的办法任意改变其中的某个字符。 “” 也是合法的字符串常量，称为“空串”， 空串仍然会占据一个字节的存储空间，存放 ‘\0’。 如果字符串常量中包含双引号，则双引号应写为‘&quot;’。而‘\’字符在 字符串中出现时，须连写两次，变成‘\’，以防止转译。 C语言中的结构类型两个同类型的结构变量，可以互相赋值。但是结构变量之间不能用“==”、“!=”、“&lt;”、“&gt;”、“&lt;=”、“&gt;=”进行比较运算。 一般来说，一个结构变量所占的内存空间的大小，就是结构中所有成员变量大小之和。结构变量中的各个成员变量在内存中一般是连续存放的。 并且，一个结构的成员变量可以是任何类型的，包括可以是另一个结构类型: ASCII码和char类型的关系char表示一个字符型数据，其和int在0-255范围内是等价的。而字符编码采用的是ASCII码，所以看起来和ASCII有关。在用char进行输入、输出时其值可以被当成ASCII码，输入、输出函数根据这个码找到相应的字符输入或输出。 0x02 使用格式化输入输出函数printf()和scanf()在printf和scanf中可以使用以”%”开头的控制符，指明要输入或输出的数据的类型以及格式。常用的格式控制符如下表所示：|常用格式控制符|作 用||—|—||%d|读入或输出int变量||%c|读入或输出char变量||%f|读入或输出float变量，输出时保留小数点后面6位||%lf|读入或输出double变量，输出时保留小数点后面6位||%x|以十六进制读入或输出整型变量||%lld|读入或输出long long 变量(64位整数）||%nd|(如%4d,%12d）以n字符宽度输出整数，宽度不足时用空格填充||%0nd|( 如 %04d,%012d )以n字符宽度输出整数，宽度不足时用0填充||%.nf|(如%.4f,%.3f） 输出double或float值，精确到小数点后n位| scanf的进阶使用1.用scanf可以一次读入多个类型不同的变量，只要输入的各项之间用空格分隔即可。example： 12345678910#include &lt;stdio.h&gt;int main()&#123; int n; char c; float m; scanf("%d%c%f",&amp;n,&amp;c,&amp;m); /*依次输入一个整数，一个字符，再一个整数，则它们会被分别放入n,c,m；&amp;n代表“取n的地址"，%c代表等待输入一个字符*/ printf("%d %c %f",n,c,m); return 0;&#125; 输入：34 k 234.45↙输出：34 k 234.449997 2.若输入的各项之间没有用空格分隔，则等待输入字符时，不会跳过空格(空格也会被当作字符读入)，输入其他类型的数据时，会跳过空格。example： 12345678910#include &lt;stdio.h&gt;int main()&#123; int n; char c; float f; scanf("%d%c%f",&amp;n,&amp;c,&amp;f); printf("%d %c %f",n,c,f); return 0;&#125; 输入：34 k 456↙输出：34 0.000000 原因：c = &apos; &apos;, 读入f 时，对应输入是&apos;k&apos;，导致出错。3.如果在输入中有scanf中出现的非控制字符，则这些字符会被跳过。example： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int n,m; char c; float f; scanf("%d %c,%f:%d",&amp;n,&amp;c,&amp;f,&amp;m); printf("%d,%c,%f,%d",n,c,f,m); return 0;&#125;&#125; 输入：12 k,3.75:290↙输出：12,k,3.750000,290 有关sprintf()和sscanf()函数参考这篇文章:浅析C语言中printf(),sprintf(),scanf(),sscanf()的用法和区别-极客编程-博客园 0x03 分支结构与循环控制结构分支结构if语句常见错误1.错把赋值符当逻辑运算符来使用：example： 1234567int a = 0;if( a = 0 ) //a = 0的值是0printf("hello");if( a = 5 ) // a = 5的值是5printf("Hi");=&gt; Hi 2.互相矛盾的多个条件，如果确实只希望执行其中一个分支，应该用if和多个else if，而不要写多个if wrong example: 123456789int a = 0;if( a &gt;=0 &amp;&amp; a &lt; 5 )a = 8;if( a &gt;= 5 &amp;&amp; a &lt; 10 )printf("hello");if( a &gt; 10 &amp;&amp; a &lt; 20).....if( a &gt;= 20)..... 最终会输出hello right example： 123456789int a = 0;if( a &gt;=0 &amp;&amp; a &lt; 5 )a = 8;else if( a &gt;= 5 &amp;&amp; a &lt; 10 )printf("hello");else if( a &gt; 10 &amp;&amp; a &lt; 20).....else..... 不会输出 hello switch语句常见错误switch语句在进入某个case分支后，会一直执行到第一个碰到的“break;”，即使这个“break;”是在后面的case分支里面。如果没有碰到“break;”，则会向下一直执行到switch语句末尾的“}”，包括“default:”部分的语句组也会被执行。 因此，在运用switch语句时，一定要根据题目加上break关键字。 if-else与switch-case语法的区别if语句，if else if语句和switch case语句都属于流程控制语句。 在只需要判断一个条件的时候，自然是使用if语句方便有效；但是当判断条件很多的时候，我们可以使用多个if语句或者if…else if语句或者switch case语句。 if…else if语句和多个if语句的区别还是很大的，if…else if在任何一个环节满足条件的时候就将会终止判断，只处理一个满足条件的情况；而对于多个if语句，将会对每一个判断条件进行判断，自然而然会导致程序的执行效率降低。在多个判断条件的情况下，使用if…else if语句相对于使用多个if语句而言，可以减少程序的判断次数，提高效率。 在多个判断条件的情况下，不仅可以使用if…else if语句，还可以使用switch case语句。一般情况下，当判断条件较多的情况下，使用switch case语句的效率会高于使用if…else if语句。switch…case与if…else if的根本区别在于，switch…case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch…case不用像if…else if那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。 因此，当只有分支比较少的时候，if效率比switch高（因为switch需要生成跳转表）。若分支比较多，那当然是switch更高效也更清晰。 循环结构for循环语句结构特点for语句结构： 123for( 表达式1 ;表达式2;表达式3) &#123;语句组&#125; for循环结构里的“表达式1”和“表达式3”都可以是用逗号连接的若干个表达式。 for循环括号内三个语句的执行时间执行过程： 1) 计算“表达式1”。2) 计算“表达式2”，若其值为true，则执行“{ }”中的语句组，然后转到3)；若为false,则不再执行“{}”中的语句组，for语句结束，转到5)。3) 计算“表达式3”。4) 转到2)。5) 从for语句后面继续往下执行程序。 for语句的循环控制变量特点循环控制变量定义在”表达式1”中，则其只在for语句内部起作用，可以不用担心循环控制变量重名。example： 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int i = 5; for( int i = 0;i &lt; 26; ++i )&#123; printf("%c\n",char('a'+i )); &#125; for( int i = 0;i &lt; 26; i+=2 )&#123; printf("%c\n",char('a'+i )); &#125; printf("%d\n",i）;//此处的i和for里面的i无关 return 0;&#125;&gt;最后的一个输出：5#### while循环语句结构特点```cwhile(表达式) &#123;语句组&#125; 若情境是并非到达指定次数，而是满足某条件时即停止循环，则适合用while语句来实现循环。 while循环的执行过程1) 判断“表达式”是否为真，如果不为真，则转4)2) 执行“语句组”3) 转1)4) while语句结束，继续执行while语句后面的语句。 do……while循环语句结构特点123do &#123;语句组&#125; while(表达式); 如果希望循环至少要执行一次，就可以使用do…while语句。 do……while循环语句的执行过程每执行一次循环后，都要判断“表达式”的值是否为真，如果真就继续循环，如果为假，就停止循环。 while和do……while语句的区别while先判断后执行，do while先执行后判断当不满足循环条件时，while循环一次都不会执行，do while循环至少执行一次 break与continue语句break语句可以出现在循环体中(for、while、do…while循环均可)，其作用是跳出循环。并且在多重循环的情况下，break语句只能跳出直接包含它的那一重循环。 example:找兄弟数：如果两个不同的正整数，他们的和是他们的积的因子，就称这两个数为兄弟数，小的称为弟数，大的称为兄数。先后输入正整数n和m(n &lt; m) , 请在n至m这m-n+1个数中，找出一对兄弟数。如果找不到，就输出“No Solution.”。如果能找到，就找出和最小的那一对；如果有多对兄弟数和相同且都是最小，就找出弟数最小的那一对。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main() &#123; int n,m; scanf("%d %d",&amp;n,&amp;m ); int a = m + 1,b = m + 1; //a,b记录已经找到的最佳兄弟数，a是弟数，b是兄数 for( int i = n; i &lt; m ; ++i ) &#123; //取弟数，共m-n种取法 if( i &gt; (a + b)/2 + 1) break; // 跳出外重循环 for( int j = i + 1; j &lt;= m; ++j ) &#123; //取兄数 if( i + j &gt; a + b ) break; // 跳出内重循环 if( i * j % (i + j) == 0 ) &#123; //发现兄弟数 if( i + j &lt; a + b) &#123; //发现和更小的兄弟数 a = i; b = j ; //更新已找到的最佳兄弟数 &#125; else if( i + j == a + b &amp;&amp; i &lt; a) //发现和相同但弟数更小的兄弟数 a = i; b = j; //更新已找到的最佳兄弟数 &#125; &#125; &#125; if( a == m + 1 ) //没找到兄弟数 printf("No solution."); else printf("%d,%d\n",a,b); return 0;&#125; continue语句可以出现在循环体中(for、while、do…while循环均可)，其作用是立即结束本次循环，并回到循环开头判断是否要进行下一次循环。在多重循环的情况下，continue只对直接包含它的那重循环起作用。 example：找10以内的偶数 1234567891011#include&lt;stdio.h&gt;int main()&#123; for( int i = 1;i &lt;= 10 ;++i ) &#123; if( i % 2 ) continue; //导致不执行后面的语句，回到循环开头 printf("%d,",i); &#125; return 0;&#125; 输出：2,4,6,8,10, 0x04 初始化数组一维数字数组的初始化在通过type arrayName [ arraySize ];语句声明数组之后，需要对数组进行初始化。 在 C 中，我们可以逐个初始化数组，也可以使用一个初始化语句，如下所示： int test[5] = {1, 2, 3, 4, 5}; 需要注意的是，声明数组时方括号内的数字代表的是数组长度。数组的元素都是从0开始标号的，因此数组的第一个元素是arrayName[0],最后一个元素是arrayName[数组的总大小减去 1]。需要牢记这一点以免发生数组越界情况。 例如，有以下程序： 1234567891011121314 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define Lenth 5 int main() &#123; int test[Lenth] = &#123; 1, 2, 3, 4, 5 &#125;; int i = 0; for (i = 0; i &lt; Lenth; i++) &#123; printf("test数组的第%d个元素为%d,\n", i+1, test[i]); &#125; return 0;&#125; 运行结果为： &gt;test数组的第1个元素为1, test数组的第2个元素为2, test数组的第3个元素为3, test数组的第4个元素为4, test数组的第5个元素为5, 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 若是大括号{ }之间的值小于我们在数组声明时在方括号中指定的元素数目，则没有值与之对应的数组元素自动赋0 只能给元素逐个赋值，不能给数组整体赋值。例如给十个元素全部赋1值，只能写为：int a[10]={1,1,1,1,1,1,1,1,1,1};而不能写为：int a[10]=1. 如不给可初始化的数组赋初值，则全部元素均为0值。 以上规则也适用于 其他类型的数组例如，有以下程序： 1234567891011121314 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define Lenth 6 int main() &#123; int test[Lenth] = &#123; 1, 2, 3, 4, 5 &#125;; int i = 0; for (i = 0; i &lt; Lenth; i++) &#123; printf("test数组的第%d个元素为%d,\n", i+1, test[i]); &#125; return 0;&#125; 运行结果为： &gt;test数组的第1个元素为1, test数组的第2个元素为2, test数组的第3个元素为3, test数组的第4个元素为4, test数组的第5个元素为5, test数组的第6个元素为0, 如果在初始化时省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果我们初始化：int test[] = {1, 2, 3, 4, 5};那么创建的这个数组，它与前一个例子中所创建的数组是完全相同的。 一维字符数组的初始化C语言允许用字符串的方式对数组作初始化赋值。例如： 1char c[9]=&#123;'c',' ','p','r','o','g','r','a','m'&#125;; 可写为： 1char c[10]=&#123;"C program"&#125;; 或去掉&#123;&#125;写为： 1char c[10]="C program"; 需要注意的是，用字符串给字符数组赋值时由于要添加结束符 ‘\0‘，数组的长度要比字符串的长度（字符串长度不包括 ‘\0&#39;）大1。例如：char str[] = “C program”;该数组在内存中的实际存放情况为：字符串长度为 9，数组长度为 10。因此我们需要增加一个字符数组长度用来存放\0。 并且，上述这种字符数组的整体赋值只能在字符数组初始化时使用，不能用于字符数组的赋值，字符数组的赋值只能对其元素一一赋值，下面的赋值方法是错误的。 12char str[];str="I am happy";//错误，字符数组的赋值只能按元素一一赋值 当对全体元素赋初值时也可以省去长度说明。例如： 1char c[]=&#123;'c',' ','p','r','o','g','r','a','m'&#125;; 这时C数组的长度自动定为9。 二维数字数组的初始化example： 1int a[5][3]=&#123;&#123;80,75,92&#125;,&#123;61,65&#125;,&#123;59,63,70&#125;,&#123;85,90&#125;,&#123;76,77,85&#125;&#125;; 每个内层的{}，初始化数组中的一行。同样地，二维数组初始化时，如果对每行都进行了初始化，则也可以不给出行数:example： 1int a[][3]=&#123; &#123;80,75,92&#125;,&#123;61,65&#125; &#125;; a 是一个2行3列的数组，a[1][2]被初始化成0。 二维字符数组的初始化通常情况下，二维数组的每一行分别使用一个字符串进行初始化。 例如： 1char c[3][8]=&#123;&#123;"apple"&#125;,&#123;"orange"&#125;,&#123;"banana"&#125;&#125;; 等价于： 1char c[3][8]=&#123;"apple","orange","banana"&#125;; 以上两条初始化语句中，二维数组的第一维大小均可省略。数组 c 的逻辑结构如下所示：| |0|1|2|3|4|5|6|7||–|–|–|–|–|–|–|–|–||c[0]|a|p|p|l|e|\0|\0|\0||c[1]|o|r|a|n|g|e|\0|\0||c[2]|b|a|n|a|n|a|\0|\0| 二维数字数组的存放方式数组T a[N][M] 每一行都有M个元素第i行的元素就是a[i][0]、a[i][1]……a[i][M-1]。同一行的元素，在内存中是连续存放的。第j列的元素的元素，就是a[0][j]、a[1][j]……a[N-1][j]。a[0][0]是数组中地址最小的元素。如果a[0][0]存放在地址n，则a[i][j]存放的地址就是：n + i × M× sizeof(T) + j × sizeof(T) 数组越界数组元素的下标，可以是任何整数，可以是负数，也可以大于数组的元素个数。不会导致编译错误：example： 12345int a[10];a[-2] = 5;a[200] = 10;a[10] = 20;int m = a[30]; 但运行时很可能会出错!a[-2] = 5; a[200] = 10; a[10] = 20;int m = a[30];均可能导致程序运行出错！！！因为可能引起意外修改其他变量的值，导致程序运行结果不正确可能试图访问不该访问的内存区域，导致程序崩溃数组越界的程序，用某些编译器编译后可能可以正确运行，换一个编译器编译后就运行错误最可怕的是，编译器不会报错。 因此，我们在使用数组时，最好能初始化/声明地大一些 0x05 标识符的作用域，结构体标识符的作用域C语言中的全局变量、局部变量、静态变量要想学习变量的作用域，首先要搞懂C中的全局变量、局部变量、静态变量 局部变量：定义在函数内部的变量叫局部变量（函数的形参也是局部变量） 全局变量：定义在所有函数的外面的变量叫全局变量全局变量在所有函数中均可以使用，局部变量只能在定义它的函数内部使用 静态变量：全局变量都是静态变量。局部变量定义时如果前面加了“static”关键字，则该变量也成为静态变量静态变量的存放地址，在整个程序运行期间，都是固定不变的非静态变量(一定是局部变量)地址每次函数调用时都可能不同,在函数的一次执行期间不变如果未明确初始化，则静态变量会被自动初始化成全0(每个bit都是0），局部非静态变量的值则随机 作用域变量名、函数名、类型名统称为“标识符”。一个标识符能够起作用的范围，叫做该标识符的作用域 在一个标识符的作用域之外使用该标识符，会导致“标识符没有定义”的编译错误。使用标识符的语句，必须出现在它们的声明或定义之后在单文件的程序中，结构、函数和全局变量的作用域是其定义所在的整个文件 函数形参的作用域是整个函数局部变量的作用域，是从定义它的语句开始，到包含它的最内层的那一对大括号“{}”的右大括号 “}”为止。for循环里定义的循环控制变量，其作用域就是整个for循环同名标示符的作用域，可能一个被另一个包含。则在小的作用域里，作用域大的那个标识符被屏蔽，不起作用。 生存期所谓变量的“生存期”，指的是在此期间，变量占有内存空间，其占有的内存空间只能归它使用，不会被用来存放别的东西。而变量的生存期终止，就意味着该变量不再占有内存空间，它原来占有的内存空间，随时可能被派做他用。 全局变量的生存期，从程序被装入内存开始，到整个程序结束。静态局部变量的生存期，从定义它语句第一次被执行开始，到整个程序结束为止。函数形参的生存期从函数执行开始，到函数返回时结束。非静态局部变量的生存期，从执行到定义它的语句开始，一旦程序执行到了它的作用域之外，其生存期就终止。 使用struct定义结构体我们可以使用“struct”关键字来定义一个“结构”，也就是说定义了一个新的结构数据类型：定义方式: 1234567struct 结构名&#123;类型名 成员变量名；类型名 成员变量名；类型名 成员变量名；……&#125;; example: 12345struct Student &#123;unsigned int ID;char Name[20];float GPA;&#125;; 在经过这条语句之后Student 即成为自定义类型的名字，可以用来定义变量Stuent s1,s2; 使用结构体获得、写入结构体内部的成员变量一个结构变量的成员变量，可以完全和一个普通变量一样来使用，也可以取得其地址。使用形式： 结构变量名.成员变量名example：对于以下定义的StudentEx与Date结构体数据类型 1234567891011struct Date &#123;int year;int month;int day;&#125;;struct StudentEx &#123;unsigned int ID;char Name[20];float GPA;Date birthday;&#125;; 我们可以运行以下的main()代码段： 1234567StudentEx stu;scanf("%f", &amp;stu.GPA);stu.ID = 12345;stu.Name[]=&#123;'Z','a','m'&#125;;printf("%f",stu.GPA);stu.birthday.year = 1984;unsigned int * p = &amp; stu.ID; //p指向stu中的ID成员变量 结构变量的初始化结构变量可以在定义时进行初始化:例如对上面的例子，我们可以通过以下语句对结构变量进行初始化 1StudentEx stu = &#123; 1234,"Tom",3.78,&#123; 1984,12,28 &#125;&#125;; 指向结构变量的指针定义指向结构变量的指针方式：结构名 * 指针变量名;example: 1234StudentEx * pStudent;//定义了* pStudent为StudentEx类型的指针StudentEx Stu1;pStudent = &amp; Stu1;//使得pStudent指针指向stu1变量的起始位置StudentEx Stu2 = * pStudent; //将pStudent指针指向的stu1变量赋值给stu2变量 通过指针，访问其指向的结构变量的成员变量方式： 123指针-&gt;成员变量名or(* 指针).成员变量名 example:对于‘使用结构体获得、写入结构体内部的成员变量’中定义的结构体可以使用以下语句： 1234567StudentEx Stu;StudentEx * pStu;pStu = &amp; Stu;pStu-&gt;ID = 12345;( * pStu).GPA = 3.48;printf("%d\n",Stu.ID) //输出 12345printf("%f\n",Stu.GPA); //输出 3.48 0x06 C语言函数函数的定义一般来说函数的定义必须出现在函数调用语句之前，否则调用语句编译出错函数的定义方式： 12345返回值类型 函数名(参数1类型 参数1名称, 参数2类型 参数2名称……)&#123;语句组(即“函数体”）return 返回值；&#125; 如果函数不需要返回值，则“返回值类型”可以写“void” 函数的调用调用函数语句：函数名（参数1,参数2，……） return语句对函数的调用，也是一个表达式。函数调用表达式的值，由函数内部的return语句决定。return语句语法如下：return 返回值；return语句的功能是结束函数的执行，并将“返回值”作为结果返回。“返回值”是常量、变量或复杂的表达式均可。如果函数返回值类型为“void”，return语句就直接写：return ;需要注意的是，return 语句作为函数的出口，可以在函数中多次出现。多个return语句的“返回值”可以不同。在哪个return语句结束函数，函数的返回值就和哪个return语句里面的“返回值”相等。 0x07 C语言的指针C语言指针的定义T * p ; // T 可以是任何类型的名字，比如 int, double ,char 等等。p 的类型: T * *p 的类型： T通过表达式 * p，可以读写从地址p开始的 sizeof(T)个字节*p 等价于存放在地址p处的一个 T 类型的变量 间接引用运算符 sizeof(T*) 4字节（64位计算机上可能8字节）指针的用法&amp; : 取地址运算符&amp;x : 变量x的地址（即指向x的指针)对于类型为 T 的变量 x，&amp;x 表示变量 x 的地址(即指向x的指针) &amp;x 的类型是 T * 。example：123456char ch1 = 'A';char * pc = &amp;ch1; // 使得pc 指向变量ch1 * pc = 'B'; // 使得ch1 = 'B' char ch2 = * pc; // 使得ch2 = ch1 pc = &amp; ch2; // 使得pc 指向变量ch2 * pc = 'D'; // 使得ch2 = 'D' 指针的赋值 不同类型的指针，如果不经过强制类型转换，不能直接互相赋值example： 123456int * pn, char * pc, char c = 0x65;pn = pc; //类型不匹配，编译出错pn = &amp; c; //类型不匹配，编译出错pn = (int * ) &amp; c;int n = * pn; //n值不确定* pn = 0x12345678; //编译能过但运行可能出错 指针的运算1） 两个 同类型 的指针变量，可以比较大小 若地址p1&lt;地址p2，则 p1&lt; p2 值为真。若地址p1=地址p2，则 p1== p2 值为真。若地址p1&gt;地址p2，则 p1 &gt; p2 值为真。 2) 两个 同类型 的指针变量，可以相减 运算规则：两个T * 类型的指针 p1和p2p1 – p2 = ( 地址p1 – 地址 p2 ) / sizeof(T) 例：int * p1, * p2;若 p1 指向地址 2000,p2 指向地址 600, 则p1 – p2 = (1000 – 600)/sizeof(int) = (2000 – 600)/4 = 350 3)指针变量加减一个整数的结果是指针 例如：p : T * 类型的指针n : 整数类型的变量或常量 则p+n : T * 类型的指针，指向地址： 地址p + n × sizeof(T)n+p, p-n , * (p+n), * (p-n)等同理 4) 指针变量可以自增、自减 若T* 类型的指针p指向地址n则p++, ++p : p指向 n + sizeof(T) p–, –p : p指向 n - sizeof(T) 5）指针可以用下标运算符“[ ]”进行运算若p 是一个 T * 类型的指针， n 是整数类型的变量或常量则p[n] 等价于 * (p+n) Task End]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>AST of EIC,HUST</tag>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
