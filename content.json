{"meta":{"title":"Zam’s Blog","subtitle":null,"description":"A total fish","author":"Zam","url":"http://Zam-0703.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-10-04T15:20:00.102Z","updated":"2019-10-04T15:20:00.102Z","comments":true,"path":"404.html","permalink":"http://Zam-0703.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-10-04T15:10:53.054Z","updated":"2019-10-04T15:10:53.054Z","comments":true,"path":"about/index.html","permalink":"http://Zam-0703.github.io/about/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-10-04T15:19:03.453Z","updated":"2019-10-04T15:19:03.453Z","comments":true,"path":"friends/index.html","permalink":"http://Zam-0703.github.io/friends/index.html","excerpt":"","text":"需要上友链，请发邮件到Zam-0703@Outlook.com~"},{"title":"","date":"2019-10-04T15:15:06.021Z","updated":"2019-10-04T15:15:06.021Z","comments":true,"path":"mylist/index.html","permalink":"http://Zam-0703.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-10-04T15:13:44.298Z","updated":"2019-10-04T15:13:44.298Z","comments":true,"path":"categories/index.html","permalink":"http://Zam-0703.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-10-04T15:14:33.435Z","updated":"2019-10-04T15:14:33.435Z","comments":true,"path":"tags/index.html","permalink":"http://Zam-0703.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux初体验","slug":"Linux初体验","date":"2019-11-02T01:50:17.000Z","updated":"2019-11-02T03:26:17.485Z","comments":true,"path":"2019/11/02/Linux初体验/","link":"","permalink":"http://Zam-0703.github.io/2019/11/02/Linux初体验/","excerpt":"","text":"写在前面本来想装物理机Linux，做个双系统，但是奈何本机硬件不算主流（Ryzen 7 3700u with Radeon Vega Mobile Gfx）,担心在物理机上安Arch会出现驱动兼容性问题，遂作罢，改用VMware安装虚拟机，还可以顺带做网安组的Task，美滋滋。 安装准备VMware的安装下载地址：https://www.nocmd.com/740.html安装无脑下一步即可 Arch Linux镜像下载地址：http://mirrors.zju.edu.cn/archlinux/iso/2019.10.01/ （浙大源）下载链接地址中的archlinux-2019.10.01-x86_64.iso若此地址下载缓慢，也可以进入官方的下载源集合：https://www.archlinux.org/download/ 开始安装VMware配置打开VMware，首先点击文件选项 -&gt; 新建虚拟机 -&gt; 典型 -&gt; 稍后安装操作系统 -&gt; 选择Linux选项 -&gt; 版本选择‘Linux4.x’，内存按需分配就可以，硬盘分配40G左右，根据自己需求来定，毕竟Arch一开始还算一个比较干净简洁轻量的Linux release。网络类型选择NAT，其他默认即可。CD/DVD选项记得选择ArchLinux镜像。 Arch Linux安装准备启动安装archlinux不论你使用的是EFI或BIOS引导，均选择Boot Arch Linux(x86_64)这一选项启动成功后就会进入命令行模式，此时如果你不清楚你用的是EFI引导还是BIOS引导，可以在此处列出efivars目录以验证启动模式来判断主板是以何种方式引导系统的（这对之后对硬盘的分区 十分有用）： 1ls /sys/firmware/efi/efivars 若该目录不存在，系统就可能以BIOS模式启动。 确认网络连接情况如果你使用的是有线网络连接方式，那么Arch Linux在启动后，守护进程dhcpcd已被默认启用以探测有线设备，因此你只需验证网络是否正常即可如果你使用的是无线网络连接方式，Arch Linux的安装必须使用网络才能完成，使用下面命令以验证网络是否正常： 1ping -c 4 www.baidu.com 如果网络不正常，可能是由于dhcp服务没有开启，可以使用以下命令来开启此服务： 1systemctl enable dhcpcd.service 更新系统时间首先还是验证一下系统的时间是否正常： 1timedatectl status 如果时间和当前时间对不上的话，使用下面命令来更新系统时间： 1timedatectl set-ntp true 建立硬盘分区硬盘如果被系统识别到，就会被分配为一个块设备，如/dev/sda；因此先查看一下硬盘的状态，以便于后续分区操作： 1lsblk 屏幕显示如下：这里sda即是我分配给虚拟机的8GB硬盘，因为此硬盘下还没有分区，所以sda节点下无任何显示；loop0和sr0可以忽略。如果硬盘已经有分区，sda节点下应当会显示如下图：接下来我们要对这8GB的硬盘进行分区，能够创建分区的命令很多，如fdisk，parted，cfdisk等，这里使用GUI的cfdisk命令（在真机上分区时，请认真检查你的硬盘是否选择正确，如果你有多个硬盘，可能你要用来安装Linux的硬盘并不是如下所写的/dev/sda，而是/dev/sdb也说不定。 1cfdisk /dev/sda 对于一个硬盘，以下三个分区是必须要有的：··· 一个根分区（挂载在根目录） /··· 如果 UEFI 模式被启用，你还需要一个 EFI 系统分区，或者是通过BIOS启动，那么你需要建立的是BIOS boot分区··· Swap 可以在一个独立的分区上设置，也可以直接建立交换文件其中，Swap分区的大小应与你物理机/虚拟机的内存大小相同，EFI分区通常为300M，BIOS boot分区通常为1G 具体cfdisk的使用命令，可以参考这篇文章：https://jingyan.baidu.com/article/ce09321bb922da2bff858fdd.html 分好区后确认写入分区到硬盘，然后退出分区工具，再次使用lsblk查看一下，显示如下图：那么你就成功分好区了 格式化分区分区完成后，需要对分区做格式化处理，如果你使用了EFI分区，因为EFI分区需要FAT32文件格式，所以需要将其格式化为FAT32格式；EFI引导分区推荐大小为512M。在这里我使用的是BIOS引导，但为了方便起见，我也将它格式化成FAT32文件格式。根分区格式化为ext4格式；设置并开启Swap分区： 12345mkfs.fat -F32 /dev/sda2mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4mkswap /dev/sda1 -L Swapswapon /dev/sda1 挂载分区EFI模式引导格式化完成后，需要将分区挂载到 /mnt ，先挂载根分区（这里是/dev/sda2）；再挂载EFI分区（这里是/dev/sda1），挂载EFI分区时，需要在/mnt上先创建 boot/EFI 目录，然后将EFI分区挂载到/mnt/boot/EFI上；Sawp分区不需要挂载： 123mount /dev/sda3 /mntmkdir -p /mnt/boot/EFImount /dev/sda2 /mnt/boot/EFI BIOS模式引导12345mount /dev/sda4 /mnt 注：sda4挂载为根mkdir /mnt/boot 注：在 / 分区中创建/boot文件夹mkdir /mnt/home 注：在 / 分区中创建home文件夹mount /dev/sda2 /mnt/boot 注：将sda2分区挂载到/mnt/boot文件夹内mount /dev/sda3 /mnt/home 注：将sda3分区挂载到/mnt/home文件夹内 安装基本系统选择软件镜像源在安装基本系统之前，需要修改一下软件镜像源，不然安装基本系统时会安装不上。镜像源列表在 /etc/pacman.d/mirrorlist 文件中。 我们选择软件镜像源时，最好选择国内的镜像源，因为国内网络环境的关系，选择其他国家或地区的镜像源，安装时可能很慢或失败也不一定。 下面这段代码首先添加了阿里巴巴镜像源到一个新文件（此处为mrlist），然后从mirrolist文件中选出所有国内镜像源追加到mrlist中，然后将mirrorlist文件的内容追加在mrlist的最后面，最后将mrlist重命名为mirrorlsit： 1234echo &apos;## China\\nServer = http://mirrors.aliyun.com/archlinux/$repo/os/$arch&apos; &gt; mrlistgrep -A 1 &apos;China&apos; /etc/pacman.d/mirrorlist|grep -v &apos;\\-\\-&apos; &gt;&gt; mrlistcat /etc/pacman.d/mirrorlist &gt;&gt; mrlistmv mrlist /etc/pacman.d/mirrorlist 执行完以上命令后，可以使用以下命令来查看mirrorlist文件是否修改成功： 1nano /etc/pacman.d/mirrorlist 按下Ctrl+X退出查看若修改成功，会看到mirrorlist文件中的开头的内容全是国内的镜像源 开始安装系统修改完软件镜像源后，然后就可以开始安装系统了： 1pacstrap -i /mnt base base-devel vim linux linux-firmware 注意，在安装环节就需要安装linux 和 linux-firmware两个包，不然会导致内核没有安装导致grub引导失败进不去系统使用-i选项会在实际安装前进行确认；安装 base-devel组，可以让我们通过 AUR (简体中文) 或者 ABS (简体中文) 编译安装软件包，如果不需要通过AUR或ABS安装软件包，则只需要安装base组就可以了 。 配置系统FstabLinux的文件结构是单个的树状结构。最顶部的为根目录，即/。在根目录下，分为多个子目录，包括/bin、/boot、/dev、/etc、/home、/lib、/media、/mnt、/opt、/proc、/root、/sbin、/tmp、/usr和/var等。磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作，而fstab正是负责这一配置。 因此，在基本系统安装完成后，用以下命令生成 fstab 文件 (用 -U 或 -L 选项设置UUID 或卷标)： 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 然后使用以下命令检查一下生成的fstab文件是否正确： 1nano /mnt/etc/fstab 如果生成的fstab文件正确，会看到之前分的4个分区的信息。 Chrootchroot命令用来在指定的根目录下运行指令切换到新安装的系统： 1arch-chroot /mnt chroot之后，当前目录就变成为 / 。此步会自动进行创建初始的ramdisk环境，但是如果以后更改了内核配置了的话，最好使用一下命令再重新生成ramdisk环境： 1mkinitcpio -p linux 配置时区将系统时区设为东八区： 1ln -sf /usr/share/zoneinfo/Asia/Chongqing /etc/localtime 设置时间标准为UTC，并调整时间漂移： 1hwclock --systohc --utc 配置Localelocale文件对系统的使用地区和语言等进行配置。在/etc/locale.gen文件中进行配置。locale.gen是一个仅包含注释文档的文本文件。指定需要的本地化类型，只需移除对应行前面的注释符号（＃）即可，使用下面命令打开locale.gen文件： 1nano /etc/locale.gen 然后找到下面2项，去掉每项前面的#即可： 12en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8 使用locale-gen命令生成Locale信息，并列出所有启用的Locale： 12locale-genlocale -a 最后创建locale.conf文件，并提交所要使用的本地化选项，然后使用locale命令显示当前正在使用的Locale和相关的环境变量： 12echo LANG=en_US.UTF-8 &gt; /etc/locale.conflocale /etc/locale.conf用来配置整个系统所使用的Loacle，而这也可以由用户通过用户自己的 /.config/locale.conf （表示当前用户的Home目录）来覆盖整个系统的Locale配置。建立 /etc/skel/.config/locale.conf 文件，可以在新用户的建立（新用户的建立见下文）且同时创建用户主目录（useradd -m）时，自动应用其中的Locale（会将此文件复制到新建用户的 ~/.config/locale.conf 中）。不推荐此时设置任何中文locale，因为这样做可能会导致tty显示乱码。 设置主机名要设置主机名，创建 /etc/hostname 文件并将主机名写入该文件即可。我的主机名为Zam-laptop： 1echo Zam-laptop &gt; /etc/hostname 然后配置主机名对应的IP到 /etc/hosts 中： 1nano /etc/hosts 将其中的主机名改为你自己的主机名（我这里是Zam-laptop）： 123127.0.0.1 localhost.localdomain localhost::1 localhost.localdomain localhost127.0.1.1 Zam-laptop.localdomain Zam-laptop 网络配置若使用有线网络的话，由于在Base包里已经不包括联网所需的程序，所以需要下载dhcp客户端: 1pacman -S dhcpcd 若使用无线网络的话，则安装以下几个软件包（因为我使用的是虚拟机，并未验证过）： 1pacman -S iw wpa_supplicant dialog 设置Root用户密码设置root密码： 1passwd 然后输入两次密码即可。 创建新用户因为使用root用户登陆后，root用户拥有系统的所有操作权限，这样对系统的操作非常不安全（如一不小心删库，你就要开始跑路），所以需要新建一个普通用户，让其对系统的操作受到一定限制，使用下面命令新建用户zam： 1useradd -m -G wheel -s /bin/bash zam 命令解释：-m：创建用户主目录（/home/[用户名]）-G：用户要加入的附加组列表；此处将用户加到wheel组中，之后可以给这个组执行sudo命令的权限-s：指定了用户默认登录shell的路径，此处设置为bash的路径更多创建新用户的使用请查看官方Arch Linux Wiki：https://wiki.archlinux.org/index.php/Users_and_groups_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 然后修改新创建用户的用户密码，和修改Root用户密码所使用的命令一样（只是需要指定要修改密码的用户名）： 1passwd zam 然后输入两次密码即可。 以后大部分时间我们都将使用此普通用户来工作，但由于此用户的操作权限有限，有时会对很多操作带来不便，因此需要给该用户在某些情况下提权，这就需要允许该用户所在的wheel组有执行sudo命令的权限，此时需要修改 /etc/sudoers文件 ，但请不要直接修改此文件，而是用下面的命令修改： 1visudo 使用上面命令打开sudoers文件后，删除wheel组前面的注释（#）即可： 12## Uncomment to allow members of group wheel to execute any command%wheel ALL=(ALL) ALL 若执行visudo时，提示找不到vim，则请先安装vim后在执行上面的操作，执行下面指令安装vim： 1pacman -S vim 安装grubgrub是一个启动引导器，同时支持EFI和BIOS方式的启动。若使用的UEFI方式引导系统，则还需要安装efibootmgr，如果是双系统的话，还需要安装os-prober，且如果使用Intel CPU的话，则需要安装 intel-ucode 并启用 因特尔微码更新 嘤特尔微码更新并不是一定需要开启 微码 微码（microcode）就是由 Intel/AMD 提供的 CPU 固件。Linux 的内核可以在引导时更新 CPU 固件，而无需 BIOS 更新。处理器的微码保存在内存中，在每次启动系统时，内核可以更新这个微码。 这些来自 Intel/AMD 的微码的更新可以去修复 bug 或者使用补丁来防范 bug。例如前段时间爆出的幽灵(Spectre)与熔断(Meltdown)漏洞，就可以通过更新微码来解决 因此，最好还是启用因特尔微码更新，以保证自己的数据安全 因为我使用的是虚拟机和BIOS引导方式，因此只需要安装grub： 1pacman -S grub 然后，还需要将其安装到BIOS boot分区当中： 1grub-install --recheck /dev/sda 注意：此处的 /dev/sda 后没有数字。最后还需要生成一个grub的配置文件： 1grub-mkconfig -o /boot/grub/grub.cfg 重启执行以下命令： 12exit #退出chroot环境，切换到光盘系统reboot #重启系统 然后你就可以进入到grub的引导界面，选择Arch Linux，enjoy it！ 进阶安装在重启之后，我们就已经成功地安装了ArchLinux,但是这时系统处于一个非常精简的状态,为了日常使用,我们必须安装一些需要的组件,来完善我们的系统功能。 预先准备：启动DHCP服务启动dhcp服务： 1systemctl enable dhcpcd.service 以确保后续的下载软件包操作能够正常进行 安装图形界面安装XorgXorg是Linux下的一个著名的开源图形服务，我们的桌面环境需要Xorg的支持。执行以下命令安装Xorg及相关组件： 1sudo pacman -S xorg 安装Deepin Desktop Environment（DDE）作为国产的桌面操作环境，当然要滋磁一波执行以下命令： 1sudo pacman -S deepin deepin-extra lightdm lightdm-deepin-greeter 安装其余实用软件deepin还提供了解压、下载工具等实用工具的下载执行以下命令： 12sudo pacman -S file-roller evince gedit thunderbird gpicviewsudo pacman -S unrar unzip p7zip 安装桌面管理器sddm经过某李姓学长提醒，了解了sddm和lightdm都是图形化的桌面管理器，因此若上面安装deepin时已经安装了lightdm，接下来就不需要安装桌面管理器sddm了 安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，sddm就是这样的一款管理器。执行以下命令来安装sddm： 1sudo pacman -S sddm 设置开机启动sddm服务使用systemctl命令：sudo systemctl enable sddm来启用sddm开机自启设置lightdm开机自启同理 配置网络到现在我们已经安装好了桌面环境，但是还有一件事情需要我们提前设置一下。由于我们之前使用的一直都是netctl这个自带的网络服务，而桌面环境使用的是NetworkManager这个网络服务，所以我们需要禁用netctl并启用NetworkManager： 12sudo systemctl disable netctlsudo systemctl enable NetworkManager 同时你需要安装工具栏工具来显示网络设置图标： 1sudo pacman -S network-manager-applet 安装完成重启之后就可以尽情地enjoy了 下载编译安装最新最鬼酷的Linux内核注：为了完成之后的Patch任务，我这里就下载5.3版本的内核。下载最新版的内核同理。 下载内核首先，我们当然要先去把内核下载到虚拟机中 由于某些特殊原因，国内访问国外的Kernel.org速度偏慢那么就需要从国内的开源镜像站去下载内核地址：https://mirrors.tuna.tsinghua.edu.cn/kernel/ 然后根据自己的喜好找到自己需要的内核，使用wget命令下载，并将其解压 123wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.3.tar.xzxz -d linux-5.3.tar.xztar -xvf linux-5.3.tar 编译内核进入解压好的源码的根目录下，如果需要自定义选项，就执行以下命令： 1make menuconfig 会进入一个菜单，让你定制你自己的内核。当然，你也可以使用缺省配置，执行以下命令: 1zcat /proc/config.gz &gt; .config #将当前内核的配置文件复制到此处 并且不要忘记在 General Setup —&gt; 选项中或者复制来的config文件的”CONFIG_LOCALVERSION”一行的值来修改内核版本，这样可以避免编译的内核覆盖当前内核文件。这样内核已经配置好了，下面就可以开始编译了编译命令： 1make -j 线程数 安装内核模块1sudo make modules_install ##把所有编译好的模块安装到正确的主目录/lib/modules下 该命令将编译好的模块拷贝至 /lib/modules/-，例如 /lib/modules/3.18.28-ARCH。这样，这些模块和那些被你电脑上其他内核使用的模块就独立开来。 拷贝内核到 /boot 目录内核编译完成后会生成内核的 bzImage (big zImage) 文件，根据系统架构，将此文件复制到 /boot 目录，以 5.3 内核为例： 32-bit (i686) kernel: 1sudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-linux53 64-bit (x86_64) kernel: 1sudo cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-linux53 制作初始化内存盘自动生成复制和修改 mkinitcpio preset，就能用官方内核一样的方式生成自定义内核的 initramfs 镜像。下面例子中将已有的 preset 复制到 linux53 要使用的文件: 1sudo cp /etc/mkinitcpio.d/linux.preset /etc/mkinitcpio.d/linux53.preset 针对定制内核编辑和修改此文件， 1sudo vim /etc/mkinitcpio.d/linux53.preset ALL_kver= 应该和定制内核匹配： 1234567/etc/mkinitcpio.d/linux53.preset...ALL_kver=&quot;/boot/vmlinuz-linux53&quot;...default_image=&quot;/boot/initramfs-linux53.img&quot;...fallback_image=&quot;/boot/initramfs-linux53-fallback.img&quot; 用官方内核一样的方式生成 initramfs 镜像： 1sudo mkinitcpio -p linux53 拷贝System.map将 System.map 复制到 /boot, 然后创建 /boot/System.map 软链接到 /boot/System.map-YourKernelName: 12sudo cp System.map /boot/System.map-YourKernelNamesudo ln -sf /boot/System.map-YourKernelName /boot/System.map 更新grub配置信息使用命令 1grub-mkconfig -o /boot/grub/grub.cfg 来把我们刚刚配置好的内核添加到grub的启动配置中 然后reboot就可以享受最新（更老）的kernel了！ Patch自己的内核说实话，一开始看到要patch自己的内核，能够给出现象证明你的patch有效，我的心就拔凉拔凉的Kernel里那么多东西，我咋看的过来哪些能改哪些不能改，改了会有什么效果啊我透……后来转念一想，Patch最显著的现象不就是版本号升级了吗？！于是就有了之前反向升级最新内核的操作 下载Patch地址：https://mirrors.tuna.tsinghua.edu.cn/kernel/依旧是打开那个熟悉的地址，然后找到自己对应的patch包，用wget命令下载即可。注意：如果你想跨版本升级，例如说现在是5.3，想要升级到5.3.8的内核，可以一步到位从5.3这个大版本用patch-5.3.8升级至5.3.8 解压Patch使用命令： 1xz -d patch-5.3.1.xz 即可 安装Patch将解压出的Patch文件放在你想要打Patch的源代码文件夹的Kernel目录下 重要 为确保内核树绝对干净，执行以下命令 1make clean &amp;&amp; make mrproper 注意：由于patch文件中的文件路径包含了它所基于的内核源文件目录的名字(或者像是”a/“和”b/“之类的其它名字)。这很可能和你本地机器上的内核源代码目录的名字不匹配。你应该切换到你的内核源代码目录，并且在打补丁的时候去掉patch中文件名字路径的第一个分量(patch命令的-p1参数可以完成这个任务)。因此我们在Kernel目录下直接执行以下命令： 1patch -p1 &lt; ./patch-5.3.8.patch 其余的patch文件依样画瓢即可 编译Patch后的内核以及之后的步骤这个就和之前的差不多，就不再叙说了~ 制作自己的Patch文件并打Patch。经过某李姓学长的提醒，我明白了这个任务其实是要我们自己动手修改kernel内核。那么最简单的修改方法就是添加一个系统调用。 修改源程序，增加系统调用实现假设你现在已经下好了kernel源文件并解压。在解压出的源代码文件夹内执行以下命令： 1vim ./kernel/sys.c 在sys.c的末尾加入以下函数 123asmlinkage void sys_helloworld(void)&#123; printk(“hello world”);&#125; 修改头文件，增加系统调用声明注意：我在修改之后的系统调用后才发现520已经被占，因此之后图里所有的520都被改成了436，也推荐大家以后新增调用时先去看看syscall_64.tbl文件的内容。使用命令 1vim ./include/uapi/asm-generic/unistd.h 来添加系统调用的声明在文件的最末尾处添加如下代码：再使用命令 1vim ./include/linux/syscalls.h 在文件的最末尾处添加如下代码： 注册系统调用进入/arch/x86/entry/syscalls目录可以看到以下内容：32位系统就添加到syscall_32.tbl，64位就修改syscall_64.tbl我这里是64位，因此我应该修改syscall_64.tbl。按着顺序往下添加即可，中间使用Tab键分隔。如图所示： 生成Patch文件在这里，我就假设你已经修改好了文件。比如基于kernel内核 做了修改，修改前的内容放在文件夹kernel下，修改后的内容放在文件夹kernel_new下，并且两个目录在同级的文件夹里，那么制作patch文件的命令为 1diff -Naur kernel/ kernel_new/ &gt; new.patch 然后接下来的步骤和上面的 安装Patch 部分相同，不再赘述。 最终结果 几个踩坑的点一开始只安装了Base包网上的远古教程指导我说安装了Base包就行了，然而Arch Linux似乎把Linux内核从Base包当中分离了出来，所以一开始只安装Base包导致grub找不到内核一直引导失败。这个惨痛的经历告诉我们，以后不管装什么，都要看官方wiki，避免踩坑。 在编译内核时config文件没有配置好一开始直接用make defconfig命令，编译了一个几乎啥都不带的内核。之后才明白如果想沿用当前系统设置应该用zcat /proc/config.gz &gt; .config命令。还好有 善意的提醒 不然又得从头再来。 在Patch时报错，提示patch rejected这是因为我用了tuna的patch包，这个包是用来一步到位从5.3升级到5.3.8的，而要想从5.3.7升级到5.3.8，则需要从 https://www.kernel.org 上下载Inc.patch包。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Zam-0703.github.io/tags/Linux/"},{"name":"syscall","slug":"syscall","permalink":"http://Zam-0703.github.io/tags/syscall/"},{"name":"Patch","slug":"Patch","permalink":"http://Zam-0703.github.io/tags/Patch/"}]},{"title":"使用VMware搭建小型局域网","slug":"使用VMware搭建小型局域网","date":"2019-10-26T09:25:11.000Z","updated":"2019-10-26T09:28:16.801Z","comments":true,"path":"2019/10/26/使用VMware搭建小型局域网/","link":"","permalink":"http://Zam-0703.github.io/2019/10/26/使用VMware搭建小型局域网/","excerpt":"","text":"前期准备安装VMware下载地址：https://www.nocmd.com/740.html安装无脑下一步即可 安装Ubuntu镜像下载地址：https://cn.ubuntu.com/download最新版的VMware支持Ubuntu的简易安装，所以在配置时直接填好主机名用户名密码就可以愉快的食用Ubuntu了 配置局域网在虚拟网络编辑器中配置网关以及网段在VMware主页面 编辑–》虚拟网络编辑器单击箭头所指按钮，给编辑器提升权限以更改设置 我们使用NAT模式，所以选择VMnet8。（记住这个名称，稍后还会用到）不勾选【使用本地DHCP】服务这个复选框，因为我们要求固定IP，DHCP是动态分配IP的。首先，我们将子网IP设置成我们需要的IP地址所在的网段，即192.168.188.0，如图所示： 点击NAT设置。我们将网关IP设置成我们需要的IP地址192.168.188.2，如图所示： 然后再选择Host-only模式的网卡VMnet1同理，不勾选【使用本地DHCP】服务这个复选框。首先，我们将子网IP设置成我们需要的IP地址所在的网段，即192.168.188.0，如图所示： 在控制面板中配置虚拟网卡IP在VMware中更改了虚拟网络之后，我们还需要去宿主机的网络控制面板中更改网络适配器，才能让我们的虚拟主机能够正常的上网在控制面版中找到VMware Network Adapter VMnet8，也就是我们之前记住的使用NAT模式的那张网卡双击图标后，在弹出的窗口中单击属性–&gt;双击Internet协议版本4将弹出的窗口设置成如图所示的亚子： 到此，配置局域网的工作暂告一段落打开三台虚拟机，进行最后的指向操作对于充当路由器和DNS服务器的虚拟机VM1首先打开VM1的IP转发功能： 1nano /etc/sysctl.conf 把net.ipv4.ip_forward = 0改成1，或者是将注释符删去，如图所示： ![更改VM1 IP转发.png](https://cdn.jsdelivr.net/gh/Zam-0703/Pictures/img/更改VM1 IP转发.png) 使用sysctl -p命令使改动生效。 然后再将用于与VM2和VM3通信的网卡手动分配下IP注意，此时一定要分清哪张网卡是工作在NAT模式下，用于与宿主机通信的；哪张是工作在Host-Only模式下，用于与两个虚拟机通信的。所以在开始更改网卡配置之前，需要先执行ifconfig确定网卡的具体信息 从ubuntu从17.10开始，已经不再在/etc/network/interfaces里配置IP，即使配置了也不会生效，而是改成netplan方式 ，配置写在/etc/netplan/文件夹里或者类似名称的yaml文件里。因此，我们应先查看/etc/netplan文件夹下的文件，来判断我们需要修改的是什么文件 12cd /etc/netplanls 从而确定下一步的命令为：sudo nano 01-network-manager-all.yaml 经过我的甄别，确定网卡ens38是那张工作在Host-Only模式下的网卡、ens33是那张工作在NAT模式下的网卡，于是乎按照任务要求，如图所示编辑两张网卡的配置： 之后运行命令netplan apply来应用这一设置 到这里，对VM1的操作就告一段落 对于VM2和VM3照葫芦画瓢，首先执行ifconfig确定网卡的具体信息，再更改netplan的配置信息。具体操作过程与VM1大差不差，就直接放按着任务要求配置好的netplan了。 然后就可以实现VM1,VM2,VM3三台机器的互ping 对VM2与VM3进行NAT转换但是，经过上述的操作，VM2与VM3却不能ping通VM1的网关和公网。有句话说得好，不能连公网的主机和咸鱼没啥区别。因此，我们需要用iptables实现NAT转换，使得B和C能够访问(ping)A的网关和公网。 具体的NAT操作过程示例，可以参照这篇blog中SNAT部分，再根据具体的环境配置iptables的参数：https://www.zsythink.net/archives/1764 在此次任务中，命令为： 1sudo iptables -t nat -A POSTROUTING -s 10.1.2.0/24 -j SNAT --to-source 192.168.188.128 执行之后就可以在VM2与VM3两台“内网”机器中愉快的连上公网了~ 遇到的问题 1.netplan apply时遇到格式错误 错误原因：YAML文件对格式的要求非常严格。在冒号后少打一个空格都会导致文件读取错误。 解决方法：重新检查一遍YAML文件格式是否正确，有没有少打空格。并在之后多多注意格式问题 2.在执行命令中多次出现Permission Denied 错误原因：因为这次任务中涉及到对网络配置等系统关键文件进行修改的操作，所以需要su权限才能进行命令的执行。 解决方法：在之后的命令行输入时，涉及到对系统文件、系统环境的修改时要记得加上sudo。 不能因为sudo麻烦而直接使用root用户登录。不然没准哪天你就会不小心删库跑路 Task Over然而还差12h工时……绝了","categories":[],"tags":[{"name":"Dian CyberSecurity Team","slug":"Dian-CyberSecurity-Team","permalink":"http://Zam-0703.github.io/tags/Dian-CyberSecurity-Team/"},{"name":"Network","slug":"Network","permalink":"http://Zam-0703.github.io/tags/Network/"}]},{"title":"AST-Task2","slug":"AST-Task2","date":"2019-10-16T04:09:55.000Z","updated":"2019-10-25T04:22:34.136Z","comments":true,"path":"2019/10/16/AST-Task2/","link":"","permalink":"http://Zam-0703.github.io/2019/10/16/AST-Task2/","excerpt":"","text":"注意，本文编译环境为Visual Studio 2019 on Windows 10 1903 X64 几个练手题1.编程实现：用户给定一个整数，将该整数逆置之后输出。（如：输入123，输出321）。限制条件a.给定整数，不要用字符串来完成。b.尽可能使时间复杂度小。c.要求能够完成214748364792这个数字的逆置。 程序源码1234567891011121314#include&lt;stdio.h&gt;int main() &#123; long long int input; scanf_s(\"%lld\", &amp;input); long long int output = 0, digit; while (input &gt; 0) &#123; digit = input % 10;//取当前最末位数 output = output * 10 + digit;//将当前的最末位数加到待输出结果的最后一位 input /= 10; &#125; printf(\"%lld\", output); return 0;&#125; ###运行结果 2.编程实现：给定一串任意字符串。要求，将其中的所有整数提取出来并存入整数数组给定样例1023fase415#145# 程序源码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main(void)&#123; char str[1000]; int a[100]; int p, q; int i = 0, r = 0,count = 0;//i用于控制输出，r用于控制字符串内查找,count用于计算字符串内数字个数 gets(str); r = 0; while (1) &#123; while (str[r] &amp;&amp; (str[r]&lt;'0' || str[r]&gt;'9')) r++; //跳过字符串中非数字部分 if (str[r]) &#123; p = r; //p指向数字子串开头 q = r + 1; //q寻找数字串结尾 a[i] = str[r] - '0';//将字符串中的0变为数字0 while (str[q] &gt;= '0' &amp;&amp; str[q] &lt;= '9') &#123; a[i] = 10 * a[i] + (str[q] - '0');//计算数字 q++; &#125; count++; r = q; //设定新起点 i++; &#125; else break; &#125; for (i = 0; i &lt; count; i++) printf(\"%d \", a[i]); printf(\"\\n\"); return 0;&#125; 运行结果 3.编程实现：给定一串任意字符串。要求，将其中的所有数字提取出来并存入double数组。给定样例10.23fase4.15#14.5# 程序源码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; char str[1000], num[1000]; double a[100]; int p, q; int i = 0, r = 0,count = 0;//i用于控制循环，r用于控制字符串内查找,count用于计算字符串内数字个数 gets(str); r = 0; while (1) &#123; while (str[r] &amp;&amp; (str[r]&lt;'0' || str[r]&gt;'9')) &#123;//查找数字字串开头部分 r++; &#125; if (str[r]) &#123; p = r; //p指向数字子串开头 q = r + 1; //q寻找数字串结尾 while ((str[q] &gt;= '0' &amp;&amp; str[q] &lt;= '9')||str[q]=='.')&#123; q++; &#125; for (i = 0; i &lt; q-p; i++) &#123;//将数字字串转存到新字符串中，用于后续转化输出 num[i] = str[p + i]; &#125; num[i] = '\\0'; a[count] = atof(num); count++; r = q; //设定新起点 &#125; else break; &#125; for (i = 0; i &lt; count; i++) printf(\"%lf \", a[i]); printf(\"\\n\"); return 0;&#125; 运行结果 几个烧脑题多级指针：观察下列代码，思考并解释程序运行结果1程序代码及解释12345678910111213#include &lt;stdio.h&gt;int main()&#123; char * c[] = &#123; \"ENTER\", \"NEW\", \"POINT\", \"FIRST\" &#125;;//定义了四个指针c[0]-c[3]分别指向四个字符串 char** cp[] = &#123; c + 3, c + 2, c + 1, c &#125;;//定义了一个二级指针数组，其中的cp[0]-cp[3]分别依次对应c[3]-c[0] char*** cpp = cp;//定义了一个三级指针，指向二级指针数组的第一个元素cp[0]，此时cpp就相当于c[3] printf(\"%s\\n\", ** ++cpp);//** cpp经过间接引用运算后相当于是指针cp，指针cp自增后指向的是指针数组cp[]中的第二个元素,也即是c[2] printf(\"%s\\n\", * --* ++cpp + 3);//首先对指针cpp作了自增操作，使得cpp指向cp[2],此时cpp中的地址为c+1，再通过自减符使得指针 * cpp即cp[2] (注意不是cpp)的地址变为c，这时候*--* ++cpp相当于指向了一个字符数组&#123;'E','N','T','E','R'&#125;的首地址。+3的操作等价于在这个字符数组的首地址的基础上再右移三个地址，指向了第二个E，然后通过printf将第二个E和之后的所有剩余字符全部打印。 printf(\"%s\\n\", * cpp[-2] + 3);//经过了上一条语句后，cpp指向cp[2],那么cpp[-2]指向cp[0]（注意，此时cpp内存储的地址并没有改变）,即c[3]此时的*cpp[-2]就相当于指向了一个字符数组&#123;'F','I','R','S','T'&#125;的首地址。+3的操作等价于在这个字符数组的首地址的基础上再右移三个地址，指向了S，然后通过printf将S和之后的所有剩余字符全部打印。 printf(\"%s\\n\", * cpp[-1][-1] + 1);//同上理，此时cpp指向cp[2],cpp[-1]就会指向cp[1]，即c[2],那么cpp[-1][-1]就相当于指向c[1],即一个字符数组&#123;'N','E','W'&#125;的首地址。+1的操作等价于在这个字符数组的首地址的基础上再右移1个地址，指向了E，然后通过printf将E和之后的所有剩余字符全部打印。 system(\"pause\"); return 0;&#125; 上机验证 2程序代码1234567891011121314151617#include &lt;stdio.h&gt;struct Test&#123; int Num; char* pcName; short sDate; char cha[2]; short sBa[4];&#125;*p;int main()&#123; p = 0x100000; printf(\"%p\\n\", p + 0x1);//输出00100014 printf(\"%p\\n\", (unsigned long)p + 0x1);//输出00100001 printf(\"%p\\n\", (unsigned int*)p + 0x1);//输出00100004 return 0;&#125; 解释首先要明确，指针与整数的加减法公式为 p = p +/- sizeof（type * p） 第一行输出00100014的原因是结构体Test的存储空间大小为sizeof(int) + sizeof(char* ) + sizeof(short) + sizeof(char)* 2 + sizeof(short)* 4 = 20,并且指针的地址是以十六进制数存放的，因此p + 0x1就相当于指针p向后移动了sizeof(Test)的内存大小，因此输出的内存地址比1000000大20，为00100014。 第二行输出001000001的原因是(unsigned long)语句将* p转换成了整数类型，因此此时做的只是普通的整数与整数之间的加减法。 第三行输出00100004的原因是 (unsigned int)语句将Test 类型的p指针转换成了int * 类型，根据公式此时sizeof(int*) = 4,因此输出00100004。 上机验证 3程序代码#include &lt;stdio.h&gt; 12345678int main()&#123; int a[4] = &#123; 1, 2, 3, 4 &#125;; int * ptr1 = (int * )(&amp;a + 1); int * ptr2 = (int * )((int)a + 1); printf(\"%x\\n%x\\n\", ptr1[-1], * ptr2);\\\\输出4 2000000 return 0;&#125; 解释首先，&amp;a指的是取数组a的地址，而&amp;a + 1指的是加上一个int a[4]的长度，即sizeof(int) * 4=16字节，所以ptr1指向数组a后面的内存单元，如果用下标表示就是a[5] 由指针与整数的加减法公式p = p +/- sizeof（type * p，ptr1[-1]表示ptr1指向的地址再减去sizeof(int * )，即指向a[4]，所以第一个%x输出对应的是0x4. (int)a+1的值就是元素a[0]的第二个字节的地址，然后把这个地址强制转化为（int)类型赋给ptr2，也就是说ptr2的值应该为元素a[0]的第二个字节开始的连续4个Byte的内容。 不过要想理解为什么输出了2000000，就要首先明白数字在数组中是怎么被存储的： 每个元素具体存储方式，取决于CPU。 有两种：1、小端(Little Endian)：将低序字节存储在起始地址（低位编址）, 地址低位存储值的低位，地址高位存储值的高位 。目前大多数CPU是按照这种方式存储的，包括intel和移动端最常见的arm。比如4字节整型值为0x12345678的情况，那么在内存中会存储为：0x78 0x56 0x34 0x122、大端(Big Endian)：与小端相反， 将高序字节存储在起始地址（高位编址），地址低位存储值的高位,地址高位存储值的低位。之前的例子在大端情况下存储为：0x12 0x34 0x56 0x78 因此，a[0]在内存中被存储为0x01 0x00 0x00 0x00,a[1]在内存中被存储为0x02 0x00 0x00 0x00，此时ptr2所指向的内存区域的值就是0x00 0x00 0x00 0x02 但是，在printf进行输出时，内存中的值是自右而左地被读出的，因此输出的值应该是0x02000000 上机验证 其余部分就先咕为敬了，告辞有空再补好了我胡汉三又回来了 malloc函数的使用在C语言中，malloc是动态内存分配函数。 它的原型声明在stdlib.h头文件中： 1void *malloc(unsigned int num_bytes); num_bytes 是无符号整型，用于表示分配的字节数。这个函数的返回值：如果分配成功则返回指向被分配内存的指针void* (此存储区中的初始值不确定)，否则返回空指针NULL。void* 表示未确定类型的指针，void * 可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者…）这个函数的功能很简单：就是分配长度为num_bytes字节的内存块。注意：由于C语言中缺少内存回收机制，所以当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，例如说统一为4的倍数，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此在使用是我们应要进行类型转换。example: 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//malloc()函数被包含在stdlib.h里面int main(void)&#123;char*a=NULL; //声明一个指向a的char*类型的指针a=(char*)malloc(100*sizeof(char));//使用malloc分配内存的首地址，然后赋值给aif(!a)//如果malloc失败，可以得到一些log&#123;perror(\"malloc\");return-1;&#125;sprintf(a,\"%s\",\"HelloWorld\\n\");//\"HelloWorld\\n\"写入a指向的地址printf(\"%s\\n\",a);//输出上边写入a的字符串free(a);//释放掉使用的内存地址return 0;//例2有无内存泄露？&#125; 而且，作为一名合格的码农，我们应当对一些特殊情况进行特殊处理，如这里的malloc函数若调用失败，则直接让程序退出，而不是让其运行下去，否则可能会造成更大的bug，而且也不利于我们根据返回值进行debug。 结构体指针-&gt;的使用除了我们通过结构体变量名.成员名的方式引用结构体变量中的成员，我们还可以使用指针。要想学会-&gt;这种指针的使用，首先我们就要学会一般的结构体指针使用方式：(* 指针变量名).成员名这个指针变量定义成什么类型呢？只能定义成结构体类型，且指向什么结构体类型的结构体变量，就要定义成什么样的结构体类型。比如指向 struct STUDENT 类型的结构体变量，那么指针变量就一定要定义成 struct STUDENT* 类型。example: 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;# include &lt;string.h&gt;struct AGE&#123; int year; int month; int day;&#125;;struct STUDENT&#123; char name[20]; //姓名 int num; //学号 struct AGE birthday; //生日 float score; //分数&#125;;int main(void)&#123; struct STUDENT student1; /* 用struct STUDENT结构体类型定义结构体变量student1*/ struct STUDENT * p = NULL; /* 定义一个struct STUDENT结构体类型的指针变量p*/ p = &amp;student1; /* p指向结构体变量student1的首地址, 即第一个成员的地址*/ strcpy((* p).name, \"小明\"); //(* p).name等价于student1.name (* p).birthday.year = 1989; (* p).birthday.month = 3; (* p).birthday.day = 29; (* p).num = 1207041; (* p).score = 100; printf(\"name : %s\\n\", (* p).name); //(* p).name不能写成p,即使p指向的是student1.name的地址。 printf(\"birthday : %d-%d-%d\\n\", (* p).birthday.year, (* p).birthday.month, (* p).birthday.day); printf(\"num : %d\\n\", (* p).num); printf(\"score : %.1f\\n\", (* p).score); return 0;&#125; 输出结果： 1234name : 小明birthday : 1989-3-29num : 1207041score : 100.0 注意，* p 两边的括号不可省略，因为成员运算符“.”的优先级高于指针运算符“ * ”，所以如果 * p 两边的括号省略的话，那么 * p.num 就等价于 * (p.num) 了。从该程序也可以看出：因为指针变量 p 指向的是结构体变量 student1 第一个成员的地址，即字符数组 name 的首地址，所以 p 和 (* p).name 是等价的。但是，“等价”仅仅是说它们表示的是同一个内存单元的地址，但它们的类型是不同的。指针变量 p 是 struct STUDENT* 型的，而 (* p).name 是 char* 型的。所以在 strcpy 中不能将 (* p).name 改成 p。用 %s 进行输入或输出时，输入参数或输出参数也只能写成 (* p).name 而不能写成 p。同样，虽然 &amp;student1 和 student1.name 表示的是同一个内存单元的地址，但它们的类型是不同的。&amp;student1 是 struct STUDENT* 型的，而 student1.name 是 char* 型的，所以在对 p 进行初始化时，“p=&amp;student1；”不能写成“p=student1.name”。因为 p 是 struct STUDENT* 型的，所以不能将 char* 型的 student1.name 赋给 p。C语言是一门强数据类型的语言，就在这里体现的淋漓尽致。此外,为了使用的方便和直观，我们可以直接用指针变量名-&gt;成员名来代替。p-&gt;num 的含义是：指针变量 p 所指向的结构体变量中的 num 成员。p-&gt;num 最终代表的就是 num 这个成员中的内容。下面，我们可以用指针变量名-&gt;成员名的形式对我们刚刚的代码进行修改： 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;# include &lt;string.h&gt;struct AGE&#123; int year; int month; int day;&#125;;struct STUDENT&#123; char name[20]; //姓名 int num; //学号 struct AGE birthday; /* 用struct AGE结构体类型定义结构体变量birthday, 生日*/ float score; //分数&#125;;int main(void)&#123; struct STUDENT student1; /* 用struct STUDENT结构体类型定义结构体变量student1*/ struct STUDENT * p = NULL; /* 定义struct STUDENT结构体类型的指针变量p*/ p = &amp;student1; /* p指向结构体变量student1的首地址, 即第一项的地址*/ strcpy(p-&gt;name, \"小明\"); p-&gt;birthday.year = 1989; p-&gt;birthday.month = 3; p-&gt;birthday.day = 29; p-&gt;num = 1207041; p-&gt;score = 100; printf(\"name : %s\\n\", p-&gt;name); //p-&gt;name不能写成p printf(\"birthday : %d-%d-%d\\n\", p-&gt;birthday.year, p-&gt;birthday.month, p-&gt;birthday.day); printf(\"num : %d\\n\", p-&gt;num); printf(\"score : %.1f\\n\", p-&gt;score); return 0;&#125; 输出同上。 链表的基本概念及简单使用学了三个月，终于学到了第一种数据结构类型：链表。那么，链表它到底是个啥？链表，链表，首先它得是个线性表。根据《数据结构》书中介绍，一个线性表是n个数据元素的有限序列，它的长度可根据需要增长或缩短，还有一系列对线性表的操作。线性表可分为顺序存储结构和链式存储结构两种。那么今天所学习的链表，全称就叫链式存储结构线性表。线性链表可分为单链表，循环链表，双链表。 线性表特点是用一组任意的存储单元存储线性表的数据元素，同时还存储一个指向后继信息的信息，这两部分信息组成为结点。结点包含两部分数据域和指针域。指针域存储信息成为指针或链。链表中只包含一个指针域，故称为单链表。 下面通过c语言实现单链表的基本操作： 1234567891011#define MAXSIZE 20#define OK 1#define ERROR 0typedef int ElemType;typedef int Status;//上述是一些重命名和宏定义//单链表的存储结构typedef struct LNode&#123; ElemType data; //数据域 struct Node * next; //指针域&#125;LNode，*LinkList; 读取链表第i个元素的数据： 123456789101112131415Status GetElem(LinkList L, int i, ElemType *e)&#123; LinkList p; int j; p = L-&gt;next; j=1; while(p &amp;&amp; j&lt;i)&#123; p = p-&gt;next; ++j; &#125; if(!p || j&gt;i)&#123; return ERROR; &#125; * e = p-&gt;data; return OK;&#125; 在带头结点的链表L的第i个位置之前插入元素e: 12345678910111213141516171819Status ListInsert(LinkList &amp;L, int i, ElemType e)&#123; LNode p; int j; p = L; j=0; while(p &amp;&amp; j&lt;i-1)&#123; p = p-&gt;next; ++j; &#125; if(!p || j&gt;i-1)&#123; return ERROR; &#125; LinkList s; s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next =s; return OK;&#125; 在带头结点的链表L，删除第i个位置的元素，并由e返回其值: 12345678910111213141516171819Status ListDelete(LinkList &amp;L, int i, ElemType &amp;e)&#123; LNode p; int j; p = L; j=0; while(p &amp;&amp; j&lt;i-1)&#123; p = p-&gt;next; ++j; &#125; if(!(p-&gt;next) || j&gt;i-1)&#123; return ERROR; &#125; LinkList q; q = p-&gt;next; p = q-&gt;next; e = q-&gt;data; free(q); return OK;&#125; 循环链表是另外一种存储形式的链式存储结构，特点是表中最后一个结点的指针域指向头结点，与单链表比较相像，故不再赘述。双向链表：是指针域指向前驱结点和后继结点。存储结构为： 12345typedef struct DuLNode&#123; ElemType data; struct DuLNode * prior; struct DuLNode * next;&#125;DuLNode, * DuLinkList; 链表延伸1.编程创建一个单链表。可不断读取用户输入的整数并存储进链表里。并在最后将链表里面的数据打印出来。2.编程实现：将上述任务中已经创建完毕的单链表逆置（如将1-&gt;2-&gt;3-&gt;4-&gt;null逆置为4-&gt;3-&gt;2-&gt;1-&gt;） 程序代码简明起见，我将两个任务写在一个程序里了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SUCCESS 10000#define FAILURE 10001typedef int ElemType;typedef struct Node&#123; ElemType data; struct Node* next;&#125;Link;int InitLink(Link** l)//初始化链表&#123; if (NULL == l) &#123; return FAILURE; &#125; * l = (Link*)malloc(sizeof(Link)); if (NULL == * l) &#123; return FAILURE; &#125; (* l)-&gt;next = NULL; (* l)-&gt;data = 0; return SUCCESS;&#125;int InsertLink(Link* l, int place, ElemType e)//插入链表&#123; int k = 1; if (NULL == l) &#123; return FAILURE; &#125; if (place &gt; l-&gt;data + 1 || place &lt;= 0) &#123; return FAILURE; &#125; Link* head = l; while (k &lt; place) &#123; k++; l = l-&gt;next; &#125; Link* tmp = (Link*)malloc(sizeof(Link)); if (NULL == tmp) &#123; return FAILURE; &#125; tmp-&gt;next = l-&gt;next; l-&gt;next = tmp; tmp-&gt;data = e; head-&gt;data++; return SUCCESS;&#125;int TraverseLink(Link* l)//遍历链表&#123; int length; if (NULL == l) &#123; return FAILURE; &#125; length = l-&gt;data; while (length &gt; 0) &#123; length--; l = l-&gt;next; printf(\"%d \", l-&gt;data); &#125; return SUCCESS;&#125;void ReverseList(Link* L)//逆置链表&#123; Link* curnode = L-&gt;next; //当前节点，指向表头 Link* temp = curnode-&gt;next; //临时节点 curnode-&gt;next = NULL; L-&gt;next = curnode; while (temp != NULL) &#123; curnode = temp; temp = curnode-&gt;next; curnode-&gt;next = L-&gt;next; L-&gt;next = curnode; &#125;&#125;int SortInsert(Link* l, ElemType e)&#123; int flag = 1; int length, place; if (NULL == l) &#123; return FAILURE; &#125; Link* head = l; length = l-&gt;data; l = l-&gt;next; place = 0; if (0 == length)&#123; InsertLink(head, place + 1, e); &#125; else&#123; while (place &lt; length) &#123; if (e &lt; l-&gt;data) &#123; InsertLink(head, place + 1, e); flag = 0; break; &#125; else &#123; l = l-&gt;next; place++; &#125; &#125; if (1 == flag) &#123; InsertLink(head, length + 1, e); &#125; &#125; return SUCCESS;&#125;int main()&#123; Link* list; ElemType e; InitLink(&amp;list); printf(\"Please input numbers,input other character to end!\\n\"); while(scanf_s(\"%d\",&amp;e) == 1) &#123; printf(\"Please input numbers,input other character to end!\\n\"); SortInsert(list, e); // printf(\"Length = %d\\n\", list-&gt;data); &#125; printf(\"The output is :\"); TraverseLink(list); ReverseList(list); printf(\"\\nThe reverse List output is: \"); TraverseLink(list); return 0;&#125; 程序运行结果 Leetcode都不会做好难啊我太菜了","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://Zam-0703.github.io/tags/C/"},{"name":"Learning","slug":"Learning","permalink":"http://Zam-0703.github.io/tags/Learning/"},{"name":"Function&Pointer","slug":"Function-Pointer","permalink":"http://Zam-0703.github.io/tags/Function-Pointer/"}]},{"title":"AST Task1","slug":"AST-Task1","date":"2019-10-05T08:15:00.000Z","updated":"2019-10-07T03:44:56.555Z","comments":true,"path":"2019/10/05/AST-Task1/","link":"","permalink":"http://Zam-0703.github.io/2019/10/05/AST-Task1/","excerpt":"","text":"学习内容0x01 C语言中的数据类型C语言中的常用数据类型 C语言中整型与字符型数据首先需要注意的是： 无符号(unsigned)整型数据与一般有符号整型数据的区别。 整型有无符号（unsigned）和有符号（signed）两种类型，在默认情况下声明的整型变量都是有符号的类型（char有点特别，需要根据具体编译环境确定），如果需声明无符号类型的话就需要在类型前加上unsigned。 无符号整型和有符号整型的区别就是无符号类型可以存放的正数范围比有符号整型中的范围大一倍，因为有符号类型将最高位储存符号，而无符号类型全都储存数字。 并且： 在C/C++语言中，int和long int的所占的字节数与编译环境有关。 C语言标准是这样规定的：int最少16位（2字节），long不能比int短，short不能比int长，具体位长由编译器开发商根据各种情况自己决定。 在老式的16位编译系统上，short、int、long普遍的长度是2字节、2字节、4字节。在32位编译系统x86处理器上，short、int、long普遍的长度是2字节、4字节、4字节。int占四字节，与long相同。在64位编译系统x64处理器上：short占两字节，int占四字节，long占8字节，long数据范围变为：-2^63~2^63-1 由此可见int类型的数据长度一般是机器位长。在16位编译系统中int为16位，两个字节；32位编译系统中int为32位，4个字节；但是在64位编译系统中为了兼容32位编译系统，64位编译系统的int也是4字节。 现在常用的编译器多认为int和long int相同，均为4字节，short为2字节，char为1字节。如果只输入int，它有可能是以上三种形式中的一种。 那么如何得到某个类型在特定平台上的准确大小？ 为了得到某个类型或某个变量在特定平台上的准确大小，我们可以使用 sizeof 运算符。通过表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小： 123456789#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int main()&#123; printf(\"int 存储大小 : %lu \\n\", sizeof(int)); return 0;&#125; C语言中的void类型void 类型指定没有可用的值。它通常用于以下三种情况下： 第一种：函数返回为空C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 第二种：函数参数为空C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数void *malloc( size_t size );返回指向 void 的指针，可以转换为任何数据类型。 C语言中的bool（布尔）类型在此之前的C语言中，使用整型int来表示真假。在输入时：使用非零值表示真；零值表示假。在输出时：真的值是1，假的值是0。 现在，出现了布尔型变量。_Bool类型长度为1，只能取值范围为0或1。将任意非零值赋值给_Bool类型，都会先转换为1，表示真。将零值赋值给_Bool类型，结果为0，表示假。 有如下example program： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; _Bool bool1 = 1; _Bool bool2 = 2; /* 非零值，bool2的值为1 */ _Bool bool3 = 0; _Bool bool4 = -1; /* 非零值，bool4的值为1 */ printf(&quot;bool1==%d, \\n&quot;, bool1); printf(&quot;bool2==%d, \\n&quot;, bool2); printf(&quot;bool3==%d, \\n&quot;, bool3); printf(&quot;bool4==%d, \\n&quot;, bool4); printf(&quot;sizeof(_Bool) == %d \\n&quot;, sizeof(_Bool)); return 0;&#125; 运行结果如下： 12345bool1==1,bool2==1,bool3==0,bool4==1,sizeof(_Bool) == 1 C语言中的数组类型所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 C语言中的指针类型每个变量都被存放在从某个内存地址（以字节为单位）开始的若干个字节中。“指针”，也称作“指针变量”，大小为4个字节（或8个字节）的变量，其内容代表一个内存地址。通过指针，我们能够对该指针指向的内存区域进行读写。如果把内存的每个字节都想像成宾馆的一个房间，那么内存地址相当于就是房间号，而指针里存放的，就是房间号。 T * p ; // T 可以是任何类型的名字，比如 int, double ,char 等等。p 的类型: T * p 的类型： T通过表达式 * p，可以读写从地址 p 开始的 sizeof(T)个字节 p 等价于存放在地址p处的一个 T 类型的变量 意思为间接引用运算符sizeof(T*) 4字节（64位计算机上可能8字节） 有了指针，就有了自由访问内存空间的手段：不需要通过变量，就能对内存直接进行操作。通过指针，程序能访问的内存区域就不仅限于变量所占据的数据区域。在C中，用指针p指向a的地址,然后对p进行加减操作，p就能指向a后面或前面的内存区域，通过p也就能访问这些内存区域。 C语言中的字符串类型C语言中，字符串有两种形式： 用双引号括起来的字符串常量， 如”CHINA” ， “C program “。 存放于字符数组中，以‘\\0’字符（ASCII码为0)结尾 存放于字符数组中的字符串常量占据内存的字节数等于字符串中字符数目加1，多出来的是结尾字符‘\\0’。但是字符串的长度不包含’\\0’用char数组存放字符串，数组元素个数应该至少为字符串长度+1，以避免数组越界。char数组的内容，可以在初始化时设定，还可以用对数组元素赋值的办法任意改变其中的某个字符。 “” 也是合法的字符串常量，称为“空串”， 空串仍然会占据一个字节的存储空间，存放 ‘\\0’。 如果字符串常量中包含双引号，则双引号应写为‘&quot;’。而‘\\’字符在 字符串中出现时，须连写两次，变成‘\\’，以防止转译。 C语言中的结构类型两个同类型的结构变量，可以互相赋值。但是结构变量之间不能用“==”、“!=”、“&lt;”、“&gt;”、“&lt;=”、“&gt;=”进行比较运算。 一般来说，一个结构变量所占的内存空间的大小，就是结构中所有成员变量大小之和。结构变量中的各个成员变量在内存中一般是连续存放的。 并且，一个结构的成员变量可以是任何类型的，包括可以是另一个结构类型: ASCII码和char类型的关系char表示一个字符型数据，其和int在0-255范围内是等价的。而字符编码采用的是ASCII码，所以看起来和ASCII有关。在用char进行输入、输出时其值可以被当成ASCII码，输入、输出函数根据这个码找到相应的字符输入或输出。 0x02 使用格式化输入输出函数printf()和scanf()在printf和scanf中可以使用以”%”开头的控制符，指明要输入或输出的数据的类型以及格式。常用的格式控制符如下表所示：|常用格式控制符|作 用||—|—||%d|读入或输出int变量||%c|读入或输出char变量||%f|读入或输出float变量，输出时保留小数点后面6位||%lf|读入或输出double变量，输出时保留小数点后面6位||%x|以十六进制读入或输出整型变量||%lld|读入或输出long long 变量(64位整数）||%nd|(如%4d,%12d）以n字符宽度输出整数，宽度不足时用空格填充||%0nd|( 如 %04d,%012d )以n字符宽度输出整数，宽度不足时用0填充||%.nf|(如%.4f,%.3f） 输出double或float值，精确到小数点后n位| scanf的进阶使用1.用scanf可以一次读入多个类型不同的变量，只要输入的各项之间用空格分隔即可。example： 12345678910#include &lt;stdio.h&gt;int main()&#123; int n; char c; float m; scanf(\"%d%c%f\",&amp;n,&amp;c,&amp;m); /*依次输入一个整数，一个字符，再一个整数，则它们会被分别放入n,c,m；&amp;n代表“取n的地址\"，%c代表等待输入一个字符*/ printf(\"%d %c %f\",n,c,m); return 0;&#125; 输入：34 k 234.45↙输出：34 k 234.449997 2.若输入的各项之间没有用空格分隔，则等待输入字符时，不会跳过空格(空格也会被当作字符读入)，输入其他类型的数据时，会跳过空格。example： 12345678910#include &lt;stdio.h&gt;int main()&#123; int n; char c; float f; scanf(\"%d%c%f\",&amp;n,&amp;c,&amp;f); printf(\"%d %c %f\",n,c,f); return 0;&#125; 输入：34 k 456↙输出：34 0.000000 原因：c = &apos; &apos;, 读入f 时，对应输入是&apos;k&apos;，导致出错。3.如果在输入中有scanf中出现的非控制字符，则这些字符会被跳过。example： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int n,m; char c; float f; scanf(\"%d %c,%f:%d\",&amp;n,&amp;c,&amp;f,&amp;m); printf(\"%d,%c,%f,%d\",n,c,f,m); return 0;&#125;&#125; 输入：12 k,3.75:290↙输出：12,k,3.750000,290 有关sprintf()和sscanf()函数参考这篇文章:浅析C语言中printf(),sprintf(),scanf(),sscanf()的用法和区别-极客编程-博客园 0x03 分支结构与循环控制结构分支结构if语句常见错误1.错把赋值符当逻辑运算符来使用：example： 1234567int a = 0;if( a = 0 ) //a = 0的值是0printf(\"hello\");if( a = 5 ) // a = 5的值是5printf(\"Hi\");=&gt; Hi 2.互相矛盾的多个条件，如果确实只希望执行其中一个分支，应该用if和多个else if，而不要写多个if wrong example: 123456789int a = 0;if( a &gt;=0 &amp;&amp; a &lt; 5 )a = 8;if( a &gt;= 5 &amp;&amp; a &lt; 10 )printf(\"hello\");if( a &gt; 10 &amp;&amp; a &lt; 20).....if( a &gt;= 20)..... 最终会输出hello right example： 123456789int a = 0;if( a &gt;=0 &amp;&amp; a &lt; 5 )a = 8;else if( a &gt;= 5 &amp;&amp; a &lt; 10 )printf(\"hello\");else if( a &gt; 10 &amp;&amp; a &lt; 20).....else..... 不会输出 hello switch语句常见错误switch语句在进入某个case分支后，会一直执行到第一个碰到的“break;”，即使这个“break;”是在后面的case分支里面。如果没有碰到“break;”，则会向下一直执行到switch语句末尾的“}”，包括“default:”部分的语句组也会被执行。 因此，在运用switch语句时，一定要根据题目加上break关键字。 if-else与switch-case语法的区别if语句，if else if语句和switch case语句都属于流程控制语句。 在只需要判断一个条件的时候，自然是使用if语句方便有效；但是当判断条件很多的时候，我们可以使用多个if语句或者if…else if语句或者switch case语句。 if…else if语句和多个if语句的区别还是很大的，if…else if在任何一个环节满足条件的时候就将会终止判断，只处理一个满足条件的情况；而对于多个if语句，将会对每一个判断条件进行判断，自然而然会导致程序的执行效率降低。在多个判断条件的情况下，使用if…else if语句相对于使用多个if语句而言，可以减少程序的判断次数，提高效率。 在多个判断条件的情况下，不仅可以使用if…else if语句，还可以使用switch case语句。一般情况下，当判断条件较多的情况下，使用switch case语句的效率会高于使用if…else if语句。switch…case与if…else if的根本区别在于，switch…case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch…case不用像if…else if那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。 因此，当只有分支比较少的时候，if效率比switch高（因为switch需要生成跳转表）。若分支比较多，那当然是switch更高效也更清晰。 循环结构for循环语句结构特点for语句结构： 123for( 表达式1 ;表达式2;表达式3) &#123;语句组&#125; for循环结构里的“表达式1”和“表达式3”都可以是用逗号连接的若干个表达式。 for循环括号内三个语句的执行时间执行过程： 1) 计算“表达式1”。2) 计算“表达式2”，若其值为true，则执行“{ }”中的语句组，然后转到3)；若为false,则不再执行“{}”中的语句组，for语句结束，转到5)。3) 计算“表达式3”。4) 转到2)。5) 从for语句后面继续往下执行程序。 for语句的循环控制变量特点循环控制变量定义在”表达式1”中，则其只在for语句内部起作用，可以不用担心循环控制变量重名。example： 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int i = 5; for( int i = 0;i &lt; 26; ++i )&#123; printf(\"%c\\n\",char('a'+i )); &#125; for( int i = 0;i &lt; 26; i+=2 )&#123; printf(\"%c\\n\",char('a'+i )); &#125; printf(\"%d\\n\",i）;//此处的i和for里面的i无关 return 0;&#125;&gt;最后的一个输出：5#### while循环语句结构特点```cwhile(表达式) &#123;语句组&#125; 若情境是并非到达指定次数，而是满足某条件时即停止循环，则适合用while语句来实现循环。 while循环的执行过程1) 判断“表达式”是否为真，如果不为真，则转4)2) 执行“语句组”3) 转1)4) while语句结束，继续执行while语句后面的语句。 do……while循环语句结构特点123do &#123;语句组&#125; while(表达式); 如果希望循环至少要执行一次，就可以使用do…while语句。 do……while循环语句的执行过程每执行一次循环后，都要判断“表达式”的值是否为真，如果真就继续循环，如果为假，就停止循环。 while和do……while语句的区别while先判断后执行，do while先执行后判断当不满足循环条件时，while循环一次都不会执行，do while循环至少执行一次 break与continue语句break语句可以出现在循环体中(for、while、do…while循环均可)，其作用是跳出循环。并且在多重循环的情况下，break语句只能跳出直接包含它的那一重循环。 example:找兄弟数：如果两个不同的正整数，他们的和是他们的积的因子，就称这两个数为兄弟数，小的称为弟数，大的称为兄数。先后输入正整数n和m(n &lt; m) , 请在n至m这m-n+1个数中，找出一对兄弟数。如果找不到，就输出“No Solution.”。如果能找到，就找出和最小的那一对；如果有多对兄弟数和相同且都是最小，就找出弟数最小的那一对。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main() &#123; int n,m; scanf(\"%d %d\",&amp;n,&amp;m ); int a = m + 1,b = m + 1; //a,b记录已经找到的最佳兄弟数，a是弟数，b是兄数 for( int i = n; i &lt; m ; ++i ) &#123; //取弟数，共m-n种取法 if( i &gt; (a + b)/2 + 1) break; // 跳出外重循环 for( int j = i + 1; j &lt;= m; ++j ) &#123; //取兄数 if( i + j &gt; a + b ) break; // 跳出内重循环 if( i * j % (i + j) == 0 ) &#123; //发现兄弟数 if( i + j &lt; a + b) &#123; //发现和更小的兄弟数 a = i; b = j ; //更新已找到的最佳兄弟数 &#125; else if( i + j == a + b &amp;&amp; i &lt; a) //发现和相同但弟数更小的兄弟数 a = i; b = j; //更新已找到的最佳兄弟数 &#125; &#125; &#125; if( a == m + 1 ) //没找到兄弟数 printf(\"No solution.\"); else printf(\"%d,%d\\n\",a,b); return 0;&#125; continue语句可以出现在循环体中(for、while、do…while循环均可)，其作用是立即结束本次循环，并回到循环开头判断是否要进行下一次循环。在多重循环的情况下，continue只对直接包含它的那重循环起作用。 example：找10以内的偶数 1234567891011#include&lt;stdio.h&gt;int main()&#123; for( int i = 1;i &lt;= 10 ;++i ) &#123; if( i % 2 ) continue; //导致不执行后面的语句，回到循环开头 printf(\"%d,\",i); &#125; return 0;&#125; 输出：2,4,6,8,10, 0x04 初始化数组一维数字数组的初始化在通过type arrayName [ arraySize ];语句声明数组之后，需要对数组进行初始化。 在 C 中，我们可以逐个初始化数组，也可以使用一个初始化语句，如下所示： int test[5] = {1, 2, 3, 4, 5}; 需要注意的是，声明数组时方括号内的数字代表的是数组长度。数组的元素都是从0开始标号的，因此数组的第一个元素是arrayName[0],最后一个元素是arrayName[数组的总大小减去 1]。需要牢记这一点以免发生数组越界情况。 例如，有以下程序： 1234567891011121314 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define Lenth 5 int main() &#123; int test[Lenth] = &#123; 1, 2, 3, 4, 5 &#125;; int i = 0; for (i = 0; i &lt; Lenth; i++) &#123; printf(\"test数组的第%d个元素为%d,\\n\", i+1, test[i]); &#125; return 0;&#125; 运行结果为： &gt;test数组的第1个元素为1, test数组的第2个元素为2, test数组的第3个元素为3, test数组的第4个元素为4, test数组的第5个元素为5, 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 若是大括号{ }之间的值小于我们在数组声明时在方括号中指定的元素数目，则没有值与之对应的数组元素自动赋0 只能给元素逐个赋值，不能给数组整体赋值。例如给十个元素全部赋1值，只能写为：int a[10]={1,1,1,1,1,1,1,1,1,1};而不能写为：int a[10]=1. 如不给可初始化的数组赋初值，则全部元素均为0值。 以上规则也适用于 其他类型的数组例如，有以下程序： 1234567891011121314 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define Lenth 6 int main() &#123; int test[Lenth] = &#123; 1, 2, 3, 4, 5 &#125;; int i = 0; for (i = 0; i &lt; Lenth; i++) &#123; printf(\"test数组的第%d个元素为%d,\\n\", i+1, test[i]); &#125; return 0;&#125; 运行结果为： &gt;test数组的第1个元素为1, test数组的第2个元素为2, test数组的第3个元素为3, test数组的第4个元素为4, test数组的第5个元素为5, test数组的第6个元素为0, 如果在初始化时省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果我们初始化：int test[] = {1, 2, 3, 4, 5};那么创建的这个数组，它与前一个例子中所创建的数组是完全相同的。 一维字符数组的初始化C语言允许用字符串的方式对数组作初始化赋值。例如： 1char c[9]=&#123;'c',' ','p','r','o','g','r','a','m'&#125;; 可写为： 1char c[10]=&#123;\"C program\"&#125;; 或去掉&#123;&#125;写为： 1char c[10]=\"C program\"; 需要注意的是，用字符串给字符数组赋值时由于要添加结束符 ‘\\0‘，数组的长度要比字符串的长度（字符串长度不包括 ‘\\0&#39;）大1。例如：char str[] = “C program”;该数组在内存中的实际存放情况为：字符串长度为 9，数组长度为 10。因此我们需要增加一个字符数组长度用来存放\\0。 并且，上述这种字符数组的整体赋值只能在字符数组初始化时使用，不能用于字符数组的赋值，字符数组的赋值只能对其元素一一赋值，下面的赋值方法是错误的。 12char str[];str=\"I am happy\";//错误，字符数组的赋值只能按元素一一赋值 当对全体元素赋初值时也可以省去长度说明。例如： 1char c[]=&#123;'c',' ','p','r','o','g','r','a','m'&#125;; 这时C数组的长度自动定为9。 二维数字数组的初始化example： 1int a[5][3]=&#123;&#123;80,75,92&#125;,&#123;61,65&#125;,&#123;59,63,70&#125;,&#123;85,90&#125;,&#123;76,77,85&#125;&#125;; 每个内层的{}，初始化数组中的一行。同样地，二维数组初始化时，如果对每行都进行了初始化，则也可以不给出行数:example： 1int a[][3]=&#123; &#123;80,75,92&#125;,&#123;61,65&#125; &#125;; a 是一个2行3列的数组，a[1][2]被初始化成0。 二维字符数组的初始化通常情况下，二维数组的每一行分别使用一个字符串进行初始化。 例如： 1char c[3][8]=&#123;&#123;\"apple\"&#125;,&#123;\"orange\"&#125;,&#123;\"banana\"&#125;&#125;; 等价于： 1char c[3][8]=&#123;\"apple\",\"orange\",\"banana\"&#125;; 以上两条初始化语句中，二维数组的第一维大小均可省略。数组 c 的逻辑结构如下所示：| |0|1|2|3|4|5|6|7||–|–|–|–|–|–|–|–|–||c[0]|a|p|p|l|e|\\0|\\0|\\0||c[1]|o|r|a|n|g|e|\\0|\\0||c[2]|b|a|n|a|n|a|\\0|\\0| 二维数字数组的存放方式数组T a[N][M] 每一行都有M个元素第i行的元素就是a[i][0]、a[i][1]……a[i][M-1]。同一行的元素，在内存中是连续存放的。第j列的元素的元素，就是a[0][j]、a[1][j]……a[N-1][j]。a[0][0]是数组中地址最小的元素。如果a[0][0]存放在地址n，则a[i][j]存放的地址就是：n + i × M× sizeof(T) + j × sizeof(T) 数组越界数组元素的下标，可以是任何整数，可以是负数，也可以大于数组的元素个数。不会导致编译错误：example： 12345int a[10];a[-2] = 5;a[200] = 10;a[10] = 20;int m = a[30]; 但运行时很可能会出错!a[-2] = 5; a[200] = 10; a[10] = 20;int m = a[30];均可能导致程序运行出错！！！因为可能引起意外修改其他变量的值，导致程序运行结果不正确可能试图访问不该访问的内存区域，导致程序崩溃数组越界的程序，用某些编译器编译后可能可以正确运行，换一个编译器编译后就运行错误最可怕的是，编译器不会报错。 因此，我们在使用数组时，最好能初始化/声明地大一些 0x05 标识符的作用域，结构体标识符的作用域C语言中的全局变量、局部变量、静态变量要想学习变量的作用域，首先要搞懂C中的全局变量、局部变量、静态变量 局部变量：定义在函数内部的变量叫局部变量（函数的形参也是局部变量） 全局变量：定义在所有函数的外面的变量叫全局变量全局变量在所有函数中均可以使用，局部变量只能在定义它的函数内部使用 静态变量：全局变量都是静态变量。局部变量定义时如果前面加了“static”关键字，则该变量也成为静态变量静态变量的存放地址，在整个程序运行期间，都是固定不变的非静态变量(一定是局部变量)地址每次函数调用时都可能不同,在函数的一次执行期间不变如果未明确初始化，则静态变量会被自动初始化成全0(每个bit都是0），局部非静态变量的值则随机 作用域变量名、函数名、类型名统称为“标识符”。一个标识符能够起作用的范围，叫做该标识符的作用域 在一个标识符的作用域之外使用该标识符，会导致“标识符没有定义”的编译错误。使用标识符的语句，必须出现在它们的声明或定义之后在单文件的程序中，结构、函数和全局变量的作用域是其定义所在的整个文件 函数形参的作用域是整个函数局部变量的作用域，是从定义它的语句开始，到包含它的最内层的那一对大括号“{}”的右大括号 “}”为止。for循环里定义的循环控制变量，其作用域就是整个for循环同名标示符的作用域，可能一个被另一个包含。则在小的作用域里，作用域大的那个标识符被屏蔽，不起作用。 生存期所谓变量的“生存期”，指的是在此期间，变量占有内存空间，其占有的内存空间只能归它使用，不会被用来存放别的东西。而变量的生存期终止，就意味着该变量不再占有内存空间，它原来占有的内存空间，随时可能被派做他用。 全局变量的生存期，从程序被装入内存开始，到整个程序结束。静态局部变量的生存期，从定义它语句第一次被执行开始，到整个程序结束为止。函数形参的生存期从函数执行开始，到函数返回时结束。非静态局部变量的生存期，从执行到定义它的语句开始，一旦程序执行到了它的作用域之外，其生存期就终止。 使用struct定义结构体我们可以使用“struct”关键字来定义一个“结构”，也就是说定义了一个新的结构数据类型：定义方式: 1234567struct 结构名&#123;类型名 成员变量名；类型名 成员变量名；类型名 成员变量名；……&#125;; example: 12345struct Student &#123;unsigned int ID;char Name[20];float GPA;&#125;; 在经过这条语句之后Student 即成为自定义类型的名字，可以用来定义变量Stuent s1,s2; 使用结构体获得、写入结构体内部的成员变量一个结构变量的成员变量，可以完全和一个普通变量一样来使用，也可以取得其地址。使用形式： 结构变量名.成员变量名example：对于以下定义的StudentEx与Date结构体数据类型 1234567891011struct Date &#123;int year;int month;int day;&#125;;struct StudentEx &#123;unsigned int ID;char Name[20];float GPA;Date birthday;&#125;; 我们可以运行以下的main()代码段： 1234567StudentEx stu;scanf(\"%f\", &amp;stu.GPA);stu.ID = 12345;stu.Name[]=&#123;'Z','a','m'&#125;;printf(\"%f\",stu.GPA);stu.birthday.year = 1984;unsigned int * p = &amp; stu.ID; //p指向stu中的ID成员变量 结构变量的初始化结构变量可以在定义时进行初始化:例如对上面的例子，我们可以通过以下语句对结构变量进行初始化 1StudentEx stu = &#123; 1234,\"Tom\",3.78,&#123; 1984,12,28 &#125;&#125;; 指向结构变量的指针定义指向结构变量的指针方式：结构名 * 指针变量名;example: 1234StudentEx * pStudent;//定义了* pStudent为StudentEx类型的指针StudentEx Stu1;pStudent = &amp; Stu1;//使得pStudent指针指向stu1变量的起始位置StudentEx Stu2 = * pStudent; //将pStudent指针指向的stu1变量赋值给stu2变量 通过指针，访问其指向的结构变量的成员变量方式： 123指针-&gt;成员变量名or(* 指针).成员变量名 example:对于‘使用结构体获得、写入结构体内部的成员变量’中定义的结构体可以使用以下语句： 1234567StudentEx Stu;StudentEx * pStu;pStu = &amp; Stu;pStu-&gt;ID = 12345;( * pStu).GPA = 3.48;printf(\"%d\\n\",Stu.ID) //输出 12345printf(\"%f\\n\",Stu.GPA); //输出 3.48 0x06 C语言函数函数的定义一般来说函数的定义必须出现在函数调用语句之前，否则调用语句编译出错函数的定义方式： 12345返回值类型 函数名(参数1类型 参数1名称, 参数2类型 参数2名称……)&#123;语句组(即“函数体”）return 返回值；&#125; 如果函数不需要返回值，则“返回值类型”可以写“void” 函数的调用调用函数语句：函数名（参数1,参数2，……） return语句对函数的调用，也是一个表达式。函数调用表达式的值，由函数内部的return语句决定。return语句语法如下：return 返回值；return语句的功能是结束函数的执行，并将“返回值”作为结果返回。“返回值”是常量、变量或复杂的表达式均可。如果函数返回值类型为“void”，return语句就直接写：return ;需要注意的是，return 语句作为函数的出口，可以在函数中多次出现。多个return语句的“返回值”可以不同。在哪个return语句结束函数，函数的返回值就和哪个return语句里面的“返回值”相等。 0x07 C语言的指针C语言指针的定义T * p ; // T 可以是任何类型的名字，比如 int, double ,char 等等。p 的类型: T * *p 的类型： T通过表达式 * p，可以读写从地址p开始的 sizeof(T)个字节*p 等价于存放在地址p处的一个 T 类型的变量 间接引用运算符 sizeof(T*) 4字节（64位计算机上可能8字节）指针的用法&amp; : 取地址运算符&amp;x : 变量x的地址（即指向x的指针)对于类型为 T 的变量 x，&amp;x 表示变量 x 的地址(即指向x的指针) &amp;x 的类型是 T * 。example：123456char ch1 = 'A';char * pc = &amp;ch1; // 使得pc 指向变量ch1 * pc = 'B'; // 使得ch1 = 'B' char ch2 = * pc; // 使得ch2 = ch1 pc = &amp; ch2; // 使得pc 指向变量ch2 * pc = 'D'; // 使得ch2 = 'D' 指针的赋值 不同类型的指针，如果不经过强制类型转换，不能直接互相赋值example： 123456int * pn, char * pc, char c = 0x65;pn = pc; //类型不匹配，编译出错pn = &amp; c; //类型不匹配，编译出错pn = (int * ) &amp; c;int n = * pn; //n值不确定* pn = 0x12345678; //编译能过但运行可能出错 指针的运算1） 两个 同类型 的指针变量，可以比较大小 若地址p1&lt;地址p2，则 p1&lt; p2 值为真。若地址p1=地址p2，则 p1== p2 值为真。若地址p1&gt;地址p2，则 p1 &gt; p2 值为真。 2) 两个 同类型 的指针变量，可以相减 运算规则：两个T * 类型的指针 p1和p2p1 – p2 = ( 地址p1 – 地址 p2 ) / sizeof(T) 例：int * p1, * p2;若 p1 指向地址 2000,p2 指向地址 600, 则p1 – p2 = (1000 – 600)/sizeof(int) = (2000 – 600)/4 = 350 3)指针变量加减一个整数的结果是指针 例如：p : T * 类型的指针n : 整数类型的变量或常量 则p+n : T * 类型的指针，指向地址： 地址p + n × sizeof(T)n+p, p-n , * (p+n), * (p-n)等同理 4) 指针变量可以自增、自减 若T* 类型的指针p指向地址n则p++, ++p : p指向 n + sizeof(T) p–, –p : p指向 n - sizeof(T) 5）指针可以用下标运算符“[ ]”进行运算若p 是一个 T * 类型的指针， n 是整数类型的变量或常量则p[n] 等价于 * (p+n) Task End","categories":[{"name":"Learning","slug":"Learning","permalink":"http://Zam-0703.github.io/categories/Learning/"}],"tags":[{"name":"C","slug":"C","permalink":"http://Zam-0703.github.io/tags/C/"},{"name":"AST of EIC,HUST","slug":"AST-of-EIC-HUST","permalink":"http://Zam-0703.github.io/tags/AST-of-EIC-HUST/"},{"name":"Task","slug":"Task","permalink":"http://Zam-0703.github.io/tags/Task/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-04T03:33:56.908Z","updated":"2019-10-04T03:33:56.908Z","comments":true,"path":"2019/10/04/hello-world/","link":"","permalink":"http://Zam-0703.github.io/2019/10/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}